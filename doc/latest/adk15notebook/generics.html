<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.20">
<title>Generics</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="./asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="./coderay-asciidoctor.css">
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>Generics</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#generics-inJava5">Generics in Java 5</a>
<ul class="sectlevel2">
<li><a href="#_declaring_generic_types">Declaring Generic Types</a></li>
<li><a href="#_using_generic_and_parameterized_types">Using Generic and Parameterized Types</a></li>
<li><a href="#_subtypes_supertypes_and_assignability">Subtypes, Supertypes, and Assignability</a></li>
<li><a href="#_generic_methods_and_constructors">Generic Methods and Constructors</a></li>
<li><a href="#_erasure">Erasure</a></li>
</ul>
</li>
<li><a href="#generics-inAspectJ5">Generics in AspectJ 5</a>
<ul class="sectlevel2">
<li><a href="#_matching_generic_and_parameterized_types_in_pointcut_expressions">Matching generic and parameterized types in pointcut expressions</a></li>
<li><a href="#_inter_type_declarations">Inter-type Declarations</a></li>
<li><a href="#declare-parents-java5">Declare Parents</a></li>
<li><a href="#_declare_soft">Declare Soft</a></li>
<li><a href="#_generic_aspects">Generic Aspects</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="generics-inJava5">Generics in Java 5</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section provides the essential information about generics in Java 5
needed to understand how generics are treated in AspectJ 5. For a full
introduction to generics in Java, please see the documentation for the
Java 5 SDK.</p>
</div>
<div class="sect2">
<h3 id="_declaring_generic_types">Declaring Generic Types</h3>
<div class="paragraph">
<p>A generic type is declared with one or more type parameters following
the type name. By convention formal type parameters are named using a
single letter, though this is not required. A simple generic list type
(that can contain elements of any type <code>E</code>) could be declared:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">interface</span> <span class="class">List</span>&lt;E&gt; {
   <span class="predefined-type">Iterator</span>&lt;E&gt; iterator();
   <span class="type">void</span> add(E anItem);
   E remove(E anItem);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is important to understand that unlike template mechanisms there will
only be one type, and one class file, corresponding to the <code>List</code>
interface, regardless of how many different instantiations of the <code>List</code>
interface a program has (each potentially providing a different value
for the type parameter <code>E</code>). A consequence of this is that you cannot
refer to the type parameters of a type declaration in a static method or
initializer, or in the declaration or initializer of a static variable.</p>
</div>
<div class="paragraph">
<p>A <em>parameterized type</em> is an invocation of a generic type with concrete
values supplied for all of its type parameters (for example,
<code>List&lt;String&gt;</code> or <code>List&lt;Food&gt;</code>).</p>
</div>
<div class="paragraph">
<p>A generic type may be declared with multiple type parameters. In
addition to simple type parameter names, type parameter declarations can
also constrain the set of types allowed by using the <code>extends</code> keyword.
Some examples follow:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>class Foo&lt;T&gt; {&#8230;&#8203;}</code></dt>
<dd>
<p>A class <code>Foo</code> with one type parameter, <code>T</code>.</p>
</dd>
<dt class="hdlist1"><code>class Foo&lt;T,S&gt; {&#8230;&#8203;}</code></dt>
<dd>
<p>A class <code>Foo</code> with two type parameters, <code>T</code> and <code>S</code>.</p>
</dd>
<dt class="hdlist1"><code>class Foo&lt;T extends Number&gt; {&#8230;&#8203;}</code></dt>
<dd>
<p>A class <code>Foo</code> with one type parameter <code>T</code>, where <code>T</code> must be
instantiated as the type <code>Number</code> or a subtype of <code>Number</code>.</p>
</dd>
<dt class="hdlist1"><code>class Foo&lt;T, S extends T&gt; {&#8230;&#8203;}</code></dt>
<dd>
<p>A class <code>Foo</code> with two type parameters, <code>T</code> and <code>S</code>. <code>Foo</code> must be
instantiated with a type <code>S</code> that is a subtype of the type specified
for parameter <code>T</code>.</p>
</dd>
<dt class="hdlist1"><code>class Foo&lt;T extends Number &amp; Comparable&gt; {&#8230;&#8203;}</code></dt>
<dd>
<p>A class <code>Foo</code> with one type parameter, <code>T</code>. <code>Foo</code> must be instantiated
with a type that is a subtype of <code>Number</code> and that implements
<code>Comparable</code>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_using_generic_and_parameterized_types">Using Generic and Parameterized Types</h3>
<div class="paragraph">
<p>You declare a variable (or a method/constructor argument) of a
parameterized type by specifying a concrete type specfication for each
type parameter in the generic type. The following example declares a
list of strings and a list of numbers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; strings;
<span class="predefined-type">List</span>&lt;<span class="predefined-type">Number</span>&gt; numbers;</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is also possible to declare a variable of a generic type without
specifying any values for the type parameters (a <em>raw</em> type). For
example, <code>List strings</code>. In this case, unchecked warnings may be issued
by the compiler when the referenced object is passed as a parameter to a
method expecting a parameterized type such as a <code>List&lt;String&gt;</code>. New code
written in the Java 5 language would not be expected to use raw types.</p>
</div>
<div class="paragraph">
<p>Parameterized types are instantiated by specifying type parameter values
in the constructor call expression as in the following examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; strings = <span class="keyword">new</span> MyListImpl&lt;<span class="predefined-type">String</span>&gt;();
<span class="predefined-type">List</span>&lt;<span class="predefined-type">Number</span>&gt; numbers = <span class="keyword">new</span> MyListImpl&lt;<span class="predefined-type">Number</span>&gt;();</code></pre>
</div>
</div>
<div class="paragraph">
<p>When declaring parameterized types, the <code>?</code> wildcard may be used, which
stands for "some type". The <code>extends</code> and <code>super</code> keywords may be used
in conjunction with the wildcard to provide upper and lower bounds on
the types that may satisfy the type constraints. For example:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>List&lt;?&gt;</code></dt>
<dd>
<p>A list containing elements of some type, the type of the elements in
the list is unknown.</p>
</dd>
<dt class="hdlist1"><code>List&lt;? extends Number&gt;</code></dt>
<dd>
<p>A list containing elements of some type that extends Number, the exact
type of the elements in the list is unknown.</p>
</dd>
<dt class="hdlist1"><code>List&lt;? super Double&gt;</code></dt>
<dd>
<p>A list containing elements of some type that is a super-type of
Double, the exact type of the elements in the list is unknown.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>A generic type may be extended as any other type. Given a generic type
<code>Foo&lt;T&gt;</code> then a subtype <code>Goo</code> may be declared in one of the following
ways:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>class Goo extends Foo</code></dt>
<dd>
<p>Here <code>Foo</code> is used as a raw type, and the appropriate warning messages
will be issued by the compiler on attempting to invoke methods in
<code>Foo</code>.</p>
</dd>
<dt class="hdlist1"><code>class Goo&lt;E&gt; extends Foo</code></dt>
<dd>
<p><code>Goo</code> is a generic type, but the super-type <code>Foo</code> is used as a raw
type and the appropriate warning messages will be issued by the
compiler on attempting to invoke methods defined by <code>Foo</code>.</p>
</dd>
<dt class="hdlist1"><code>class Goo&lt;E&gt; extends Foo&lt;E&gt;</code></dt>
<dd>
<p>This is the most usual form. <code>Goo</code> is a generic type with one
parameter that extends the generic type <code>Foo</code> with that same
parameter. So <code>Goo&lt;String&lt;</code> is a subclass of <code>Foo&lt;String&gt;</code>.</p>
</dd>
<dt class="hdlist1"><code>class Goo&lt;E,F&gt; extends Foo&lt;E&gt;</code></dt>
<dd>
<p><code>Goo</code> is a generic type with two parameters that extends the generic
type <code>Foo</code> with the first type parameter of <code>Goo</code> being used to
parameterize <code>Foo</code>. So <code>Goo&lt;String,Integer&lt;</code> is a subclass of
<code>Foo&lt;String&gt;</code>.</p>
</dd>
<dt class="hdlist1"><code>class Goo extends Foo&lt;String&gt;</code></dt>
<dd>
<p><code>Goo</code> is a type that extends the parameterized type <code>Foo&lt;String&gt;</code>.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>A generic type may implement one or more generic interfaces, following
the type binding rules given above. A type may also implement one or
more parameterized interfaces (for example,
<code>class X implements List&lt;String&gt;</code>, however a type may not at the same
time be a subtype of two interface types which are different
parameterizations of the same interface.</p>
</div>
</div>
<div class="sect2">
<h3 id="_subtypes_supertypes_and_assignability">Subtypes, Supertypes, and Assignability</h3>
<div class="paragraph">
<p>The supertype of a generic type <code>C</code> is the type given in the extends
clause of <code>C</code>, or <code>Object</code> if no extends clause is present. Given the
type declaration</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">List</span>&lt;E&gt; <span class="directive">extends</span> <span class="predefined-type">Collection</span>&lt;E&gt; {... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>then the supertype of <code>List&lt;E&gt;</code> is <code>Collection&lt;E&gt;</code>.</p>
</div>
<div class="paragraph">
<p>The supertype of a parameterized type <code>P</code> is the type given in the
extends clause of <code>P</code>, or <code>Object</code> if no extends clause is present. Any
type parameters in the supertype are substituted in accordance with the
parameterization of <code>P</code>. An example will make this much clearer: Given
the type <code>List&lt;Double&gt;</code> and the definition of the <code>List</code> given above,
the direct supertype is <code>Collection&lt;Double&gt;</code>. <code>List&lt;Double&gt;</code> is <em>not</em>
considered to be a subtype of <code>List&lt;Number&gt;</code>.</p>
</div>
<div class="paragraph">
<p>An instance of a parameterized type <code>P&lt;T1,T2,&#8230;&#8203;Tn&gt;`may be assigned to a
variable of the same type or a supertype without casting. In addition it
may be assigned to a variable `R&lt;S1,S2,&#8230;&#8203;Sm&gt;</code> where <code>R</code> is a supertype
of <code>P</code> (the supertype relationship is reflexive), <code>m &#8656; n</code>, and for all
type parameters <code>S1..m</code>, <code>Tm</code> equals <code>Sm</code> <em>or</em> <code>Sm</code> is a wildcard type
specification and <code>Tm</code> falls within the bounds of the wildcard. For
example, <code>List&lt;String&gt;</code> can be assigned to a variable of type
<code>Collection&lt;?&gt;</code>, and <code>List&lt;Double&gt;</code> can be assigned to a variable of
type <code>List&lt;? extends Number&gt;</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_generic_methods_and_constructors">Generic Methods and Constructors</h3>
<div class="paragraph">
<p>A static method may be declared with one or more type parameters as in
the following declaration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">static</span> &lt;T&gt; T first(<span class="predefined-type">List</span>&lt;T&gt; ts) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Such a definition can appear in any type, the type parameter <code>T</code> does
not need to be declared as a type parameter of the enclosing type.</p>
</div>
<div class="paragraph">
<p>Non-static methods may also be declared with one or more type parameters
in a similar fashion:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">&lt;T <span class="directive">extends</span> <span class="predefined-type">Number</span>&gt; T max(T t1, T t2) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The same technique can be used to declare a generic constructor.</p>
</div>
</div>
<div class="sect2">
<h3 id="_erasure">Erasure</h3>
<div class="paragraph">
<p>Generics in Java are implemented using a technique called <em>erasure</em>. All
type parameter information is erased from the run-time type system.
Asking an object of a parameterized type for its class will return the
class object for the raw type (eg. <code>List</code> for an object declared to be
of type <code>List&lt;String&gt;</code>. A consequence of this is that you cannot at
runtime ask if an object is an <code>instanceof</code> a parameterized type.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="generics-inAspectJ5">Generics in AspectJ 5</h2>
<div class="sectionbody">
<div class="paragraph">
<p>AspectJ 5 provides full support for all of the Java 5 language features,
including generics. Any legal Java 5 program is a legal AspectJ 5
progam. In addition, AspectJ 5 provides support for generic and
parameterized types in pointcuts, inter-type declarations, and declare
statements. Parameterized types may freely be used within aspect
members, and support is also provided for generic <em>abstract</em> aspects.</p>
</div>
<div class="sect2">
<h3 id="_matching_generic_and_parameterized_types_in_pointcut_expressions">Matching generic and parameterized types in pointcut expressions</h3>
<div class="paragraph">
<p>The simplest way to work with generic and parameterized types in
pointcut expressions and type patterns is simply to use the raw type
name. For example, the type pattern <code>List</code> will match the generic type
<code>List&lt;E&gt;</code> and any parameterization of that type
(<code>List&lt;String&gt;, List&lt;?&gt;, List&lt;? extends Number&gt;</code> and so on. This ensures
that pointcuts written in existing code that is not generics-aware will
continue to work as expected in AspectJ 5. It is also the recommended
way to match against generic and parameterized types in AspectJ 5 unless
you explicitly wish to narrow matches to certain parameterizations of a
generic type.</p>
</div>
<div class="paragraph">
<p>Generic methods and constructors, and members defined in generic types,
may use type variables as part of their signature. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Utils</span> {

  <span class="comment">/** static generic method */</span>
  <span class="directive">static</span> &lt;T&gt; T first(<span class="predefined-type">List</span>&lt;T&gt; ts) { ... }

  <span class="comment">/** instance generic method */</span>
  &lt;T <span class="directive">extends</span> <span class="predefined-type">Number</span>&gt; T max(T t1, T t2) { ... }

}

<span class="directive">public</span> <span class="type">class</span> <span class="class">G</span>&lt;T&gt; {

   <span class="comment">// field with parameterized type</span>
   T myData;

   <span class="comment">// method with parameterized return type</span>
   <span class="directive">public</span> <span class="predefined-type">List</span>&lt;T&gt; getAllDataItems() {...}

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>AspectJ 5 does not allow the use of type variables in pointcut
expressions and type patterns. Instead, members that use type parameters
as part of their signature are matched by their <em>erasure</em>. Java 5
defines the rules for determing the erasure of a type as follows.</p>
</div>
<div class="paragraph">
<p>Let <code>|T|</code> represent the erasure of some type <code>T</code>. Then:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The erasure of a parameterized type <code>T&lt;T1,&#8230;&#8203;,Tn&gt;</code> is <code>|T|</code>.
For example, the erasure of <code>List&lt;String&gt;</code> is <code>List</code>.</p>
</li>
<li>
<p>The erasure of a nested type <code>T.C</code> is <code>|T|.C</code>.
For example, the erasure of the nested type <code>Foo&lt;T&gt;.Bar</code> is <code>Foo.Bar</code>.</p>
</li>
<li>
<p>The erasure of an array type <code>T[]</code> is <code>|T|[]</code>.
For example, the erasure of <code>List&lt;String&gt;[]</code> is <code>List[]</code>.</p>
</li>
<li>
<p>The erasure of a type variable is its leftmost bound.
For example, the erasure of a type variable <code>P</code> is <code>Object</code>,
and the erasure of a type variable <code>N extends Number</code> is <code>Number</code>.</p>
</li>
<li>
<p>The erasure of every other type is the type itself.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Applying these rules to the earlier examples, we find that the methods
defined in <code>Utils</code> can be matched by a signature pattern matching
<code>static Object Utils.first(List)</code> and <code>Number Utils.max(Number, Number)</code>
respectively. The members of the generic type <code>G</code> can be matched by a
signature pattern matching <code>Object G.myData</code> and
<code>public List G.getAllDataItems()</code> respectively.</p>
</div>
<div class="sect3">
<h4 id="_restricting_matching_using_parameterized_types">Restricting matching using parameterized types</h4>
<div class="paragraph">
<p>Pointcut matching can be further restricted to match only given
parameterizations of parameter types (methods and constructors), return
types (methods) and field types (fields). This is achieved by specifying
a parameterized type pattern at the appropriate point in the signature
pattern. For example, given the class <code>Foo</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Foo</span> {

  <span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; myStrings;
  <span class="predefined-type">List</span>&lt;<span class="predefined-type">Float</span>&gt;  myFloats;

  <span class="directive">public</span> <span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; getStrings() { <span class="keyword">return</span> myStrings; }
  <span class="directive">public</span> <span class="predefined-type">List</span>&lt;<span class="predefined-type">Float</span>&gt; getFloats() { <span class="keyword">return</span> myFloats; }

  <span class="directive">public</span> <span class="type">void</span> addStrings(<span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; evenMoreStrings) {
     myStrings.addAll(evenMoreStrings);
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then a <code>get</code> join point for the field <code>myStrings</code> can be matched by the
pointcut <code>get(List Foo.myStrings)</code> and by the pointcut
<code>get(List&lt;String&gt; Foo.myStrings)</code>, but <em>not</em> by the pointcut
<code>get(List&lt;Number&gt; *)</code>.</p>
</div>
<div class="paragraph">
<p>A <code>get</code> join point for the field <code>myFloats</code> can be matched by the
pointcut <code>get(List Foo.myFloats)</code>, the pointcut <code>get(List&lt;Float&gt; *)</code>,
and the pointcut <code>get(List&lt;Number+&gt; *)</code>. This last example shows how
AspectJ type patterns can be used to match type parameters types just
like any other type. The pointcut <code>get(List&lt;Double&gt; *)</code> does <em>not</em>
match.</p>
</div>
<div class="paragraph">
<p>The execution of the methods <code>getStrings</code> and <code>getFloats</code> can be matched
by the pointcut expression <code>execution(List get*(..))</code>, and the pointcut
expression <code>execution(List&lt;*&gt; get*(..))</code>, but only <code>getStrings</code> is
matched by <code>execution(List&lt;String&gt; get*(..))</code> and only <code>getFloats</code> is
matched by <code>execution(List&lt;Number+&gt; get*(..))</code></p>
</div>
<div class="paragraph">
<p>A call to the method <code>addStrings</code> can be matched by the pointcut
expression <code>call(* addStrings(List))</code> and by the expression
<code>call(* addStrings(List&lt;String&gt;))</code>, but <em>not</em> by the expression
<code>call(* addStrings(List&lt;Number&gt;))</code>.</p>
</div>
<div class="paragraph">
<p>Remember that any type variable reference in a generic member is
<em>always</em> matched by its erasure. Thus given the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">G</span>&lt;T&gt; {
    <span class="predefined-type">List</span>&lt;T&gt; foo(<span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; ls) { <span class="keyword">return</span> <span class="predefined-constant">null</span>; }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The execution of <code>foo</code> can be matched by <code>execution(List foo(List))</code>,
<code>execution(List foo(List&lt;String&gt;&gt;))</code>, and
<code>execution(* foo(List&lt;String&lt;))`but <em>not</em> by
`execution(List&lt;Object&gt; foo(List&lt;String&gt;&gt;)</code> since the erasure of
<code>List&lt;T&gt;</code> is <code>List</code> and not <code>List&lt;Object&gt;</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_generic_wildcards_and_signature_matching">Generic wildcards and signature matching</h4>
<div class="paragraph">
<p>When it comes to signature matching, a type parameterized using a
generic wildcard is a distinct type. For example, <code>List&lt;?&gt;</code> is a very
different type to <code>List&lt;String&gt;</code>, even though a variable of type
<code>List&lt;String&gt;</code> can be assigned to a variable of type <code>List&lt;?&gt;</code>. Given
the methods:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">C</span> {
  <span class="directive">public</span> <span class="type">void</span> foo(<span class="predefined-type">List</span>&lt;? <span class="directive">extends</span> <span class="predefined-type">Number</span>&gt; listOfSomeNumberType) {}
  <span class="directive">public</span> <span class="type">void</span> bar(<span class="predefined-type">List</span>&lt;?&gt; listOfSomeType) {}
  <span class="directive">public</span> <span class="type">void</span> goo(<span class="predefined-type">List</span>&lt;<span class="predefined-type">Double</span>&gt; listOfDoubles) {}
}</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>execution(* C.*(List))</code></dt>
<dd>
<p>Matches an execution join point for any of the three methods.</p>
</dd>
<dt class="hdlist1"><code>execution(* C.*(List&lt;? extends Number&gt;))</code></dt>
<dd>
<p>matches only the execution of <code>foo</code>, and <em>not</em> the execution of <code>goo</code>
since <code>List&lt;? extends Number&gt;</code> and <code>List&lt;Double&gt;</code> are distinct types.</p>
</dd>
<dt class="hdlist1"><code>execution(* C.*(List&lt;?&gt;))</code></dt>
<dd>
<p>matches only the execution of <code>bar</code>.</p>
</dd>
<dt class="hdlist1"><code>execution(* C.*(List&lt;? extends Object+&gt;))</code></dt>
<dd>
<p>matches both the execution of <code>foo</code> and the execution of <code>bar</code> since
the upper bound of <code>List&lt;?&gt;</code> is implicitly <code>Object</code>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_treatment_of_bridge_methods">Treatment of bridge methods</h4>
<div class="paragraph">
<p>Under certain circumstances a Java 5 compiler is required to create
<em>bridge methods</em> that support the compilation of programs using raw
types. Consider the types</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">Generic</span>&lt;T&gt; {
  <span class="directive">public</span> T foo(T someObject) {
    <span class="keyword">return</span> someObject;
  }
}

<span class="type">class</span> <span class="class">SubGeneric</span>&lt;N <span class="directive">extends</span> <span class="predefined-type">Number</span>&gt; <span class="directive">extends</span> Generic&lt;N&gt; {
  <span class="directive">public</span> N foo(N someNumber) {
    <span class="keyword">return</span> someNumber;
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The class <code>SubGeneric</code> extends <code>Generic</code> and overrides the method <code>foo</code>.
Since the upper bound of the type variable <code>N</code> in <code>SubGeneric</code> is
different to the upper bound of the type variable <code>T</code> in <code>Generic</code>, the
method <code>foo</code> in <code>SubGeneric</code> has a different erasure to the method <code>foo</code>
in <code>Generic</code>. This is an example of a case where a Java 5 compiler will
create a <em>bridge method</em> in <code>SubGeneric</code>. Although you never see it, the
bridge method will look something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="predefined-type">Object</span> foo(<span class="predefined-type">Object</span> arg) {
  <span class="predefined-type">Number</span> n = (<span class="predefined-type">Number</span>) arg; <span class="comment">// &quot;bridge&quot; to the signature defined in this type</span>
<span class="keyword">return</span> foo(n);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bridge methods are synthetic artefacts generated as a result of a
particular compilation strategy and have no execution join points in
AspectJ 5. So the pointcut <code>execution(Object SubGeneric.foo(Object))</code>
does not match anything. (The pointcut
<code>execution(Object Generic.foo(Object))</code> matches the execution of <code>foo</code>
in both <code>Generic</code> and <code>SubGeneric</code> since both are implementations of
<code>Generic.foo</code>).</p>
</div>
<div class="paragraph">
<p>It <em>is</em> possible to <em>call</em> a bridge method as the following short code
snippet demonstrates. Such a call <em>does</em> result in a call join point for
the call to the method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">SubGeneric rawType = <span class="keyword">new</span> SubGeneric();
rawType.foo(<span class="string"><span class="delimiter">&quot;</span><span class="content">hi</span><span class="delimiter">&quot;</span></span>);  <span class="comment">// call to bridge method (will result in a runtime failure in this case)</span>
<span class="predefined-type">Object</span> n = <span class="keyword">new</span> <span class="predefined-type">Integer</span>(<span class="integer">5</span>);
rawType.foo(n);     <span class="comment">// call to bridge method that would succeed at runtime</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_runtime_type_matching_with_this_target_and_args">Runtime type matching with this(), target() and args()</h4>
<div class="paragraph">
<p>The <code>this()</code>, <code>target()</code>, and <code>args()</code> pointcut expressions all match
based on the runtime type of their arguments. Because Java 5 implements
generics using erasure, it is not possible to ask at runtime whether an
object is an instance of a given parameterization of a type (only
whether or not it is an instance of the erasure of that parameterized
type). Therefore AspectJ 5 does not support the use of parameterized
types with the <code>this()</code> and <code>target()</code> pointcuts. Parameterized types
may however be used in conjunction with <code>args()</code>. Consider the following
class</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">C</span> {
  <span class="directive">public</span> <span class="type">void</span> foo(<span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; listOfStrings) {}

  <span class="directive">public</span> <span class="type">void</span> bar(<span class="predefined-type">List</span>&lt;<span class="predefined-type">Double</span>&gt; listOfDoubles) {}

  <span class="directive">public</span> <span class="type">void</span> goo(<span class="predefined-type">List</span>&lt;? <span class="directive">extends</span> <span class="predefined-type">Number</span>&gt; listOfSomeNumberType) {}
}</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>args(List)</code></dt>
<dd>
<p>will match an execution or call join point for any of these methods</p>
</dd>
<dt class="hdlist1"><code>args(List&lt;String&gt;)</code></dt>
<dd>
<p>will match an execution or call join point for <code>foo</code>.</p>
</dd>
<dt class="hdlist1"><code>args(List&lt;Double&gt;)</code></dt>
<dd>
<p>matches an execution or call join point for <code>bar</code>, and <em>may</em> match at
an execution or call join point for <code>goo</code> since it is legitimate to
pass an object of type <code>List&lt;Double&gt;</code> to a method expecting a
<code>List&lt;? extends Number&gt;</code>.</p>
<div class="paragraph">
<p>In this situation, a runtime test would normally be applied to
ascertain whether or not the argument was indeed an instance of the
required type. However, in the case of parameterized types such a test
is not possible and therefore AspectJ 5 considers this a match, but
issues an <em>unchecked</em> warning. For example, compiling the aspect <code>A</code>
below with the class <code>C</code> produces the compilation warning: <code>unchecked
match of List&lt;Double&gt; with List&lt;? extends Number&gt; when argument is an
instance of List at join point method-execution(void C.goo(List&lt;?
extends Number&gt;)) [Xlint:uncheckedArgument]</code>;</p>
</div>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> aspect A {
   before(<span class="predefined-type">List</span>&lt;<span class="predefined-type">Double</span>&gt; listOfDoubles) : execution(* C.*(..)) &amp;&amp; args(listOfDoubles) {
      <span class="keyword">for</span> (<span class="predefined-type">Double</span> d : listOfDoubles) {
         <span class="comment">// do something</span>
      }
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Like all Lint messages, the <code>uncheckedArgument</code> warning can be
configured in severity from the default warning level to error or even
ignore if preferred. In addition, AspectJ 5 offers the annotation
<code>@SuppressAjWarnings</code> which is the AspectJ equivalent of Java&#8217;s
<code>@SuppressWarnings</code> annotation. If the advice is annotated with
<code>@SuppressWarnings</code> then <em>all</em> lint warnings issued during matching of
pointcut associated with the advice will be suppressed. To suppress just
an <code>uncheckedArgument</code> warning, use the annotation
<code>@SuppressWarnings("uncheckedArgument")</code> as in the following examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation.SuppressAjWarnings</span>
<span class="include">public</span> <span class="include">aspect</span> <span class="include">A</span> {
   <span class="annotation">@SuppressAjWarnings</span>   <span class="comment">// will not see *any* lint warnings for this advice</span>
   <span class="include">before</span>(<span class="include">List</span>&lt;<span class="include">Double</span>&gt; <span class="include">listOfDoubles</span>) : <span class="include">execution</span>(* <span class="include">C</span>.*(..)) &amp;&amp; <span class="include">args</span>(<span class="include">listOfDoubles</span>) {
      <span class="include">for</span> (<span class="include">Double</span> <span class="include">d</span> : <span class="include">listOfDoubles</span>) {
         <span class="comment">// do something</span>
      }
   }

   <span class="annotation">@SuppressAjWarnings</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">uncheckedArgument</span><span class="delimiter">&quot;</span></span>)   <span class="comment">// will not see *any* lint warnings for this advice</span>
   <span class="include">before</span>(<span class="include">List</span>&lt;<span class="include">Double</span>&gt; <span class="include">listOfDoubles</span>) : <span class="include">execution</span>(* <span class="include">C</span>.*(..)) &amp;&amp; <span class="include">args</span>(<span class="include">listOfDoubles</span>) {
      <span class="include">for</span> (<span class="include">Double</span> <span class="include">d</span> : <span class="include">listOfDoubles</span>) {
         <span class="comment">// do something</span>
      }
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The safest way to deal with <code>uncheckedArgument</code> warnings however is to
restrict the pointcut to match only at those join points where the
argument is guaranteed to match. This is achieved by combining <code>args</code>
with a <code>call</code> or <code>execution</code> signature matching pointcut. In the
following example the advice will match the execution of <code>bar</code> but not
of <code>goo</code> since the signature of <code>goo</code> is not matched by the execution
pointcut expression.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> aspect A {
   before(<span class="predefined-type">List</span>&lt;<span class="predefined-type">Double</span>&gt; listOfDoubles) : execution(* C.*(<span class="predefined-type">List</span>&lt;<span class="predefined-type">Double</span>&gt;)) &amp;&amp; args(listOfDoubles) {
      <span class="keyword">for</span> (<span class="predefined-type">Double</span> d : listOfDoubles) {
         <span class="comment">// do something</span>
      }
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Generic wildcards can be used in args type patterns, and matching
follows regular Java 5 assignability rules. For example, <code>args(List&lt;?&gt;)</code>
will match a list argument of any type, and
<code>args(List&lt;? extends Number&gt;)</code> will match an argument of type
<code>List&lt;Number&gt;, List&lt;Double&gt;, List&lt;Float&gt;</code> and so on. Where a match
cannot be fully statically determined, the compiler will once more issue
an <code>uncheckedArgument</code> warning.</p>
</div>
<div class="paragraph">
<p>Consider the following program:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">C</span> {
   <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
      C c = <span class="keyword">new</span> C();
      <span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; ls = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;<span class="predefined-type">String</span>&gt;();
      <span class="predefined-type">List</span>&lt;<span class="predefined-type">Double</span>&gt; ld = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;<span class="predefined-type">Double</span>&gt;();
      c.foo(<span class="string"><span class="delimiter">&quot;</span><span class="content">hi</span><span class="delimiter">&quot;</span></span>);
      c.foo(ls);
      c.foo(ld);
   }

   <span class="directive">public</span> <span class="type">void</span> foo(<span class="predefined-type">Object</span> anObject) {}
}

aspect A {
    before(<span class="predefined-type">List</span>&lt;? <span class="directive">extends</span> <span class="predefined-type">Number</span>&gt; aListOfSomeNumberType)
      : call(* foo(..)) &amp;&amp; args(aListOfSomeNumberType) {
       <span class="comment">// process list...</span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>From the signature of <code>foo</code> all we know is that the runtime argument
will be an instance of <code>Object</code>.Compiling this program gives the
unchecked argument warning: <code>unchecked match of List&lt;? extends Number&gt;
with List when argument is an instance of List at join point
method-execution(void C.foo(Object)) [Xlint:uncheckedArgument]</code>. The
advice will not execute at the call join point for <code>c.foo("hi")</code> since
<code>String</code> is not an instance of <code>List</code>. The advice <em>will</em> execute at the
call join points for <code>c.foo(ls)</code> and <code>c.foo(ld)</code> since in both cases the
argument is an instance of <code>List</code>.</p>
</div>
<div class="paragraph">
<p>Combine a wildcard argument type with a signature pattern to avoid
unchecked argument matches. In the example below we use the signature
pattern <code>List&lt;Number+&gt;</code> to match a call to any method taking a
<code>List&lt;Number&gt;, List&lt;Double&gt;, List&lt;Float&gt;</code> and so on. In addition the
signature pattern <code>List&lt;? extends Number+&gt;</code> can be used to match a call
to a method declared to take a <code>List&lt;? extends Number&gt;</code>,
<code>List&lt;? extends Double&gt;</code> and so on. Taken together, these restrict
matching to only those join points at which the argument is guaranteed
to be an instance of <code>List&lt;? extends Number&gt;</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect A {
    before(<span class="predefined-type">List</span>&lt;? <span class="directive">extends</span> <span class="predefined-type">Number</span>&gt; aListOfSomeNumberType)
      : (call(* foo(<span class="predefined-type">List</span>&lt;<span class="predefined-type">Number</span>+&gt;)) || call(* foo(<span class="predefined-type">List</span>&lt;? <span class="directive">extends</span> <span class="predefined-type">Number</span>+&gt;)))
        &amp;&amp; args(aListOfSomeNumberType) {
        <span class="comment">// process list...</span>
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_binding_return_values_in_after_returning_advice">Binding return values in after returning advice</h4>
<div class="paragraph">
<p>After returning advice can be used to bind the return value from a
matched join point. AspectJ 5 supports the use of a parameterized type
in the returning clause, with matching following the same rules as
described for args. For example, the following aspect matches the
execution of any method returning a <code>List</code>, and makes the returned list
available to the body of the advice.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> aspect A {
  pointcut executionOfAnyMethodReturningAList() : execution(<span class="predefined-type">List</span> *(..));

  after() returning(<span class="predefined-type">List</span>&lt;?&gt; listOfSomeType) : executionOfAnyMethodReturningAList() {
    <span class="keyword">for</span> (<span class="predefined-type">Object</span> element : listOfSomeType) {
       <span class="comment">// process element...</span>
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The pointcut uses the raw type pattern <code>List</code>, and hence it matches
methods returning any kind of list (<code>List&lt;String&gt;, List&lt;Double&gt;</code>, and so
on). We&#8217;ve chosen to bind the returned list as the parameterized type
<code>List&lt;?&gt;</code> in the advice since Java&#8217;s type checking will now ensure that
we only perform safe operations on the list.</p>
</div>
<div class="paragraph">
<p>Given the class</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">C</span> {
  <span class="directive">public</span> <span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; foo(<span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; listOfStrings) {...}
  <span class="directive">public</span> <span class="predefined-type">List</span>&lt;<span class="predefined-type">Double</span>&gt; bar(<span class="predefined-type">List</span>&lt;<span class="predefined-type">Double</span>&gt; listOfDoubles) {...}
  <span class="directive">public</span> <span class="predefined-type">List</span>&lt;? <span class="directive">extends</span> <span class="predefined-type">Number</span>&gt; goo(<span class="predefined-type">List</span>&lt;? <span class="directive">extends</span> <span class="predefined-type">Number</span>&gt; listOfSomeNumberType) {...}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The advice in the aspect below will run after the execution of <code>bar</code> and
bind the return value. It will also run after the execution of <code>goo</code> and
bind the return value, but gives an <code>uncheckedArgument</code> warning during
compilation. It does <em>not</em> run after the execution of <code>foo</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> aspect Returning {
  after() returning(<span class="predefined-type">List</span>&lt;<span class="predefined-type">Double</span>&gt; listOfDoubles) : execution(* C.*(..)) {
     <span class="keyword">for</span>(<span class="predefined-type">Double</span> d : listOfDoubles) {
        <span class="comment">// process double...</span>
     }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As with <code>args</code> you can guarantee that after returning advice only
executes on lists <em>statically determinable</em> to be of the right type by
specifying a return type pattern in the associated pointcut. The
<code>@SuppressAjWarnings</code> annotation can also be used if desired.</p>
</div>
</div>
<div class="sect3">
<h4 id="_declaring_pointcuts_inside_generic_types">Declaring pointcuts inside generic types</h4>
<div class="paragraph">
<p>Pointcuts can be declared in both classes and aspects. A pointcut
declared in a generic type may use the type variables of the type in
which it is declared. All references to a pointcut declared in a generic
type from outside of that type must be via a parameterized type
reference, and not a raw type reference.</p>
</div>
<div class="paragraph">
<p>Consider the generic type <code>Generic</code> with a pointcut <code>foo</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Generic</span>&lt;T&gt; {
   <span class="comment">/**
    * matches the execution of any implementation of a method defined for T
    */</span>
   <span class="directive">public</span> pointcut foo() : execution(* T.*(..));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Such a pointcut must be refered to using a parameterized reference as
shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> aspect A {
  <span class="comment">// runs before the execution of any implementation of a method defined for MyClass</span>
  before() : Generic&lt;MyClass&gt;.foo() {
     <span class="comment">// ...</span>
  }

  <span class="comment">// runs before the execution of any implementation of a method defined for YourClass</span>
  before() : Generic&lt;YourClass&gt;.foo() {
      <span class="comment">// ...</span>
  }

  <span class="comment">// results in a compilation error - raw type reference</span>
  before() : Generic.foo() { }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_inter_type_declarations">Inter-type Declarations</h3>
<div class="paragraph">
<p>AspectJ 5 supports the inter-type declaration of generic methods, and of
members on generic types. For generic methods, the syntax is exactly as
for a regular method declaration, with the addition of the target type
specification:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>&lt;T extends Number&gt; T Utils.max(T first, T second) {&#8230;&#8203;}</code></dt>
<dd>
<p>Declares a generic instance method <code>max</code> on the class <code>Util</code>. The
<code>max</code> method takes two arguments, <code>first</code> and <code>second</code> which must both
be of the same type (and that type must be <code>Number</code> or a subtype of
<code>Number</code>) and returns an instance of that type.</p>
</dd>
<dt class="hdlist1"><code>static &lt;E&gt; E Utils.first(List&lt;E&gt; elements) {&#8230;&#8203;}</code></dt>
<dd>
<p>Declares a static generic method <code>first</code> on the class <code>Util</code>. The
<code>first</code> method takes a list of elements of some type, and returns an
instance of that type.</p>
</dd>
<dt class="hdlist1">&lt;T&gt; Sorter.new(List&lt;T&gt; elements,Comparator&lt;? super T&gt; comparator) <code>{&#8230;&#8203;}</code></dt>
<dd>
<p>Declares a constructor on the class <code>Sorter</code>. The constructor takes a
list of elements of some type, and a comparator that can compare
instances of the element type.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>A generic type may be the target of an inter-type declaration, used
either in its raw form or with type parameters specified. If type
parameters are specified, then the number of type parameters given must
match the number of type parameters in the generic type declaration.
Type parameter <em>names</em> do not have to match. For example, given the
generic type <code>Foo&lt;T,S extends Number&gt;</code> then:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>String Foo.getName() {&#8230;&#8203;}</code></dt>
<dd>
<p>Declares a <code>getName</code> method on behalf of the type <code>Foo</code>. It is not
possible to refer to the type parameters of Foo in such a declaration.</p>
</dd>
<dt class="hdlist1"><code>public R Foo&lt;Q, R&gt;.getMagnitude() {&#8230;&#8203;}</code></dt>
<dd>
<p>Declares a method <code>getMagnitude</code> on the generic class <code>Foo</code>. The
method returns an instance of the type substituted for the second type
parameter in an invocation of <code>Foo</code> If <code>Foo</code> is declared as
<code>Foo&lt;T,N extends Number&gt; {&#8230;&#8203;}</code> then this inter-type declaration is
equivalent to the declaration of a method <code>public N getMagnitude()</code>
within the body of <code>Foo</code>.</p>
</dd>
<dt class="hdlist1"><code>R Foo&lt;Q, R extends Number&gt;.getMagnitude() {&#8230;&#8203;}</code></dt>
<dd>
<p>Results in a compilation error since a bounds specification is not
allowed in this form of an inter-type declaration (the bounds are
determined from the declaration of the target type).</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>A parameterized type may not be the target of an inter-type declaration.
This is because there is only one type (the generic type) regardless of
how many different invocations (parameterizations) of that generic type
are made in a program. Therefore it does not make sense to try and
declare a member on behalf of (say) <code>Bar&lt;String&gt;</code>, you can only declare
members on the generic type <code>Bar&lt;T&gt;</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="declare-parents-java5">Declare Parents</h3>
<div class="paragraph">
<p>Both generic and parameterized types can be used as the parent type in a
<code>declare parents</code> statement (as long as the resulting type hierarchy
would be well-formed in accordance with Java&#8217;s sub-typing rules).
Generic types may also be used as the target type of a <code>declare parents</code>
statement.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>declare parents: Foo implements List&lt;String&gt;</code></dt>
<dd>
<p>The <code>Foo</code> type implements the <code>List&lt;String&gt;</code> interface. If <code>Foo</code>
already implements some other parameterization of the <code>List</code> interface
(for example, <code>List&lt;Integer&gt;</code> then a compilation error will result
since a type cannot implement multiple parameterizations of the same
generic interface type.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_declare_soft">Declare Soft</h3>
<div class="paragraph">
<p>It is an error to use a generic or parameterized type as the softened
exception type in a declare soft statement. Java 5 does not permit a
generic class to be a direct or indirect subtype of <code>Throwable</code> (JLS
8.1.2).</p>
</div>
</div>
<div class="sect2">
<h3 id="_generic_aspects">Generic Aspects</h3>
<div class="paragraph">
<p>AspectJ 5 allows an <em>abstract</em> aspect to be declared as a generic type.
Any concrete aspect extending a generic abstract aspect must extend a
parameterized version of the abstract aspect. Wildcards are not
permitted in this parameterization.</p>
</div>
<div class="paragraph">
<p>Given the aspect declaration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">abstract</span> aspect ParentChildRelationship&lt;P,C&gt; {
    <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>then</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>public aspect FilesInFolders extends ParentChildRelationship&lt;Folder,File&gt; {&#8230;&#8203;</code></dt>
<dd>
<p>declares a concrete sub-aspect, <code>FilesInFolders</code> which extends the
parameterized abstract aspect <code>ParentChildRelationship&lt;Folder,File&gt;</code>.</p>
</dd>
<dt class="hdlist1"><code>public aspect FilesInFolders extends ParentChildRelationship {&#8230;&#8203;</code></dt>
<dd>
<p>results in a compilation error since the <code>ParentChildRelationship</code>
aspect must be fully parameterized.</p>
</dd>
<dt class="hdlist1"><code>public aspect ThingsInFolders&lt;T&gt; extends ParentChildRelationship&lt;Folder,T&gt;</code></dt>
<dd>
<p>results in a compilation error since concrete aspects may not have
type parameters.</p>
</dd>
<dt class="hdlist1"><code>public abstract aspect ThingsInFolders&lt;T&gt; extends ParentChildRelationship&lt;Folder,T&gt;</code></dt>
<dd>
<p>declares a sub-aspect of <code>ParentChildRelationship</code> in which <code>Folder</code>
plays the role of parent (is bound to the type variable <code>P</code>).</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The type parameter variables from a generic aspect declaration may be
used in place of a type within any member of the aspect, <em>except for
within inter-type declarations</em>. For example, we can declare a
<code>ParentChildRelationship</code> aspect to manage the bi-directional
relationship between parent and child nodes as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">/**
 * a generic aspect, we've used descriptive role names for the type variables
 * (Parent and Child) but you could use anything of course
 */</span>
<span class="directive">public</span> <span class="directive">abstract</span> aspect ParentChildRelationship&lt;Parent,Child&gt; {

  <span class="comment">/** generic interface implemented by parents */</span>
  <span class="type">interface</span> <span class="class">ParentHasChildren</span>&lt;C <span class="directive">extends</span> ChildHasParent&gt;{
    <span class="predefined-type">List</span>&lt;C&gt; getChildren();
    <span class="type">void</span> addChild(C child);
    <span class="type">void</span> removeChild(C child);
  }

  <span class="comment">/** generic interface implemented by children */</span>
  <span class="type">interface</span> <span class="class">ChildHasParent</span>&lt;P <span class="directive">extends</span> ParentHasChildren&gt;{
    P getParent();
    <span class="type">void</span> setParent(P parent);
  }

  <span class="comment">/** ensure the parent type implements ParentHasChildren&lt;child type&gt; */</span>
  declare parents: Parent <span class="directive">implements</span> ParentHasChildren&lt;Child&gt;;

  <span class="comment">/** ensure the child type implements ChildHasParent&lt;parent type&gt; */</span>
  declare parents: Child <span class="directive">implements</span> ChildHasParent&lt;Parent&gt;;

  <span class="comment">// Inter-type declarations made on the *generic* interface types to provide</span>
  <span class="comment">// default implementations.</span>

  <span class="comment">/** list of children maintained by parent */</span>
  <span class="directive">private</span> <span class="predefined-type">List</span>&lt;C&gt; ParentHasChildren&lt;C&gt;.children = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;C&gt;();

  <span class="comment">/** reference to parent maintained by child */</span>
  <span class="directive">private</span> P ChildHasParent&lt;P&gt;.parent;

  <span class="comment">/** Default implementation of getChildren for the generic type ParentHasChildren */</span>
  <span class="directive">public</span> <span class="predefined-type">List</span>&lt;C&gt; ParentHasChildren&lt;C&gt;.getChildren() {
        <span class="keyword">return</span> <span class="predefined-type">Collections</span>.unmodifiableList(children);
  }

  <span class="comment">/** Default implementation of getParent for the generic type ChildHasParent */</span>
  <span class="directive">public</span> P ChildHasParent&lt;P&gt;.getParent() {
       <span class="keyword">return</span> parent;
  }

  <span class="comment">/**
    * Default implementation of addChild, ensures that parent of child is
    * also updated.
    */</span>
  <span class="directive">public</span> <span class="type">void</span> ParentHasChildren&lt;C&gt;.addChild(C child) {
       <span class="keyword">if</span> (child.parent != <span class="predefined-constant">null</span>) {
         child.parent.removeChild(child);
       }
       children.add(child);
       child.parent = <span class="local-variable">this</span>;
    }

   <span class="comment">/**
     * Default implementation of removeChild, ensures that parent of
     * child is also updated.
     */</span>
   <span class="directive">public</span> <span class="type">void</span> ParentHasChildren&lt;C&gt;.removeChild(C child) {
       <span class="keyword">if</span> (children.remove(child)) {
         child.parent = <span class="predefined-constant">null</span>;
       }
    }

    <span class="comment">/**
      * Default implementation of setParent for the generic type ChildHasParent.
      * Ensures that this child is added to the children of the parent too.
      */</span>
    <span class="directive">public</span> <span class="type">void</span> ChildHasParent&lt;P&gt;.setParent(P parent) {
       parent.addChild(<span class="local-variable">this</span>);
    }

    <span class="comment">/**
      * Matches at an addChild join point for the parent type P and child type C
      */</span>
    <span class="directive">public</span> pointcut addingChild(Parent p, Child c) :
      execution(* ParentHasChildren.addChild(ChildHasParent)) &amp;&amp; <span class="local-variable">this</span>(p) &amp;&amp; args(c);

    <span class="comment">/**
      * Matches at a removeChild join point for the parent type P and child type C
      */</span>
    <span class="directive">public</span> pointcut removingChild(Parent p, Child c) :
      execution(* ParentHasChildren.removeChild(ChildHasParent)) &amp;&amp; <span class="local-variable">this</span>(p) &amp;&amp; args(c);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example aspect captures the protocol for managing a bi-directional
parent-child relationship between any two types playing the role of
parent and child. In a compiler implementation managing an abstract
syntax tree (AST) in which AST nodes may contain other AST nodes we
could declare the concrete aspect:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> aspect ASTNodeContainment <span class="directive">extends</span> ParentChildRelationship&lt;ASTNode,ASTNode&gt; {
    before(ASTNode parent, ASTNode child) : addingChild(parent, child) {
      <span class="comment">// ...</span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As a result of this declaration, <code>ASTNode</code> gains members:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>List&lt;ASTNode&gt; children</code></p>
</li>
<li>
<p><code>ASTNode parent</code></p>
</li>
<li>
<p><code>List&lt;ASTNode&gt;getChildren()</code></p>
</li>
<li>
<p><code>ASTNode getParent()</code></p>
</li>
<li>
<p><code>void addChild(ASTNode child)</code></p>
</li>
<li>
<p><code>void removeChild(ASTNode child)</code></p>
</li>
<li>
<p><code>void setParent(ASTNode parent)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In a system managing orders, we could declare the concrete aspect:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> aspect OrderItemsInOrders <span class="directive">extends</span> ParentChildRelationship&lt;Order, OrderItem&gt; {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As a result of this declaration, <code>Order</code> gains members:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>List&lt;OrderItem&gt; children</code></p>
</li>
<li>
<p><code>List&lt;OrderItem&gt; getChildren()</code></p>
</li>
<li>
<p><code>void addChild(OrderItem child)</code></p>
</li>
<li>
<p><code>void removeChild(OrderItem child)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>and <code>OrderItem</code> gains members:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Order parent</code></p>
</li>
<li>
<p><code>Order getParent()</code></p>
</li>
<li>
<p><code>void setParent(Order parent)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A second example of an abstract aspect, this time for handling
exceptions in a uniform manner, is shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">abstract</span> aspect ExceptionHandling&lt;T <span class="directive">extends</span> <span class="predefined-type">Throwable</span>&gt; {

  <span class="comment">/**
   * method to be implemented by sub-aspects to handle thrown exceptions
   */</span>
  <span class="directive">protected</span> <span class="directive">abstract</span> <span class="type">void</span> onException(T anException);

  <span class="comment">/**
   * to be defined by sub-aspects to specify the scope of exception handling
   */</span>
  <span class="directive">protected</span> <span class="directive">abstract</span> pointcut inExceptionHandlingScope();

  <span class="comment">/**
   * soften T within the scope of the aspect
   */</span>
  declare soft: T : inExceptionHandlingScope();

  <span class="comment">/**
   * bind an exception thrown in scope and pass it to the handler
   */</span>
  after() throwing (T anException) : inExceptionHandlingScope() {
    onException(anException);
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice how the type variable <code>T extends Throwable</code> allows the components
of the aspect to be designed to work together in a type-safe manner. The
following concrete sub-aspect shows how the abstract aspect might be
extended to handle <code>IOExceptions</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> aspect IOExceptionHandling <span class="directive">extends</span> ExceptionHandling&lt;<span class="exception">IOException</span>&gt;{

  <span class="directive">protected</span> pointcut inExceptionHandlingScope() :
    call(* doIO*(..)) &amp;&amp; within(org.xyz..*);

  <span class="comment">/**
   * called whenever an IOException is thrown in scope.
   */</span>
  <span class="directive">protected</span> <span class="type">void</span> onException(<span class="exception">IOException</span> ex) {
    <span class="predefined-type">System</span>.err.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">handled exception: </span><span class="delimiter">&quot;</span></span> + ex.getMessage());
    <span class="keyword">throw</span> <span class="keyword">new</span> MyDomainException(ex);
  }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2024-02-01 14:58:10 +0700
</div>
</div>
</body>
</html>