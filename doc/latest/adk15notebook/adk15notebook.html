<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.20">
<title>The AspectJTM 5 Development Kit Developer&#8217;s Notebook</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="./asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="./coderay-asciidoctor.css">
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>The AspectJ<sup>TM</sup> 5 Development Kit Developer&#8217;s Notebook</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#jpsigs">Join Point Signatures</a>
<ul class="sectlevel2">
<li><a href="#_join_point_matching">Join Point Matching</a></li>
<li><a href="#join-point-signatures">Join Point Signatures</a></li>
<li><a href="#_join_point_modifiers">Join Point Modifiers</a></li>
<li><a href="#join-point-matching-summary">Summary of Join Point Matching</a></li>
</ul>
</li>
<li><a href="#_annotations">Annotations</a>
<ul class="sectlevel2">
<li><a href="#annotations-inJava5">Annotations in Java 5</a></li>
<li><a href="#annotations-aspectmembers">Annotating Aspects</a></li>
<li><a href="#annotations-pointcuts-and-advice">Join Point Matching based on Annotations</a></li>
<li><a href="#annotations-decp">Using Annotations with declare statements</a></li>
<li><a href="#annotations-declare">Declare Annotation</a></li>
<li><a href="#annotations-itds">Inter-type Declarations</a></li>
</ul>
</li>
<li><a href="#_generics">Generics</a>
<ul class="sectlevel2">
<li><a href="#generics-inJava5">Generics in Java 5</a></li>
<li><a href="#generics-inAspectJ5">Generics in AspectJ 5</a></li>
</ul>
</li>
<li><a href="#autoboxing">Autoboxing and Unboxing</a>
<ul class="sectlevel2">
<li><a href="#boxing-inJava5">Autoboxing and Unboxing in Java 5</a></li>
<li><a href="#autoboxing-in-aspectj5">Autoboxing and Join Point matching in AspectJ 5</a></li>
<li><a href="#autoboxing-and-method-dispatch">Inter-type method declarations and method dispatch</a></li>
</ul>
</li>
<li><a href="#_covariance">Covariance</a>
<ul class="sectlevel2">
<li><a href="#covariance-inJava5">Covariance in Java 5</a></li>
<li><a href="#covariance-and-join-point-matching">Covariant methods and Join Point matching</a></li>
</ul>
</li>
<li><a href="#_varargs">Varargs</a>
<ul class="sectlevel2">
<li><a href="#varargs-inJava5">Variable-length Argument Lists in Java 5</a></li>
<li><a href="#varargs-in-pcds">Using Variable-length arguments in advice and pointcut expressions</a></li>
</ul>
</li>
<li><a href="#enumeratedtypes">Enumerated Types</a>
<ul class="sectlevel2">
<li><a href="#enums-in-java5">Enumerated Types in Java 5</a></li>
<li><a href="#enums-in-aspectj5">Enumerated Types in AspectJ 5</a></li>
</ul>
</li>
<li><a href="#pertypewithin">The <code>pertypewithin</code> Aspect Instantiation Model</a></li>
<li><a href="#ataspectj">An Annotation Based Development Style</a>
<ul class="sectlevel2">
<li><a href="#ataspectj-intro">Introduction</a></li>
<li><a href="#ataspectj-aspects">Aspect Declarations</a></li>
<li><a href="#ataspectj-pcadvice">Pointcuts and Advice</a></li>
<li><a href="#ataspectj-itds">Inter-type Declarations</a></li>
<li><a href="#ataspectj-declare">Declare statements</a></li>
<li><a href="#ataspectj-aspectof"><code>aspectOf()</code> and <code>hasAspect()</code> methods</a></li>
</ul>
</li>
<li><a href="#reflection">New Reflection Interfaces</a>
<ul class="sectlevel2">
<li><a href="#reflection_api">Using <code>AjTypeSystem</code></a></li>
</ul>
</li>
<li><a href="#miscellaneous">Other Changes in AspectJ 5</a>
<ul class="sectlevel2">
<li><a href="#pointcuts-change">Pointcuts</a></li>
<li><a href="#declare-soft-change">Declare Soft</a></li>
</ul>
</li>
<li><a href="#ltw">Load-Time Weaving</a>
<ul class="sectlevel2">
<li><a href="#ltw-introduction">Introduction</a></li>
</ul>
</li>
<li><a href="#grammar">A Grammar for the AspectJ 5 Language</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><em>by the AspectJ Team</em></p>
</div>
<div class="paragraph">
<p><em>Copyright (c) 2004, 2005 Contributors. All rights reserved.</em></p>
</div>
<div class="paragraph">
<p>This guide describes the changes to the AspectJ language in AspectJ 5. These include support for Java 5 features,
support for an annotation-based development style for aspects and new reflection and tools APIs. If you are new to
AspectJ, we recommend you start by reading the programming guide.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="jpsigs">Join Point Signatures</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Many of the extensions to the AspectJ language to address the new
features of Java 5 are derived from a simple set of principles for join
point matching. In this section, we outline these principles as a
foundation for understanding the matching rules in the presence of
annotations, generics, covariance, varargs, and autoboxing.</p>
</div>
<div class="sect2">
<h3 id="_join_point_matching">Join Point Matching</h3>
<div class="paragraph">
<p>AspectJ supports 11 different kinds of join points. These are the
<code>method call, method execution, constructor call, constructor execution, field get,
field set, pre-initialization, initialization, static initialization, handler,</code>
and <code>advice execution</code> join points.</p>
</div>
<div class="paragraph">
<p>The <em>kinded</em> pointcut designators match based on the kind of a join
point. These are the <code>call, execution, get, set, preinitialization, initialization,
staticinitialization, handler,</code> and <code>adviceexecution</code> designators.</p>
</div>
<div class="paragraph">
<p>A kinded pointcut is written using patterns, some of which match based
on <em>signature</em>, and some of which match based on <em>modifiers</em>. For
example, in the <code>call</code> pointcut designator:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">call(ModifierPattern TypePattern TypePattern.IdPattern(TypePatternList) ThrowsPattern)</code></pre>
</div>
</div>
<div class="paragraph">
<p>the modifiers matching patterns are <code>ModifierPattern</code> and
<code>ThrowsPattern</code>, and the signature matching patterns are
<code>TypePattern TypePattern.IdPattern(TypePatternList)</code>.</p>
</div>
<div class="paragraph">
<p>A join point has potentially multiple signatures, but only one set of
modifiers. <em>A kinded primitive pointcut matches a particular join point
if and only if</em>:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>They are of the same kind</p>
</li>
<li>
<p>The signature pattern (exactly) matches at least one signature of the
join point</p>
</li>
<li>
<p>The modifiers pattern matches the modifiers of the subject of the join
point</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>These rules make it very easily to quickly determine whether a given
pointcut matches a given join point. In the next two sections, we
describe what the signature(s) of a join point are, and what the
subjects of join points are.</p>
</div>
</div>
<div class="sect2">
<h3 id="join-point-signatures">Join Point Signatures</h3>
<div class="paragraph">
<p>Call, execution, get, and set join points may potentially have multiple
signatures. All other join points have exactly one signature. The
following table summarizes the constituent parts of a join point
signature for the different kinds of join point.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2858%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Join Point Kind</th>
<th class="tableblock halign-left valign-top">Return Type</th>
<th class="tableblock halign-left valign-top">Declaring Type</th>
<th class="tableblock halign-left valign-top">Id</th>
<th class="tableblock halign-left valign-top">Parameter Types</th>
<th class="tableblock halign-left valign-top">Field Type</th>
<th class="tableblock halign-left valign-top">Exception Type</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Method call</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">+</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">+</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">+</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">+</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Method execution</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">+</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">+</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">+</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">+</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Constructor call</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">+</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">+</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Constructor execution</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">+</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">+</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Field get</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">+</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">+</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">+</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Field set</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">+</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">+</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">+</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pre-initialization</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">+</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">+</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Initialization</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">+</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">+</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Static initialization</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">+</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Handler</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">+</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Advice execution</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">+</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">+</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Note that whilst an advice execution join point has a signature
comprising the declaring type of the advice and the advice parameter
types, the <code>adviceexecution</code> pointcut designator does not support
matching based on this signature.</p>
</div>
<div class="paragraph">
<p>The signatures for most of the join point kinds should be
self-explanatory, except for field get and set, and method call and
execution join points, which can have multiple signatures. Each
signature of a method call or execution join point has the same id and
parameter types, but the declaring type and return type (with
covariance) may vary. Each signature of a field get or set join point
has the same id and field type, but the declaring type may vary.</p>
</div>
<div class="paragraph">
<p>The following sections examine signatures for these join points in more
detail.</p>
</div>
<div class="sect3">
<h4 id="_method_call_join_point_signatures">Method call join point signatures</h4>
<div class="paragraph">
<p>For a call join point where a call is made to a method
<code>m(parameter_types)</code> on a target type <code>T</code> (where <code>T</code> is the static type
of the target):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">T t = <span class="keyword">new</span> T();
t.m(<span class="string"><span class="delimiter">&quot;</span><span class="content">hello</span><span class="delimiter">&quot;</span></span>);  <span class="comment">// &lt;= call join point occurs when this line is executed</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Then the signature <code>R(T) T.m(parameter_types)</code> is a signature of the
call join point, where <code>R(T)</code> is the return type of <code>m</code> in <code>T</code>, and
<code>parameter_types</code> are the parameter types of <code>m</code>. If <code>T</code> itself does not
declare a definition of <code>m(parameter_types)</code>, then <code>R(T)</code> is the return
type in the definition of <code>m</code> that <code>T</code> inherits. Given the call above,
and the definition of <code>T.m</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">interface</span> <span class="class">Q</span> {
  R m(<span class="predefined-type">String</span> s);
}

<span class="type">class</span> <span class="class">P</span> <span class="directive">implements</span> Q {
  R m(<span class="predefined-type">String</span> s) {...}
}

<span class="type">class</span> <span class="class">S</span> <span class="directive">extends</span> P {
  R<span class="string"><span class="delimiter">'</span><span class="content"> m(String s) {...}
}

class T extends S {}</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Then <code>R' T.m(String)</code> is a signature of the call join point for
<code>t.m("hello")</code>.</p>
</div>
<div class="paragraph">
<p>For each ancestor (super-type) <code>A</code> of <code>T</code>, if <code>m(parameter_types)</code> is
defined for that super-type, then <code>R(A) A.m(parameter_types)</code> is a
signature of the call join point, where <code>R(A)</code> is the return type of `
            m(parameter_types)` as defined in <code>A</code>, or as inherited by
<code>A</code> if <code>A</code> itself does not provide a definition of <code>m(parameter_types)</code>.</p>
</div>
<div class="paragraph">
<p>Continuing the example from above,we can deduce that</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">R<span class="string"><span class="delimiter">'</span><span class="content"> S.m(String)
R  P.m(String)
R  Q.m(String)</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>are all additional signatures for the call join point arising from the
call <code>t.m("hello")</code>. Thus this call join point has four signatures in
total. Every signature has the same id and parameter types, and a
different declaring type.</p>
</div>
</div>
<div class="sect3">
<h4 id="_method_execution_join_point_signatures">Method execution join point signatures</h4>
<div class="paragraph">
<p>Join point signatures for execution join points are defined in a similar
manner to signatures for call join points. Given the hierarchy:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">interface</span> <span class="class">Q</span> {
  R m(<span class="predefined-type">String</span> s);
}

<span class="type">class</span> <span class="class">P</span> <span class="directive">implements</span> Q {
  R m(<span class="predefined-type">String</span> s) {...}
}

<span class="type">class</span> <span class="class">S</span> <span class="directive">extends</span> P {
  R<span class="string"><span class="delimiter">'</span><span class="content"> m(String s) {...}
}

class T extends S { }

class U extends T {
  R</span><span class="delimiter">'</span></span> m(<span class="predefined-type">String</span> s) {...}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then the execution join point signatures arising as a result of the call
to <code>u.m("hello")</code> are:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">R<span class="string"><span class="delimiter">'</span><span class="content"> U.m(String)
R</span><span class="delimiter">'</span></span> S.m(<span class="predefined-type">String</span>)
R  P.m(<span class="predefined-type">String</span>)
R  Q.m(<span class="predefined-type">String</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each signature has the same id and parameter types, and a different
declaring type. There is one signature for each type that provides its
own declaration of the method. Hence in this example there is no
signature <code>R' T.m(String)</code> as <code>T</code> does not provide its own declaration
of the method.</p>
</div>
</div>
<div class="sect3">
<h4 id="_field_get_and_set_join_point_signatures">Field get and set join point signatures</h4>
<div class="paragraph">
<p>For a field get join point where an access is made to a field <code>f</code> of
type <code>F</code> on a object with declared type <code>T</code>, then <code>F T.f</code> is a signature
of the get join point.</p>
</div>
<div class="paragraph">
<p>If <code>T</code> does not directly declare a member <code>f</code>, then for each super type
<code>S</code> of <code>T</code>, up to and including the most specific super type of <code>T</code> that
does declare the member <code>f</code>, <code>F S.f</code> is a signature of the join point.
For example, given the hierarchy:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">P</span>  {
  F f;
}

<span class="type">class</span> <span class="class">S</span> <span class="directive">extends</span> P {
  F f;
}

<span class="type">class</span> <span class="class">T</span> <span class="directive">extends</span> S { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then the join point signatures for a field get join point of the field
<code>f</code> on an object with declared type <code>T</code> are:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">F S.f
F T.f</code></pre>
</div>
</div>
<div class="paragraph">
<p>The signatures for a field set join point are derived in an identical
manner.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_join_point_modifiers">Join Point Modifiers</h3>
<div class="paragraph">
<p>Every join point has a single set of modifiers - these include the
standard Java modifiers such as <code>public</code>, <code>private</code>, <code>static</code>, <code>abstract</code> etc.,
any annotations, and the <code>throws</code> clauses of methods and constructors.
These modifiers are the modifiers of the <em>subject</em> of the join point.</p>
</div>
<div class="paragraph">
<p>The following table defines the join point subject for each kind of join
point.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Join Point Kind</th>
<th class="tableblock halign-left valign-top">Subject</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Method call</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The method picked out by Java as the static target of the
method call.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Method execution</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The method that is executing.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Constructor call</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The constructor being called.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Constructor execution</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The constructor executing.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Field get</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The field being accessed.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Field set</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The field being set.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pre-initialization</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The first constructor executing in this constructor
chain.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Initialization</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The first constructor executing in this constructor
chain.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Static initialization</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The type being initialized.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Handler</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The declared type of the exception being handled.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Advice execution</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The advice being executed.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>For example, given the following types</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">X</span> {
  <span class="annotation">@Foo</span>
  <span class="directive">protected</span> <span class="type">void</span> doIt() {...}
}

<span class="directive">public</span> <span class="type">class</span> <span class="class">Y</span> <span class="directive">extends</span> X {
  <span class="directive">public</span> <span class="type">void</span> doIt() {...}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then the modifiers for a call to <code>(Y y) y.doIt()</code> are simply <code>{ public }</code>.
The modifiers for a call to <code>(X x) x.doIt()</code> are <code>{ @Foo, protected }</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="join-point-matching-summary">Summary of Join Point Matching</h3>
<div class="paragraph">
<p>A join point has potentially multiple signatures, but only one set of
modifiers. <em>A kinded primitive pointcut matches a particular join point
if and only if</em>:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>They are of the same kind</p>
</li>
<li>
<p>The signature pattern (exactly) matches at least one signature of the
join point</p>
</li>
<li>
<p>The modifiers pattern matches the modifiers of the subject of the join
point</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Given the hierarchy</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">interface</span> <span class="class">Q</span> {
  R m(<span class="predefined-type">String</span> s);
}

<span class="type">class</span> <span class="class">P</span> <span class="directive">implements</span> Q {
  <span class="annotation">@Foo</span>
  <span class="directive">public</span> R m(<span class="predefined-type">String</span> s) {...}
}

<span class="type">class</span> <span class="class">S</span> <span class="directive">extends</span> P {
  <span class="annotation">@Bar</span>
  <span class="directive">public</span> R<span class="string"><span class="delimiter">'</span><span class="content"> m(String s) {...}
}

class T extends S {}</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>and the program fragment:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">P p = <span class="keyword">new</span> P();
S s = <span class="keyword">new</span> S();
T t = <span class="keyword">new</span> T();
...
p.m(<span class="string"><span class="delimiter">&quot;</span><span class="content">hello</span><span class="delimiter">&quot;</span></span>);
s.m(<span class="string"><span class="delimiter">&quot;</span><span class="content">hello</span><span class="delimiter">&quot;</span></span>);
t.m(<span class="string"><span class="delimiter">&quot;</span><span class="content">hello</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The the pointcut <code>call(@Foo R P.m(String))</code> matches the call
<code>p.m("hello")</code> since both the signature and the modifiers match. It does
not match the call <code>s.m("hello")</code> because even though the signature
pattern matches one of the signatures of the join point, the modifiers
pattern does not match the modifiers of the method m in S which is the
static target of the call.</p>
</div>
<div class="paragraph">
<p>The pointcut <code>call(R' m(String))</code> matches the calls <code>t.m("hello")</code> and
<code>s.m("hello")</code>. It does not match the call <code>p.m("hello")</code> since the
signature pattern does not match any signature for the call join point
of m in P.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_annotations">Annotations</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="annotations-inJava5">Annotations in Java 5</h3>
<div class="paragraph">
<p>This section provides the essential information about annotations in
Java 5 needed to understand how annotations are treated in AspectJ 5.
For a full introduction to annotations in Java, please see the
documentation for the Java 5 SDK.</p>
</div>
<div class="sect3">
<h4 id="_using_annotations">Using Annotations</h4>
<div class="paragraph">
<p>Java 5 introduces <em>annotation types</em> which can be used to express
metadata relating to program members in the form of <em>annotations</em>.
Annotations in Java 5 can be applied to package and type declarations
(classes, interfaces, enums, and annotations), constructors, methods,
fields, parameters, and variables. Annotations are specified in the
program source by using the <code>@</code> symbol. For example, the following piece
of code uses the <code>@Deprecated</code> annotation to indicate that the
<code>obsoleteMethod()</code> has been deprecated:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Deprecated</span>
<span class="directive">public</span> <span class="type">void</span> obsoleteMethod() { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Annotations may be <em>marker annotations</em>, <em>single-valued annotations</em>, or
<em>multi-valued annotations</em>. Annotation types with no members or that
provide default values for all members may be used simply as marker
annotations, as in the deprecation example above. Single-value
annotation types have a single member, and the annotation may be written
in one of two equivalent forms:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@SuppressWarnings</span>({<span class="string"><span class="delimiter">&quot;</span><span class="content">unchecked</span><span class="delimiter">&quot;</span></span>})
<span class="directive">public</span> <span class="type">void</span> someMethod() {...}</code></pre>
</div>
</div>
<div class="paragraph">
<p>or</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@SuppressWarnings</span>(value={<span class="string"><span class="delimiter">&quot;</span><span class="content">unchecked</span><span class="delimiter">&quot;</span></span>})
<span class="directive">public</span> <span class="type">void</span> someMethod() {...}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Multi-value annotations must use the `member-name=value
            ` syntax to specify annotation values. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Authenticated</span>(role=<span class="string"><span class="delimiter">&quot;</span><span class="content">supervisor</span><span class="delimiter">&quot;</span></span>,clearanceLevel=<span class="integer">5</span>)
<span class="directive">public</span> <span class="type">void</span> someMethod() {...}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_retention_policies">Retention Policies</h4>
<div class="paragraph">
<p>Annotations can have one of three retention policies:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Source-file retention</dt>
<dd>
<p>Annotations with source-file retention are read by the compiler during
the compilation process, but are not rendered in the generated <code>.class</code> files.</p>
</dd>
<dt class="hdlist1">Class-file retention</dt>
<dd>
<p>This is the default retention policy. Annotations with class-file
retention are read by the compiler and also retained in the generated <code>.class</code> files.</p>
</dd>
<dt class="hdlist1">Runtime retention</dt>
<dd>
<p>Annotations with runtime retention are read by the compiler, retained
in the generated <code>.class</code> files, and also made available at
runtime.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Local variable annotations are not retained in class files (or at
runtime) regardless of the retention policy set on the annotation type.
See JLS 9.6.1.2.</p>
</div>
</div>
<div class="sect3">
<h4 id="_accessing_annotations_at_runtime">Accessing Annotations at Runtime</h4>
<div class="paragraph">
<p>Java 5 supports a new interface, <code>java.lang.reflect.AnnotatedElement</code>,
that is implemented by the reflection classes in Java (<code>Class</code>,
<code>Constructor</code>, <code>Field</code>, <code>Method</code>, and <code>Package</code>). This interface gives
you access to annotations <em>that have runtime retention</em> via the
<code>getAnnotation</code>, <code>getAnnotations</code>, and <code>isAnnotationPresent</code>. Because
annotation types are just regular Java classes, the annotations returned
by these methods can be queried just like any regular Java object.</p>
</div>
</div>
<div class="sect3">
<h4 id="_annotation_inheritance">Annotation Inheritance</h4>
<div class="paragraph">
<p>It is important to understand the rules relating to inheritance of
annotations, as these have a bearing on join point matching based on the
presence or absence of annotations.</p>
</div>
<div class="paragraph">
<p>By default annotations are <em>not</em> inherited. Given the following program</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@MyAnnotation</span>
<span class="type">class</span> <span class="class">Super</span> {
  <span class="annotation">@Oneway</span> <span class="directive">public</span> <span class="type">void</span> foo() {}
}

<span class="type">class</span> <span class="class">Sub</span> <span class="directive">extends</span> Super {
  <span class="directive">public</span> <span class="type">void</span> foo() {}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then <code>Sub</code> <em>does not</em> have the <code>MyAnnotation</code> annotation, and
<code>Sub.foo()</code> is not an <code>@Oneway</code> method, despite the fact that it
overrides <code>Super.foo()</code> which is.</p>
</div>
<div class="paragraph">
<p>If an annotation type has the meta-annotation <code>@Inherited</code> then an
annotation of that type on a <em>class</em> will cause the annotation to be
inherited by sub-classes. So, in the example above, if the
<code>MyAnnotation</code> type had the <code>@Inherited</code> attribute, then <code>Sub</code> would
have the <code>MyAnnotation</code> annotation.</p>
</div>
<div class="paragraph">
<p><code>@Inherited</code> annotations are not inherited when used to annotate
anything other than a type. A type that implements one or more
interfaces never inherits any annotations from the interfaces it
implements.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="annotations-aspectmembers">Annotating Aspects</h3>
<div class="paragraph">
<p>AspectJ 5 supports annotations on aspects, and on method, field,
constructor, advice, and inter-type declarations within aspects. Method
and advice parameters may also be annotated. Annotations are not
permitted on pointcut declarations or on <code>declare</code> statements.</p>
</div>
<div class="paragraph">
<p>The following example illustrates the use of annotations in aspects:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@AspectAnnotation</span>
<span class="directive">public</span> <span class="directive">abstract</span> aspect ObserverProtocol {

    <span class="annotation">@InterfaceAnnotation</span>
    <span class="type">interface</span> <span class="class">Observer</span> {}

    <span class="annotation">@InterfaceAnnotation</span>
    <span class="type">interface</span> <span class="class">Subject</span> {}

    <span class="annotation">@ITDFieldAnnotation</span>
    <span class="directive">private</span> <span class="predefined-type">List</span>&lt;<span class="predefined-type">Observer</span>&gt; <span class="predefined-type">Subject</span>.observers;

    <span class="annotation">@ITDMethodAnnotation</span>
    <span class="directive">public</span> <span class="type">void</span> <span class="predefined-type">Subject</span>.addObserver(<span class="predefined-type">Observer</span> o) {
      observers.add(o);
    }

    <span class="annotation">@ITDMethodAnnotation</span>
    <span class="directive">public</span> <span class="type">void</span> <span class="predefined-type">Subject</span>.removeObserver(<span class="predefined-type">Observer</span> o) {
      observers.remove(o);
    }

    <span class="annotation">@MethodAnnotation</span>
    <span class="directive">private</span> <span class="type">void</span> notifyObservers(<span class="predefined-type">Subject</span> subject) {
      <span class="keyword">for</span>(<span class="predefined-type">Observer</span> o : subject.observers)
        notifyObserver(o,subject);
    }

    <span class="comment">/**
     * Delegate to concrete sub-aspect the actual form of
     * notification for a given type of Observer.
     */</span>
    <span class="annotation">@MethodAnnotation</span>
    <span class="directive">protected</span> <span class="directive">abstract</span> <span class="type">void</span> notifyObserver(<span class="predefined-type">Observer</span> o, <span class="predefined-type">Subject</span> s);

    <span class="comment">/* no annotations on pointcuts */</span>
    <span class="directive">protected</span> <span class="directive">abstract</span> pointcut observedEvent(<span class="predefined-type">Subject</span> subject);

    <span class="annotation">@AdviceAnnotation</span>
    after(<span class="predefined-type">Subject</span> subject) returning : observedEvent(subject) {
        notifyObservers(subject);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>An annotation on an aspect will be inherited by sub-aspects, iff it has
the <code>@Inherited</code> meta-annotation.</p>
</div>
<div class="paragraph">
<p>AspectJ 5 supports a new XLint warning, "the pointcut associated with
this advice does not match any join points". The warning is enabled by
default and will be emitted by the compiler if the pointcut expression
associated with an advice statement can be statically determined to not
match any join points. The warning can be suppressed for an individual
advice statement by using the
<code>@SuppressAjWarnings({"adviceDidNotMatch"})</code> annotation. This works in
the same way as the Java 5 SuppressWarnings annotation (See JLS
9.6.1.5), but has class file retention.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation.SuppressAjWarnings</span>;

<span class="directive">public</span> aspect AnAspect {

  pointcut anInterfaceOperation() : execution(* AnInterface.*(..));

  <span class="annotation">@SuppressAjWarnings</span> <span class="comment">// may not match if there are no implementers of the interface...</span>
  before() : anInterfaceOperation() {
     <span class="comment">// do something...</span>
  }

  <span class="annotation">@SuppressAjWarnings</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">adviceDidNotMatch</span><span class="delimiter">&quot;</span></span>) <span class="comment">// alternate form</span>
  after() returning : anInterfaceOperation() {
     <span class="comment">// do something...</span>
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="annotations-pointcuts-and-advice">Join Point Matching based on Annotations</h3>
<div class="paragraph">
<p>This section discusses changes to type pattern and signature pattern
matching in AspectJ 5 that support matching join points based on the
presence or absence of annotations. We then discuss means of exposing
annotation values within the body of advice.</p>
</div>
<div class="sect3">
<h4 id="_annotation_patterns">Annotation Patterns</h4>
<div class="paragraph">
<p>For any kind of annotated element (type, method, constructor, package,
etc.), an annotation pattern can be used to match against the set of
annotations on the annotated element.An annotation pattern element has
one of two basic forms:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@&lt;qualified-name&gt;</code>, for example, <code>@Foo</code>, or <code>@org.xyz.Foo</code>.</p>
</li>
<li>
<p><code>@(&lt;type-pattern&gt;)</code>, for example, <code>@(org.xyz..*)</code>, or <code>@(Foo || Boo)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These simple elements may be negated using <code>!</code>, and combined by simple
concatentation. The pattern <code>@Foo @Boo</code> matches an annotated element
that has both an annotation of type <code>Foo</code> and an annotation of type
<code>Boo</code>.</p>
</div>
<div class="paragraph">
<p>Some examples of annotation patterns follow:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>@Immutable</code></dt>
<dd>
<p>Matches any annotated element which has an annotation of type
<code>Immutable</code>.</p>
</dd>
<dt class="hdlist1"><code>!@Persistent</code></dt>
<dd>
<p>Matches any annotated element which does not have an annotation of
type <code>Persistent</code>.</p>
</dd>
<dt class="hdlist1"><code>@Foo @Goo</code></dt>
<dd>
<p>Matches any annotated element which has both an annotation of type
<code>Foo</code> and an annotation of type <code>Goo</code>.</p>
</dd>
<dt class="hdlist1"><code>@(Foo || Goo)</code></dt>
<dd>
<p>Matches any annotated element which has either an annotation of a type
matching the type pattern <code>(Foo || Goo)</code>. In other words, an annotated
element with either an annotation of type <code>Foo</code> or an annotation of
type <code>Goo</code> (or both). (The parenthesis are required in this example).</p>
</dd>
<dt class="hdlist1"><code>@(org.xyz..*)</code></dt>
<dd>
<p>Matches any annotated element which has either an annotation of a type
matching the type pattern <code>(org.xyz..*)</code>. In other words, an annotated
element with an annotation that is declared in the org.xyz package or
a sub-package. (The parenthesis are required in this example).</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_type_patterns">Type Patterns</h4>
<div class="paragraph">
<p>AspectJ 1.5 extends type patterns to allow an optional
<code>AnnotationPattern</code> prefix.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">TypePattern := SimpleTypePattern |
               '!' TypePattern |
               '(' AnnotationPattern? TypePattern ')'
               TypePattern '&amp;&amp;' TypePattern |
               TypePattern '||' TypePattern

SimpleTypePattern := DottedNamePattern '+'? '[]'*

DottedNamePattern := FullyQualifiedName RestOfNamePattern? |
                     '*' NotStarNamePattern?

RestOfNamePattern := '..' DottedNamePattern |
                     '*' NotStarNamePattern?

NotStarNamePattern := FullyQualifiedName RestOfNamePattern? |
                      '..' DottedNamePattern

FullyQualifiedName := JavaIdentifierCharacter+ ('.' JavaIdentifierCharacter+)*</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that in most cases when annotations are used as part of a type
pattern, the parenthesis are required (as in <code>(@Foo Hello+)</code>). In some
cases (such as a type pattern used within a <code>within</code> or <code>handler</code>
pointcut expression), the parenthesis are optional:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">OptionalParensTypePattern := AnnotationPattern? TypePattern</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following examples illustrate the use of annotations in type
patterns:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>(@Immutable *)</code></dt>
<dd>
<p>Matches any type with an <code>@Immutable</code> annotation.</p>
</dd>
<dt class="hdlist1"><code>(!@Immutable *)</code></dt>
<dd>
<p>Matches any type which does not have an <code>@Immutable</code> annotation.</p>
</dd>
<dt class="hdlist1"><code>(@Immutable (org.xyz.* || org.abc.*))</code></dt>
<dd>
<p>Matches any type in the <code>org.xyz</code> or <code>org.abc</code> packages with the
<code>@Immutable</code> annotation.</p>
</dd>
<dt class="hdlist1"><code>((@Immutable Foo+) || Goo)</code></dt>
<dd>
<p>Matches a type <code>Foo</code> or any of its subtypes, which have the
<code>@Immutable</code> annotation, or a type <code>Goo</code>.</p>
</dd>
<dt class="hdlist1"><code>((@(Immutable || NonPersistent) org.xyz..*)</code></dt>
<dd>
<p>Matches any type in a package beginning with the prefix <code>org.xyz</code>,
which has either the <code>@Immutable</code> annotation or the <code>@NonPersistent</code>
annotation.</p>
</dd>
<dt class="hdlist1"><code>(@Immutable @NonPersistent org.xyz..*)</code></dt>
<dd>
<p>Matches any type in a package beginning with the prefix <code>org.xyz</code>,
which has both an <code>@Immutable</code> annotation and an <code>@NonPersistent</code>
annotation.</p>
</dd>
<dt class="hdlist1"><code>(@(@Inherited <strong>) org.xyz..</strong>)</code></dt>
<dd>
<p>Matches any type in a package beginning with the prefix <code>org.xyz</code>,
which has an inheritable annotation. The annotation pattern
<code>@(@Inherited *)</code> matches any annotation of a type matching the type
pattern <code>@Inherited *</code>, which in turn matches any type with the
<code>@Inherited</code> annotation.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="signaturePatterns">Signature Patterns</h4>
<div class="sect4">
<h5 id="fieldPatterns">Field Patterns</h5>
<div class="paragraph">
<p>A <code>FieldPattern</code> can optionally specify an annotation-matching pattern
as the first element:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">FieldPattern :=
    AnnotationPattern? FieldModifiersPattern?
    TypePattern (TypePattern DotOrDotDot)? SimpleNamePattern

FieldModifiersPattern := '!'? FieldModifier FieldModifiersPattern*

FieldModifier := 'public' | 'private' | 'protected' | 'static' |
                 'transient' | 'final'

DotOrDotDot := '.' | '..'

SimpleNamePattern := JavaIdentifierChar+ ('*' SimpleNamePattern)?</code></pre>
</div>
</div>
<div class="paragraph">
<p>If present, the <code>AnnotationPattern</code> restricts matches to fields with
annotations that match the pattern. For example:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>@SensitiveData * *</code></dt>
<dd>
<p>Matches a field of any type and any name, that has an annotation of
type <code>@SensitiveData</code></p>
</dd>
<dt class="hdlist1"><code>@SensitiveData List org.xyz..<strong>.</strong></code></dt>
<dd>
<p>Matches a member field of a type in a package with prefix <code>org.xzy</code>,
where the field is of type <code>List</code>, and has an annotation of type
<code>@SensitiveData</code></p>
</dd>
<dt class="hdlist1"><code>(@SensitiveData <strong>) org.xyz..</strong>.*</code></dt>
<dd>
<p>Matches a member field of a type in a package with prefix <code>org.xzy</code>,
where the field is of a type which has a <code>@SensitiveData</code> annotation.</p>
</dd>
<dt class="hdlist1"><code>@Foo (@Goo <strong>) (@Hoo *).</strong></code></dt>
<dd>
<p>Matches a field with an annotation <code>@Foo</code>, of a type with an
annotation <code>@Goo</code>, declared in a type with annotation <code>@Hoo</code>.</p>
</dd>
<dt class="hdlist1"><code>@Persisted @Classified * *</code></dt>
<dd>
<p>Matches a field with an annotation <code>@Persisted</code> and an annotation
<code>@Classified</code>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="methodPatterns">Method and Constructor Patterns</h5>
<div class="paragraph">
<p>A <code>MethodPattern</code> can optionally specify an annotation-matching pattern
as the first element.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">MethodPattern :=
    AnnotationPattern? MethodModifiersPattern? TypePattern
                       (TypePattern DotOrDotDot)? SimpleNamePattern
                       '(' FormalsPattern ')'ThrowsPattern?

MethodModifiersPattern := '!'? MethodModifier MethodModifiersPattern*

MethodModifier := 'public' | 'private' | 'protected' | 'static' |
                  'synchronized' | 'final'

FormalsPattern := '..' (',' FormalsPatternAfterDotDot)* |
                  OptionalParensTypePattern (',' FormalsPattern)* |
                  TypePattern '...'

FormalsPatternAfterDotDot :=
        OptionalParensTypePattern (',' FormalsPatternAfterDotDot)* |
        TypePattern '...'

ThrowsPattern := 'throws' TypePatternList

TypePatternList := TypePattern (',' TypePattern)*</code></pre>
</div>
</div>
<div class="paragraph">
<p>A <code>ConstructorPattern</code> has the form</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">ConstructorPattern :=
    AnnotationPattern? ConstructorModifiersPattern?
                       (TypePattern DotOrDotDot)? 'new' '(' FormalsPattern ')'
                       ThrowsPattern?

ConstructorModifiersPattern := '!'? ConstructorModifier ConstructorModifiersPattern*

ConstructorModifier := 'public' | 'private' | 'protected'</code></pre>
</div>
</div>
<div class="paragraph">
<p>The optional <code>AnnotationPattern</code> at the beginning of a method or
constructor pattern restricts matches to methods/constructors with
annotations that match the pattern. For example:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>@Oneway * *(..)</code></dt>
<dd>
<p>Matches a method with any return type and any name, that has an
annotation of type <code>@Oneway</code>.</p>
</dd>
<dt class="hdlist1"><code>@Transaction * (@Persistent org.xyz..<strong>).</strong>(..)</code></dt>
<dd>
<p>Matches a method with the <code>@Transaction</code> annotation, declared in a
type with the <code>@Persistent</code> annotation, and in a package beginning
with the <code>org.xyz</code> prefix.</p>
</dd>
<dt class="hdlist1"><code>* <strong>.</strong>(@Immutable *,..)</code></dt>
<dd>
<p>Matches any method taking at least one parameter, where the parameter
type has an annotation <code>@Immutable</code>.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_example_pointcuts">Example Pointcuts</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>within(@Secure *)</code></dt>
<dd>
<p>Matches any join point where the code executing is declared in a type
with an <code>@Secure</code> annotation. The format of the <code>within</code> pointcut
designator in AspectJ 5 is
<code>'within' '(' OptionalParensTypePattern ')'</code>.</p>
</dd>
<dt class="hdlist1"><code>staticinitialization(@Persistent *)</code></dt>
<dd>
<p>Matches the staticinitialization join point of any type with the
<code>@Persistent</code> annotation. The format of the <code>staticinitialization</code>
pointcut designator in AspectJ 5 is
<code>'staticinitialization' '(' OptionalParensTypePattern ')'</code>.</p>
</dd>
<dt class="hdlist1"><code>call(@Oneway * *(..))</code></dt>
<dd>
<p>Matches a call to a method with a <code>@Oneway</code> annotation.</p>
</dd>
<dt class="hdlist1"><code>execution(public (@Immutable <strong>) org.xyz..</strong>.*(..))</code></dt>
<dd>
<p>The execution of any public method in a package with prefix <code>org.xyz</code>,
where the method returns an immutable result.</p>
</dd>
<dt class="hdlist1"><code>set(@Cachable * *)</code></dt>
<dd>
<p>Matches the set of any cachable field.</p>
</dd>
<dt class="hdlist1"><code>handler(!@Catastrophic *)</code></dt>
<dd>
<p>Matches the handler join point for the handling of any exception that
is not <code>Catastrophic</code>. The format of the <code>handler</code> pointcut designator
in AspectJ 5 is <code>'handler' '(' OptionalParensTypePattern ')'</code>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_runtime_type_matching_and_context_exposure">Runtime type matching and context exposure</h4>
<div class="paragraph">
<p>AspectJ 5 supports a set of "@" pointcut designators which can be used
both to match based on the presence of an annotation at runtime, and to
expose the annotation value as context in a pointcut or advice
definition. These designators are <code>@args, @this, @target,
    @within, @withincode</code>, and <code>@annotation</code></p>
</div>
<div class="paragraph">
<p>It is a compilation error to attempt to match on an annotation type that
does not have runtime retention using <code>@this, @target</code> or <code>@args</code>. It is
a compilation error to attempt to use any of these designators to expose
an annotation value that does not have runtime retention.</p>
</div>
<div class="paragraph">
<p>The <code>this()</code>, <code>target()</code>, and <code>args()</code> pointcut designators allow
matching based on the runtime type of an object, as opposed to the
statically declared type. In AspectJ 5, these designators are
supplemented with three new designators : <code>@this()</code> (read, "this
annotation"), <code>@target()</code>, and <code>@args()</code>.</p>
</div>
<div class="paragraph">
<p>Like their counterparts, these pointcut designators can be used both for
join point matching, and to expose context. The format of these new
designators is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">AtThis := '@this' '(' AnnotationOrIdentifer ')'

AtTarget := '@target' '(' AnnotationOrIdentifier ')'

AnnotationOrIdentifier := FullyQualifiedName | Identifier

AtArgs := '@args' '(' AnnotationsOrIdentifiersPattern ')'

AnnotationsOrIdentifiersPattern :=
                  '..' (',' AnnotationsOrIdentifiersPatternAfterDotDot)? |
                  AnnotationOrIdentifier (',' AnnotationsOrIdentifiersPattern)* |
                  '*' (',' AnnotationsOrIdentifiersPattern)*

AnnotationsOrIdentifiersPatternAfterDotDot :=
              AnnotationOrIdentifier (',' AnnotationsOrIdentifiersPatternAfterDotDot)* |
              '*' (',' AnnotationsOrIdentifiersPatternAfterDotDot)*</code></pre>
</div>
</div>
<div class="paragraph">
<p>The forms of <code>@this()</code> and <code>@target()</code> that take a single annotation
name are analogous to their counterparts that take a single type name.
They match at join points where the object bound to <code>this</code> (or <code>target</code>,
respectively) has an annotation of the specified type. For example:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>@this(Foo)</code></dt>
<dd>
<p>Matches any join point where the object currently bound to 'this' has
an annotation of type <code>Foo</code>.</p>
</dd>
<dt class="hdlist1"><code>call(* *(..)) &amp;&amp; @target(Classified)</code></dt>
<dd>
<p>Matches a call to any object where the target of the call has a
<code>@Classified</code> annotation.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Annotations can be exposed as context in the body of advice by using the
forms of <code>@this(), @target()</code> and <code>@args()</code> that use bound variables in
the place of annotation names. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">pointcut callToClassifiedObject(Classified classificationInfo) :
    call(* *(..)) &amp;&amp; <span class="annotation">@target</span>(classificationInfo);

pointcut txRequiredMethod(Tx transactionAnnotation) :
    execution(* *(..)) &amp;&amp; <span class="annotation">@this</span>(transactionAnnotation)
    &amp;&amp; <span class="keyword">if</span>(transactionAnnotation.policy() == TxPolicy.REQUIRED);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>@args</code> pointcut designator behaves as its <code>args</code> counterpart,
matching join points based on number and position of arguments, and
supporting the <code>*</code> wildcard and at most one <code>..</code> wildcard. An annotation
at a given position in an <code>@args</code> expression indicates that the runtime
type of the argument in that position at a join point must have an
annotation of the indicated type. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">/**
 * matches any join point with at least one argument, and where the
 * type of the first argument has the @Classified annotation
 */</span>
pointcut classifiedArgument() : <span class="annotation">@args</span>(Classified,..);

<span class="comment">/**
 * matches any join point with three arguments, where the third
 * argument has an annotation of type @Untrusted.
 */</span>
pointcut untrustedData(Untrusted untrustedDataSource) :
    <span class="annotation">@args</span>(*,*,untrustedDataSource);</code></pre>
</div>
</div>
<div class="paragraph">
<p>In addition to accessing annotation information at runtime through
context binding, access to <code>AnnotatedElement</code> information is also
available reflectively with the body of advice through the
<code>thisJoinPoint</code>, <code>thisJoinPointStaticPart</code>, and
<code>thisEnclosingJoinPointStaticPart</code> variables. To access annotations on
the arguments, or object bound to this or target at a join point you can
use the following code fragments:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">Annotation</span><span class="type">[]</span> thisAnnotations = thisJoinPoint.getThis().getClass().getAnnotations();
<span class="predefined-type">Annotation</span><span class="type">[]</span> targetAnnotations = thisJoinPoint.getTarget().getClass().getAnnotations();
<span class="predefined-type">Annotation</span><span class="type">[]</span> firstParamAnnotations = thisJoinPoint.getArgs()[<span class="integer">0</span>].getClass().getAnnotations();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>@within</code> and <code>@withincode</code> pointcut designators match any join
point where the executing code is defined within a type (<code>@within</code>), or
a method/constructor (<code>@withincode</code>) that has an annotation of the
specified type. The form of these designators is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">AtWithin := '@within' '(' AnnotationOrIdentifier ')'
AtWithinCode := '@withincode' '(' AnnotationOrIdentifier ')'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Some examples of using these designators follow:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>@within(Foo)</code></dt>
<dd>
<p>Matches any join point where the executing code is defined within a
type which has an annotation of type <code>Foo</code>.</p>
</dd>
<dt class="hdlist1"><code>pointcut insideCriticalMethod(Critical c) : @withincode(c);</code></dt>
<dd>
<p>Matches any join point where the executing code is defined in a method
or constructor which has an annotation of type <code>@Critical</code>, and
exposes the value of the annotation in the parameter <code>c</code>.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The <code>@annotation</code> pointcut designator matches any join point where the
<em>subject</em> of the join point has an annotation of the given type. Like
the other @pcds, it can also be used for context exposure.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">AtAnnotation := '@annotation' '(' AnnotationOrIdentifier ')'</code></pre>
</div>
</div>
<div class="paragraph">
<p>The subject of a join point is defined in the table in chapter one of
this guide.</p>
</div>
<div class="paragraph">
<p>Access to annotation information on members at a matched join point is
also available through the <code>getSignature</code> method of the <code>JoinPoint</code> and
<code>JoinPoint.StaticPart</code> interfaces. The <code>Signature</code> interfaces are
extended with additional operations that provide access to the
<code>java.lang.reflect</code> <code>Method, Field</code> and <code>Constructor</code> objects on which
annnotations can be queried. The following fragment illustrates an
example use of this interface to access annotation information.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">Signature</span> sig = thisJoinPointStaticPart.getSignature();
<span class="predefined-type">AnnotatedElement</span> declaringTypeAnnotationInfo = sig.getDeclaringType();
<span class="keyword">if</span> (sig <span class="keyword">instanceof</span> MethodSignature) {
  <span class="comment">// this must be a call or execution join point</span>
  <span class="predefined-type">Method</span> method = ((MethodSignature)sig).getMethod();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Note again that it would be nicer to add the method getAnnotationInfo
directly to MemberSignature, but this would once more couple the runtime
library to Java 5.</em></p>
</div>
<div class="paragraph">
<p>The <code>@this,@target</code> and <code>@args</code> pointcut designators can only be used to
match against annotations that have runtime retention. The
<code>@within, @withincode</code> and <code>@annotation</code> pointcut designators can only
be used to match against annotations that have at least class-file
retention, and if used in the binding form the annotation must have
runtime retention.</p>
</div>
</div>
<div class="sect3">
<h4 id="_package_and_parameter_annotations">Package and Parameter Annotations</h4>
<div class="paragraph">
<p><em>Matching on package annotations is not supported in AspectJ. Support
for this capability may be considered in a future release.</em></p>
</div>
<div class="paragraph">
<p>Parameter annotation matching is being added in AspectJ1.6. Initially
only matching is supported but binding will be implemented at some
point. Whether the annotation specified in a pointcut should be
considered to be an annotation on the parameter type or an annotation on
the parameter itself is determined through the use of parentheses around
the parameter type. Consider the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@SomeAnnotation</span>
<span class="type">class</span> <span class="class">AnnotatedType</span> {}

<span class="type">class</span> <span class="class">C</span> {
  <span class="directive">public</span> <span class="type">void</span> foo(AnnotatedType a) {}
  <span class="directive">public</span> <span class="type">void</span> goo(<span class="annotation">@SomeAnnotation</span> <span class="predefined-type">String</span> s) {}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The method foo has a parameter of an annotated type, and can be matched
by this pointcut:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">pointcut p(): execution(* *(<span class="annotation">@SomeAnnotation</span> *));</code></pre>
</div>
</div>
<div class="paragraph">
<p>When there is a single annotation specified like this, it is considered
to be part of the type pattern in the match against the parameter: 'a
parameter of any type that has the annotation @SomeAnnotation'.</p>
</div>
<div class="paragraph">
<p>To match the parameter annotation case, the method goo, this is the
pointcut:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">pointcut p(): execution(* *(<span class="annotation">@SomeAnnotation</span> (*)));</code></pre>
</div>
</div>
<div class="paragraph">
<p>The use of parentheses around the wildcard is effectively indicating
that the annotation should be considered separately to the type pattern
for the parameter type: 'a parameter of any type that has a parameter
annotation of @SomeAnnotation'.</p>
</div>
<div class="paragraph">
<p>To match when there is a parameter annotation and an annotation on the
type as well:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">pointcut p(): execution(* *(<span class="annotation">@SomeAnnotation</span> (<span class="annotation">@SomeOtherAnnotation</span> *)));</code></pre>
</div>
</div>
<div class="paragraph">
<p>The parentheses are grouping @SomeOtherAnnotation with the * to form the
type pattern for the parameter, then the type @SomeAnnotation will be
treated as a parameter annotation pattern.</p>
</div>
</div>
<div class="sect3">
<h4 id="_annotation_inheritance_and_pointcut_matching">Annotation Inheritance and pointcut matching</h4>
<div class="paragraph">
<p>According to the Java 5 specification, non-type annotations are not
inherited, and annotations on types are only inherited if they have the
<code>@Inherited</code> meta-annotation. Given the following program:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">C1</span> {
  <span class="annotation">@SomeAnnotation</span>
  <span class="directive">public</span> <span class="type">void</span> aMethod() {...}
}

<span class="type">class</span> <span class="class">C2</span> <span class="directive">extends</span> C1 {
  <span class="directive">public</span> <span class="type">void</span> aMethod() {...}
}

<span class="type">class</span> <span class="class">Main</span> {
  <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
    C1 c1 = <span class="keyword">new</span> C1();
    C2 c2 = <span class="keyword">new</span> C2();
    c1.aMethod();
    c2.aMethod();
  }
}

aspect X {
  pointcut annotatedC2MethodCall() :
    call(<span class="annotation">@SomeAnnotation</span> * C2.aMethod());

  pointcut annotatedMethodCall() :
    call(<span class="annotation">@SomeAnnotation</span> * aMethod());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The pointcut <code>annotatedC2MethodCall</code> will not match anything since the
definition of <code>aMethod</code> in <code>C2</code> does not have the annotation.</p>
</div>
<div class="paragraph">
<p>The pointcut <code>annotatedMethodCall</code> matches <code>c1.aMethod()</code> but not
<code>c2.aMethod()</code>. The call to <code>c2.aMethod</code> is not matched because join
point matching for modifiers (the visibility modifiers, annotations, and
throws clause) is based on the subject of the join point (the method
actually being called).</p>
</div>
</div>
<div class="sect3">
<h4 id="matchingOnAnnotationValues">Matching based on annotation values</h4>
<div class="paragraph">
<p>The <code>if</code> pointcut designator can be used to write pointcuts that match
based on the values annotation members. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">pointcut txRequiredMethod(Tx transactionAnnotation) :
    execution(* *(..)) &amp;&amp; <span class="annotation">@this</span>(transactionAnnotation)
    &amp;&amp; <span class="keyword">if</span>(transactionAnnotation.policy() == TxPolicy.REQUIRED);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="annotations-decp">Using Annotations with declare statements</h3>
<div class="sect3">
<h4 id="_declare_error_and_declare_warning">Declare error and declare warning</h4>
<div class="paragraph">
<p>Since pointcut expressions in AspectJ 5 support join point matching
based on annotations, this facility can be exploited when writing
<code>declare warning</code> and <code>declare error</code> statements. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">declare warning : withincode(<span class="annotation">@PerformanceCritical</span> * *(..)) &amp;&amp;
                  call(<span class="annotation">@ExpensiveOperation</span> * *(..))
                : <span class="string"><span class="delimiter">&quot;</span><span class="content">Expensive operation called from within performance critical section</span><span class="delimiter">&quot;</span></span>;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">declare error : call(* org.xyz.model.*.*(..)) &amp;&amp;
                !<span class="annotation">@within</span>(Trusted)
                : <span class="string"><span class="delimiter">&quot;</span><span class="content">Untrusted code should not call the model classes directly</span><span class="delimiter">&quot;</span></span>;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_declare_parents">declare parents</h4>
<div class="paragraph">
<p>The general form of a <code>declare parents</code> statement is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">declare parents : TypePattern extends Type;
declare parents : TypePattern implements TypeList;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since AspectJ 5 supports annotations as part of a type pattern
specification, it is now possible to match types based on the presence
of annotations <em>with either class-file or runtime retention</em>. For
example:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>declare parents : (@Secured *) implements SecuredObject;</code></dt>
<dd>
<p>All types with the <code>@Secured</code> annotation implement the <code>SecuredObject</code>
inteface.</p>
</dd>
<dt class="hdlist1"><code>declare parents : (@Secured BankAccount+) implements SecuredObject;</code></dt>
<dd>
<p>The subset of types drawn from the <code>BankAccount</code> type and any subtype
of <code>BankAccount</code>, where the <code>@Secured</code> annotation is present,
implement the <code>SecuredObject</code> interface.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>An annotation type may not be used as the target of a declare parents
statement. If an annotation type is named explicitly as the target of a
declare parents statement, a compilation error will result. If an
annotation type is matched by a non-explicit type pattern used in a
declare parents statement it will be ignored (and an XLint warning
issued).</p>
</div>
</div>
<div class="sect3">
<h4 id="_declare_precedence">declare precedence</h4>
<div class="paragraph">
<p>The general form of a declare precedence statement is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">declare precedence : TypePatList;</code></pre>
</div>
</div>
<div class="paragraph">
<p>AspectJ 5 allows the type patterns in the list to include annotation
information as part of the pattern specification. For example:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>declare precedence : (@Security <strong>),</strong>;</code></dt>
<dd>
<p>All aspects with the <code>@Security</code> annotation take precedence over any
other aspects in the system. (Or, more informally, all
security-related aspects take precedence).</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect2">
<h3 id="annotations-declare">Declare Annotation</h3>
<div class="paragraph">
<p>AspectJ 5 supports a new kind of declare statement,
<code>declare annotation</code>. This takes different forms according to the
recipient of the annotation: <code>declare @type</code> for types,
<code>declare @method</code> for methods, <code>declare @constructor</code> for constructors,
and <code>declare @field</code> for fields. <code>declare @package</code> may be supported in
a future release.</p>
</div>
<div class="paragraph">
<p>The general form is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">declare @&lt;kind&gt; : ElementPattern : Annotation ;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Where annotation is a regular annotation expression as defined in the
Java 5 language. If the annotation has the <code>@Target</code> meta-annotation,
then the elements matched by <code>ElementPattern</code> must be of the kind
specified by the <code>@Target</code> annotation.</p>
</div>
<div class="paragraph">
<p><code>ElementPattern</code> is defined as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">ElementPattern := TypePattern |
                  MethodPattern |
                  ConstructorPattern |
                  FieldPattern</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following examples illustrate the use of <code>declare annotation</code>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>declare @type : org.xyz.model..* : @BusinessDomain ;</code></dt>
<dd>
<p>  All types defined in a package with the prefix <code>org.xyz.model</code> have
  the <code>@BusinessDomain</code> annotation.
declare @method : public * BankAccount+.*(..) :</p>
</dd>
<dt class="hdlist1"><code>@Secured(role="supervisor")</code></dt>
<dd>
<p>  All public methods in <code>BankAccount</code> and its subtypes have the
  annotation <code>@Secured(role="supervisor")</code>.
declare @constructor : BankAccount+.new(..) :</p>
</dd>
<dt class="hdlist1"><code>@Secured(role="supervisor")</code></dt>
<dd>
<p>All constructors in <code>BankAccount</code> and its subtypes have the annotation
<code>@Secured(role="supervisor")</code>.</p>
</dd>
<dt class="hdlist1"><code>declare @field : * DAO+.* : @Persisted;</code></dt>
<dd>
<p>All fields defined in <code>DAO</code> or its subtypes have the <code>@Persisted</code>
annotation.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="annotations-itds">Inter-type Declarations</h3>
<div class="paragraph">
<p>An annotation type may not be the target of an inter-type declaration.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_generics">Generics</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="generics-inJava5">Generics in Java 5</h3>
<div class="paragraph">
<p>This section provides the essential information about generics in Java 5
needed to understand how generics are treated in AspectJ 5. For a full
introduction to generics in Java, please see the documentation for the
Java 5 SDK.</p>
</div>
<div class="sect3">
<h4 id="_declaring_generic_types">Declaring Generic Types</h4>
<div class="paragraph">
<p>A generic type is declared with one or more type parameters following
the type name. By convention formal type parameters are named using a
single letter, though this is not required. A simple generic list type
(that can contain elements of any type <code>E</code>) could be declared:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">interface</span> <span class="class">List</span>&lt;E&gt; {
   <span class="predefined-type">Iterator</span>&lt;E&gt; iterator();
   <span class="type">void</span> add(E anItem);
   E remove(E anItem);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is important to understand that unlike template mechanisms there will
only be one type, and one class file, corresponding to the <code>List</code>
interface, regardless of how many different instantiations of the <code>List</code>
interface a program has (each potentially providing a different value
for the type parameter <code>E</code>). A consequence of this is that you cannot
refer to the type parameters of a type declaration in a static method or
initializer, or in the declaration or initializer of a static variable.</p>
</div>
<div class="paragraph">
<p>A <em>parameterized type</em> is an invocation of a generic type with concrete
values supplied for all of its type parameters (for example,
<code>List&lt;String&gt;</code> or <code>List&lt;Food&gt;</code>).</p>
</div>
<div class="paragraph">
<p>A generic type may be declared with multiple type parameters. In
addition to simple type parameter names, type parameter declarations can
also constrain the set of types allowed by using the <code>extends</code> keyword.
Some examples follow:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>class Foo&lt;T&gt; {&#8230;&#8203;}</code></dt>
<dd>
<p>A class <code>Foo</code> with one type parameter, <code>T</code>.</p>
</dd>
<dt class="hdlist1"><code>class Foo&lt;T,S&gt; {&#8230;&#8203;}</code></dt>
<dd>
<p>A class <code>Foo</code> with two type parameters, <code>T</code> and <code>S</code>.</p>
</dd>
<dt class="hdlist1"><code>class Foo&lt;T extends Number&gt; {&#8230;&#8203;}</code></dt>
<dd>
<p>A class <code>Foo</code> with one type parameter <code>T</code>, where <code>T</code> must be
instantiated as the type <code>Number</code> or a subtype of <code>Number</code>.</p>
</dd>
<dt class="hdlist1"><code>class Foo&lt;T, S extends T&gt; {&#8230;&#8203;}</code></dt>
<dd>
<p>A class <code>Foo</code> with two type parameters, <code>T</code> and <code>S</code>. <code>Foo</code> must be
instantiated with a type <code>S</code> that is a subtype of the type specified
for parameter <code>T</code>.</p>
</dd>
<dt class="hdlist1"><code>class Foo&lt;T extends Number &amp; Comparable&gt; {&#8230;&#8203;}</code></dt>
<dd>
<p>A class <code>Foo</code> with one type parameter, <code>T</code>. <code>Foo</code> must be instantiated
with a type that is a subtype of <code>Number</code> and that implements
<code>Comparable</code>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_using_generic_and_parameterized_types">Using Generic and Parameterized Types</h4>
<div class="paragraph">
<p>You declare a variable (or a method/constructor argument) of a
parameterized type by specifying a concrete type specfication for each
type parameter in the generic type. The following example declares a
list of strings and a list of numbers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; strings;
<span class="predefined-type">List</span>&lt;<span class="predefined-type">Number</span>&gt; numbers;</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is also possible to declare a variable of a generic type without
specifying any values for the type parameters (a <em>raw</em> type). For
example, <code>List strings</code>. In this case, unchecked warnings may be issued
by the compiler when the referenced object is passed as a parameter to a
method expecting a parameterized type such as a <code>List&lt;String&gt;</code>. New code
written in the Java 5 language would not be expected to use raw types.</p>
</div>
<div class="paragraph">
<p>Parameterized types are instantiated by specifying type parameter values
in the constructor call expression as in the following examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; strings = <span class="keyword">new</span> MyListImpl&lt;<span class="predefined-type">String</span>&gt;();
<span class="predefined-type">List</span>&lt;<span class="predefined-type">Number</span>&gt; numbers = <span class="keyword">new</span> MyListImpl&lt;<span class="predefined-type">Number</span>&gt;();</code></pre>
</div>
</div>
<div class="paragraph">
<p>When declaring parameterized types, the <code>?</code> wildcard may be used, which
stands for "some type". The <code>extends</code> and <code>super</code> keywords may be used
in conjunction with the wildcard to provide upper and lower bounds on
the types that may satisfy the type constraints. For example:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>List&lt;?&gt;</code></dt>
<dd>
<p>A list containing elements of some type, the type of the elements in
the list is unknown.</p>
</dd>
<dt class="hdlist1"><code>List&lt;? extends Number&gt;</code></dt>
<dd>
<p>A list containing elements of some type that extends Number, the exact
type of the elements in the list is unknown.</p>
</dd>
<dt class="hdlist1"><code>List&lt;? super Double&gt;</code></dt>
<dd>
<p>A list containing elements of some type that is a super-type of
Double, the exact type of the elements in the list is unknown.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>A generic type may be extended as any other type. Given a generic type
<code>Foo&lt;T&gt;</code> then a subtype <code>Goo</code> may be declared in one of the following
ways:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>class Goo extends Foo</code></dt>
<dd>
<p>Here <code>Foo</code> is used as a raw type, and the appropriate warning messages
will be issued by the compiler on attempting to invoke methods in
<code>Foo</code>.</p>
</dd>
<dt class="hdlist1"><code>class Goo&lt;E&gt; extends Foo</code></dt>
<dd>
<p><code>Goo</code> is a generic type, but the super-type <code>Foo</code> is used as a raw
type and the appropriate warning messages will be issued by the
compiler on attempting to invoke methods defined by <code>Foo</code>.</p>
</dd>
<dt class="hdlist1"><code>class Goo&lt;E&gt; extends Foo&lt;E&gt;</code></dt>
<dd>
<p>This is the most usual form. <code>Goo</code> is a generic type with one
parameter that extends the generic type <code>Foo</code> with that same
parameter. So <code>Goo&lt;String&lt;</code> is a subclass of <code>Foo&lt;String&gt;</code>.</p>
</dd>
<dt class="hdlist1"><code>class Goo&lt;E,F&gt; extends Foo&lt;E&gt;</code></dt>
<dd>
<p><code>Goo</code> is a generic type with two parameters that extends the generic
type <code>Foo</code> with the first type parameter of <code>Goo</code> being used to
parameterize <code>Foo</code>. So <code>Goo&lt;String,Integer&lt;</code> is a subclass of
<code>Foo&lt;String&gt;</code>.</p>
</dd>
<dt class="hdlist1"><code>class Goo extends Foo&lt;String&gt;</code></dt>
<dd>
<p><code>Goo</code> is a type that extends the parameterized type <code>Foo&lt;String&gt;</code>.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>A generic type may implement one or more generic interfaces, following
the type binding rules given above. A type may also implement one or
more parameterized interfaces (for example,
<code>class X implements List&lt;String&gt;</code>, however a type may not at the same
time be a subtype of two interface types which are different
parameterizations of the same interface.</p>
</div>
</div>
<div class="sect3">
<h4 id="_subtypes_supertypes_and_assignability">Subtypes, Supertypes, and Assignability</h4>
<div class="paragraph">
<p>The supertype of a generic type <code>C</code> is the type given in the extends
clause of <code>C</code>, or <code>Object</code> if no extends clause is present. Given the
type declaration</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">List</span>&lt;E&gt; <span class="directive">extends</span> <span class="predefined-type">Collection</span>&lt;E&gt; {... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>then the supertype of <code>List&lt;E&gt;</code> is <code>Collection&lt;E&gt;</code>.</p>
</div>
<div class="paragraph">
<p>The supertype of a parameterized type <code>P</code> is the type given in the
extends clause of <code>P</code>, or <code>Object</code> if no extends clause is present. Any
type parameters in the supertype are substituted in accordance with the
parameterization of <code>P</code>. An example will make this much clearer: Given
the type <code>List&lt;Double&gt;</code> and the definition of the <code>List</code> given above,
the direct supertype is <code>Collection&lt;Double&gt;</code>. <code>List&lt;Double&gt;</code> is <em>not</em>
considered to be a subtype of <code>List&lt;Number&gt;</code>.</p>
</div>
<div class="paragraph">
<p>An instance of a parameterized type <code>P&lt;T1,T2,&#8230;&#8203;Tn&gt;`may be assigned to a
variable of the same type or a supertype without casting. In addition it
may be assigned to a variable `R&lt;S1,S2,&#8230;&#8203;Sm&gt;</code> where <code>R</code> is a supertype
of <code>P</code> (the supertype relationship is reflexive), <code>m &#8656; n</code>, and for all
type parameters <code>S1..m</code>, <code>Tm</code> equals <code>Sm</code> <em>or</em> <code>Sm</code> is a wildcard type
specification and <code>Tm</code> falls within the bounds of the wildcard. For
example, <code>List&lt;String&gt;</code> can be assigned to a variable of type
<code>Collection&lt;?&gt;</code>, and <code>List&lt;Double&gt;</code> can be assigned to a variable of
type <code>List&lt;? extends Number&gt;</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_generic_methods_and_constructors">Generic Methods and Constructors</h4>
<div class="paragraph">
<p>A static method may be declared with one or more type parameters as in
the following declaration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">static</span> &lt;T&gt; T first(<span class="predefined-type">List</span>&lt;T&gt; ts) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Such a definition can appear in any type, the type parameter <code>T</code> does
not need to be declared as a type parameter of the enclosing type.</p>
</div>
<div class="paragraph">
<p>Non-static methods may also be declared with one or more type parameters
in a similar fashion:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">&lt;T <span class="directive">extends</span> <span class="predefined-type">Number</span>&gt; T max(T t1, T t2) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The same technique can be used to declare a generic constructor.</p>
</div>
</div>
<div class="sect3">
<h4 id="_erasure">Erasure</h4>
<div class="paragraph">
<p>Generics in Java are implemented using a technique called <em>erasure</em>. All
type parameter information is erased from the run-time type system.
Asking an object of a parameterized type for its class will return the
class object for the raw type (eg. <code>List</code> for an object declared to be
of type <code>List&lt;String&gt;</code>. A consequence of this is that you cannot at
runtime ask if an object is an <code>instanceof</code> a parameterized type.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="generics-inAspectJ5">Generics in AspectJ 5</h3>
<div class="paragraph">
<p>AspectJ 5 provides full support for all of the Java 5 language features,
including generics. Any legal Java 5 program is a legal AspectJ 5
progam. In addition, AspectJ 5 provides support for generic and
parameterized types in pointcuts, inter-type declarations, and declare
statements. Parameterized types may freely be used within aspect
members, and support is also provided for generic <em>abstract</em> aspects.</p>
</div>
<div class="sect3">
<h4 id="_matching_generic_and_parameterized_types_in_pointcut_expressions">Matching generic and parameterized types in pointcut expressions</h4>
<div class="paragraph">
<p>The simplest way to work with generic and parameterized types in
pointcut expressions and type patterns is simply to use the raw type
name. For example, the type pattern <code>List</code> will match the generic type
<code>List&lt;E&gt;</code> and any parameterization of that type
(<code>List&lt;String&gt;, List&lt;?&gt;, List&lt;? extends Number&gt;</code> and so on. This ensures
that pointcuts written in existing code that is not generics-aware will
continue to work as expected in AspectJ 5. It is also the recommended
way to match against generic and parameterized types in AspectJ 5 unless
you explicitly wish to narrow matches to certain parameterizations of a
generic type.</p>
</div>
<div class="paragraph">
<p>Generic methods and constructors, and members defined in generic types,
may use type variables as part of their signature. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Utils</span> {

  <span class="comment">/** static generic method */</span>
  <span class="directive">static</span> &lt;T&gt; T first(<span class="predefined-type">List</span>&lt;T&gt; ts) { ... }

  <span class="comment">/** instance generic method */</span>
  &lt;T <span class="directive">extends</span> <span class="predefined-type">Number</span>&gt; T max(T t1, T t2) { ... }

}

<span class="directive">public</span> <span class="type">class</span> <span class="class">G</span>&lt;T&gt; {

   <span class="comment">// field with parameterized type</span>
   T myData;

   <span class="comment">// method with parameterized return type</span>
   <span class="directive">public</span> <span class="predefined-type">List</span>&lt;T&gt; getAllDataItems() {...}

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>AspectJ 5 does not allow the use of type variables in pointcut
expressions and type patterns. Instead, members that use type parameters
as part of their signature are matched by their <em>erasure</em>. Java 5
defines the rules for determing the erasure of a type as follows.</p>
</div>
<div class="paragraph">
<p>Let <code>|T|</code> represent the erasure of some type <code>T</code>. Then:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The erasure of a parameterized type <code>T&lt;T1,&#8230;&#8203;,Tn&gt;</code> is <code>|T|</code>.
For example, the erasure of <code>List&lt;String&gt;</code> is <code>List</code>.</p>
</li>
<li>
<p>The erasure of a nested type <code>T.C</code> is <code>|T|.C</code>.
For example, the erasure of the nested type <code>Foo&lt;T&gt;.Bar</code> is <code>Foo.Bar</code>.</p>
</li>
<li>
<p>The erasure of an array type <code>T[]</code> is <code>|T|[]</code>.
For example, the erasure of <code>List&lt;String&gt;[]</code> is <code>List[]</code>.</p>
</li>
<li>
<p>The erasure of a type variable is its leftmost bound.
For example, the erasure of a type variable <code>P</code> is <code>Object</code>,
and the erasure of a type variable <code>N extends Number</code> is <code>Number</code>.</p>
</li>
<li>
<p>The erasure of every other type is the type itself.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Applying these rules to the earlier examples, we find that the methods
defined in <code>Utils</code> can be matched by a signature pattern matching
<code>static Object Utils.first(List)</code> and <code>Number Utils.max(Number, Number)</code>
respectively. The members of the generic type <code>G</code> can be matched by a
signature pattern matching <code>Object G.myData</code> and
<code>public List G.getAllDataItems()</code> respectively.</p>
</div>
<div class="sect4">
<h5 id="_restricting_matching_using_parameterized_types">Restricting matching using parameterized types</h5>
<div class="paragraph">
<p>Pointcut matching can be further restricted to match only given
parameterizations of parameter types (methods and constructors), return
types (methods) and field types (fields). This is achieved by specifying
a parameterized type pattern at the appropriate point in the signature
pattern. For example, given the class <code>Foo</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Foo</span> {

  <span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; myStrings;
  <span class="predefined-type">List</span>&lt;<span class="predefined-type">Float</span>&gt;  myFloats;

  <span class="directive">public</span> <span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; getStrings() { <span class="keyword">return</span> myStrings; }
  <span class="directive">public</span> <span class="predefined-type">List</span>&lt;<span class="predefined-type">Float</span>&gt; getFloats() { <span class="keyword">return</span> myFloats; }

  <span class="directive">public</span> <span class="type">void</span> addStrings(<span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; evenMoreStrings) {
     myStrings.addAll(evenMoreStrings);
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then a <code>get</code> join point for the field <code>myStrings</code> can be matched by the
pointcut <code>get(List Foo.myStrings)</code> and by the pointcut
<code>get(List&lt;String&gt; Foo.myStrings)</code>, but <em>not</em> by the pointcut
<code>get(List&lt;Number&gt; *)</code>.</p>
</div>
<div class="paragraph">
<p>A <code>get</code> join point for the field <code>myFloats</code> can be matched by the
pointcut <code>get(List Foo.myFloats)</code>, the pointcut <code>get(List&lt;Float&gt; *)</code>,
and the pointcut <code>get(List&lt;Number+&gt; *)</code>. This last example shows how
AspectJ type patterns can be used to match type parameters types just
like any other type. The pointcut <code>get(List&lt;Double&gt; *)</code> does <em>not</em>
match.</p>
</div>
<div class="paragraph">
<p>The execution of the methods <code>getStrings</code> and <code>getFloats</code> can be matched
by the pointcut expression <code>execution(List get*(..))</code>, and the pointcut
expression <code>execution(List&lt;*&gt; get*(..))</code>, but only <code>getStrings</code> is
matched by <code>execution(List&lt;String&gt; get*(..))</code> and only <code>getFloats</code> is
matched by <code>execution(List&lt;Number+&gt; get*(..))</code></p>
</div>
<div class="paragraph">
<p>A call to the method <code>addStrings</code> can be matched by the pointcut
expression <code>call(* addStrings(List))</code> and by the expression
<code>call(* addStrings(List&lt;String&gt;))</code>, but <em>not</em> by the expression
<code>call(* addStrings(List&lt;Number&gt;))</code>.</p>
</div>
<div class="paragraph">
<p>Remember that any type variable reference in a generic member is
<em>always</em> matched by its erasure. Thus given the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">G</span>&lt;T&gt; {
    <span class="predefined-type">List</span>&lt;T&gt; foo(<span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; ls) { <span class="keyword">return</span> <span class="predefined-constant">null</span>; }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The execution of <code>foo</code> can be matched by <code>execution(List foo(List))</code>,
<code>execution(List foo(List&lt;String&gt;&gt;))</code>, and
<code>execution(* foo(List&lt;String&lt;))`but <em>not</em> by
`execution(List&lt;Object&gt; foo(List&lt;String&gt;&gt;)</code> since the erasure of
<code>List&lt;T&gt;</code> is <code>List</code> and not <code>List&lt;Object&gt;</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_generic_wildcards_and_signature_matching">Generic wildcards and signature matching</h5>
<div class="paragraph">
<p>When it comes to signature matching, a type parameterized using a
generic wildcard is a distinct type. For example, <code>List&lt;?&gt;</code> is a very
different type to <code>List&lt;String&gt;</code>, even though a variable of type
<code>List&lt;String&gt;</code> can be assigned to a variable of type <code>List&lt;?&gt;</code>. Given
the methods:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">C</span> {
  <span class="directive">public</span> <span class="type">void</span> foo(<span class="predefined-type">List</span>&lt;? <span class="directive">extends</span> <span class="predefined-type">Number</span>&gt; listOfSomeNumberType) {}
  <span class="directive">public</span> <span class="type">void</span> bar(<span class="predefined-type">List</span>&lt;?&gt; listOfSomeType) {}
  <span class="directive">public</span> <span class="type">void</span> goo(<span class="predefined-type">List</span>&lt;<span class="predefined-type">Double</span>&gt; listOfDoubles) {}
}</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>execution(* C.*(List))</code></dt>
<dd>
<p>Matches an execution join point for any of the three methods.</p>
</dd>
<dt class="hdlist1"><code>execution(* C.*(List&lt;? extends Number&gt;))</code></dt>
<dd>
<p>matches only the execution of <code>foo</code>, and <em>not</em> the execution of <code>goo</code>
since <code>List&lt;? extends Number&gt;</code> and <code>List&lt;Double&gt;</code> are distinct types.</p>
</dd>
<dt class="hdlist1"><code>execution(* C.*(List&lt;?&gt;))</code></dt>
<dd>
<p>matches only the execution of <code>bar</code>.</p>
</dd>
<dt class="hdlist1"><code>execution(* C.*(List&lt;? extends Object+&gt;))</code></dt>
<dd>
<p>matches both the execution of <code>foo</code> and the execution of <code>bar</code> since
the upper bound of <code>List&lt;?&gt;</code> is implicitly <code>Object</code>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_treatment_of_bridge_methods">Treatment of bridge methods</h5>
<div class="paragraph">
<p>Under certain circumstances a Java 5 compiler is required to create
<em>bridge methods</em> that support the compilation of programs using raw
types. Consider the types</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">Generic</span>&lt;T&gt; {
  <span class="directive">public</span> T foo(T someObject) {
    <span class="keyword">return</span> someObject;
  }
}

<span class="type">class</span> <span class="class">SubGeneric</span>&lt;N <span class="directive">extends</span> <span class="predefined-type">Number</span>&gt; <span class="directive">extends</span> Generic&lt;N&gt; {
  <span class="directive">public</span> N foo(N someNumber) {
    <span class="keyword">return</span> someNumber;
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The class <code>SubGeneric</code> extends <code>Generic</code> and overrides the method <code>foo</code>.
Since the upper bound of the type variable <code>N</code> in <code>SubGeneric</code> is
different to the upper bound of the type variable <code>T</code> in <code>Generic</code>, the
method <code>foo</code> in <code>SubGeneric</code> has a different erasure to the method <code>foo</code>
in <code>Generic</code>. This is an example of a case where a Java 5 compiler will
create a <em>bridge method</em> in <code>SubGeneric</code>. Although you never see it, the
bridge method will look something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="predefined-type">Object</span> foo(<span class="predefined-type">Object</span> arg) {
  <span class="predefined-type">Number</span> n = (<span class="predefined-type">Number</span>) arg; <span class="comment">// &quot;bridge&quot; to the signature defined in this type</span>
<span class="keyword">return</span> foo(n);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bridge methods are synthetic artefacts generated as a result of a
particular compilation strategy and have no execution join points in
AspectJ 5. So the pointcut <code>execution(Object SubGeneric.foo(Object))</code>
does not match anything. (The pointcut
<code>execution(Object Generic.foo(Object))</code> matches the execution of <code>foo</code>
in both <code>Generic</code> and <code>SubGeneric</code> since both are implementations of
<code>Generic.foo</code>).</p>
</div>
<div class="paragraph">
<p>It <em>is</em> possible to <em>call</em> a bridge method as the following short code
snippet demonstrates. Such a call <em>does</em> result in a call join point for
the call to the method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">SubGeneric rawType = <span class="keyword">new</span> SubGeneric();
rawType.foo(<span class="string"><span class="delimiter">&quot;</span><span class="content">hi</span><span class="delimiter">&quot;</span></span>);  <span class="comment">// call to bridge method (will result in a runtime failure in this case)</span>
<span class="predefined-type">Object</span> n = <span class="keyword">new</span> <span class="predefined-type">Integer</span>(<span class="integer">5</span>);
rawType.foo(n);     <span class="comment">// call to bridge method that would succeed at runtime</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_runtime_type_matching_with_this_target_and_args">Runtime type matching with this(), target() and args()</h5>
<div class="paragraph">
<p>The <code>this()</code>, <code>target()</code>, and <code>args()</code> pointcut expressions all match
based on the runtime type of their arguments. Because Java 5 implements
generics using erasure, it is not possible to ask at runtime whether an
object is an instance of a given parameterization of a type (only
whether or not it is an instance of the erasure of that parameterized
type). Therefore AspectJ 5 does not support the use of parameterized
types with the <code>this()</code> and <code>target()</code> pointcuts. Parameterized types
may however be used in conjunction with <code>args()</code>. Consider the following
class</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">C</span> {
  <span class="directive">public</span> <span class="type">void</span> foo(<span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; listOfStrings) {}

  <span class="directive">public</span> <span class="type">void</span> bar(<span class="predefined-type">List</span>&lt;<span class="predefined-type">Double</span>&gt; listOfDoubles) {}

  <span class="directive">public</span> <span class="type">void</span> goo(<span class="predefined-type">List</span>&lt;? <span class="directive">extends</span> <span class="predefined-type">Number</span>&gt; listOfSomeNumberType) {}
}</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>args(List)</code></dt>
<dd>
<p>will match an execution or call join point for any of these methods</p>
</dd>
<dt class="hdlist1"><code>args(List&lt;String&gt;)</code></dt>
<dd>
<p>will match an execution or call join point for <code>foo</code>.</p>
</dd>
<dt class="hdlist1"><code>args(List&lt;Double&gt;)</code></dt>
<dd>
<p>matches an execution or call join point for <code>bar</code>, and <em>may</em> match at
an execution or call join point for <code>goo</code> since it is legitimate to
pass an object of type <code>List&lt;Double&gt;</code> to a method expecting a
<code>List&lt;? extends Number&gt;</code>.</p>
<div class="paragraph">
<p>In this situation, a runtime test would normally be applied to
ascertain whether or not the argument was indeed an instance of the
required type. However, in the case of parameterized types such a test
is not possible and therefore AspectJ 5 considers this a match, but
issues an <em>unchecked</em> warning. For example, compiling the aspect <code>A</code>
below with the class <code>C</code> produces the compilation warning: <code>unchecked
match of List&lt;Double&gt; with List&lt;? extends Number&gt; when argument is an
instance of List at join point method-execution(void C.goo(List&lt;?
extends Number&gt;)) [Xlint:uncheckedArgument]</code>;</p>
</div>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> aspect A {
   before(<span class="predefined-type">List</span>&lt;<span class="predefined-type">Double</span>&gt; listOfDoubles) : execution(* C.*(..)) &amp;&amp; args(listOfDoubles) {
      <span class="keyword">for</span> (<span class="predefined-type">Double</span> d : listOfDoubles) {
         <span class="comment">// do something</span>
      }
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Like all Lint messages, the <code>uncheckedArgument</code> warning can be
configured in severity from the default warning level to error or even
ignore if preferred. In addition, AspectJ 5 offers the annotation
<code>@SuppressAjWarnings</code> which is the AspectJ equivalent of Java&#8217;s
<code>@SuppressWarnings</code> annotation. If the advice is annotated with
<code>@SuppressWarnings</code> then <em>all</em> lint warnings issued during matching of
pointcut associated with the advice will be suppressed. To suppress just
an <code>uncheckedArgument</code> warning, use the annotation
<code>@SuppressWarnings("uncheckedArgument")</code> as in the following examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation.SuppressAjWarnings</span>
<span class="include">public</span> <span class="include">aspect</span> <span class="include">A</span> {
   <span class="annotation">@SuppressAjWarnings</span>   <span class="comment">// will not see *any* lint warnings for this advice</span>
   <span class="include">before</span>(<span class="include">List</span>&lt;<span class="include">Double</span>&gt; <span class="include">listOfDoubles</span>) : <span class="include">execution</span>(* <span class="include">C</span>.*(..)) &amp;&amp; <span class="include">args</span>(<span class="include">listOfDoubles</span>) {
      <span class="include">for</span> (<span class="include">Double</span> <span class="include">d</span> : <span class="include">listOfDoubles</span>) {
         <span class="comment">// do something</span>
      }
   }

   <span class="annotation">@SuppressAjWarnings</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">uncheckedArgument</span><span class="delimiter">&quot;</span></span>)   <span class="comment">// will not see *any* lint warnings for this advice</span>
   <span class="include">before</span>(<span class="include">List</span>&lt;<span class="include">Double</span>&gt; <span class="include">listOfDoubles</span>) : <span class="include">execution</span>(* <span class="include">C</span>.*(..)) &amp;&amp; <span class="include">args</span>(<span class="include">listOfDoubles</span>) {
      <span class="include">for</span> (<span class="include">Double</span> <span class="include">d</span> : <span class="include">listOfDoubles</span>) {
         <span class="comment">// do something</span>
      }
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The safest way to deal with <code>uncheckedArgument</code> warnings however is to
restrict the pointcut to match only at those join points where the
argument is guaranteed to match. This is achieved by combining <code>args</code>
with a <code>call</code> or <code>execution</code> signature matching pointcut. In the
following example the advice will match the execution of <code>bar</code> but not
of <code>goo</code> since the signature of <code>goo</code> is not matched by the execution
pointcut expression.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> aspect A {
   before(<span class="predefined-type">List</span>&lt;<span class="predefined-type">Double</span>&gt; listOfDoubles) : execution(* C.*(<span class="predefined-type">List</span>&lt;<span class="predefined-type">Double</span>&gt;)) &amp;&amp; args(listOfDoubles) {
      <span class="keyword">for</span> (<span class="predefined-type">Double</span> d : listOfDoubles) {
         <span class="comment">// do something</span>
      }
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Generic wildcards can be used in args type patterns, and matching
follows regular Java 5 assignability rules. For example, <code>args(List&lt;?&gt;)</code>
will match a list argument of any type, and
<code>args(List&lt;? extends Number&gt;)</code> will match an argument of type
<code>List&lt;Number&gt;, List&lt;Double&gt;, List&lt;Float&gt;</code> and so on. Where a match
cannot be fully statically determined, the compiler will once more issue
an <code>uncheckedArgument</code> warning.</p>
</div>
<div class="paragraph">
<p>Consider the following program:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">C</span> {
   <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
      C c = <span class="keyword">new</span> C();
      <span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; ls = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;<span class="predefined-type">String</span>&gt;();
      <span class="predefined-type">List</span>&lt;<span class="predefined-type">Double</span>&gt; ld = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;<span class="predefined-type">Double</span>&gt;();
      c.foo(<span class="string"><span class="delimiter">&quot;</span><span class="content">hi</span><span class="delimiter">&quot;</span></span>);
      c.foo(ls);
      c.foo(ld);
   }

   <span class="directive">public</span> <span class="type">void</span> foo(<span class="predefined-type">Object</span> anObject) {}
}

aspect A {
    before(<span class="predefined-type">List</span>&lt;? <span class="directive">extends</span> <span class="predefined-type">Number</span>&gt; aListOfSomeNumberType)
      : call(* foo(..)) &amp;&amp; args(aListOfSomeNumberType) {
       <span class="comment">// process list...</span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>From the signature of <code>foo</code> all we know is that the runtime argument
will be an instance of <code>Object</code>.Compiling this program gives the
unchecked argument warning: <code>unchecked match of List&lt;? extends Number&gt;
with List when argument is an instance of List at join point
method-execution(void C.foo(Object)) [Xlint:uncheckedArgument]</code>. The
advice will not execute at the call join point for <code>c.foo("hi")</code> since
<code>String</code> is not an instance of <code>List</code>. The advice <em>will</em> execute at the
call join points for <code>c.foo(ls)</code> and <code>c.foo(ld)</code> since in both cases the
argument is an instance of <code>List</code>.</p>
</div>
<div class="paragraph">
<p>Combine a wildcard argument type with a signature pattern to avoid
unchecked argument matches. In the example below we use the signature
pattern <code>List&lt;Number+&gt;</code> to match a call to any method taking a
<code>List&lt;Number&gt;, List&lt;Double&gt;, List&lt;Float&gt;</code> and so on. In addition the
signature pattern <code>List&lt;? extends Number+&gt;</code> can be used to match a call
to a method declared to take a <code>List&lt;? extends Number&gt;</code>,
<code>List&lt;? extends Double&gt;</code> and so on. Taken together, these restrict
matching to only those join points at which the argument is guaranteed
to be an instance of <code>List&lt;? extends Number&gt;</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect A {
    before(<span class="predefined-type">List</span>&lt;? <span class="directive">extends</span> <span class="predefined-type">Number</span>&gt; aListOfSomeNumberType)
      : (call(* foo(<span class="predefined-type">List</span>&lt;<span class="predefined-type">Number</span>+&gt;)) || call(* foo(<span class="predefined-type">List</span>&lt;? <span class="directive">extends</span> <span class="predefined-type">Number</span>+&gt;)))
        &amp;&amp; args(aListOfSomeNumberType) {
        <span class="comment">// process list...</span>
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_binding_return_values_in_after_returning_advice">Binding return values in after returning advice</h5>
<div class="paragraph">
<p>After returning advice can be used to bind the return value from a
matched join point. AspectJ 5 supports the use of a parameterized type
in the returning clause, with matching following the same rules as
described for args. For example, the following aspect matches the
execution of any method returning a <code>List</code>, and makes the returned list
available to the body of the advice.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> aspect A {
  pointcut executionOfAnyMethodReturningAList() : execution(<span class="predefined-type">List</span> *(..));

  after() returning(<span class="predefined-type">List</span>&lt;?&gt; listOfSomeType) : executionOfAnyMethodReturningAList() {
    <span class="keyword">for</span> (<span class="predefined-type">Object</span> element : listOfSomeType) {
       <span class="comment">// process element...</span>
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The pointcut uses the raw type pattern <code>List</code>, and hence it matches
methods returning any kind of list (<code>List&lt;String&gt;, List&lt;Double&gt;</code>, and so
on). We&#8217;ve chosen to bind the returned list as the parameterized type
<code>List&lt;?&gt;</code> in the advice since Java&#8217;s type checking will now ensure that
we only perform safe operations on the list.</p>
</div>
<div class="paragraph">
<p>Given the class</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">C</span> {
  <span class="directive">public</span> <span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; foo(<span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; listOfStrings) {...}
  <span class="directive">public</span> <span class="predefined-type">List</span>&lt;<span class="predefined-type">Double</span>&gt; bar(<span class="predefined-type">List</span>&lt;<span class="predefined-type">Double</span>&gt; listOfDoubles) {...}
  <span class="directive">public</span> <span class="predefined-type">List</span>&lt;? <span class="directive">extends</span> <span class="predefined-type">Number</span>&gt; goo(<span class="predefined-type">List</span>&lt;? <span class="directive">extends</span> <span class="predefined-type">Number</span>&gt; listOfSomeNumberType) {...}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The advice in the aspect below will run after the execution of <code>bar</code> and
bind the return value. It will also run after the execution of <code>goo</code> and
bind the return value, but gives an <code>uncheckedArgument</code> warning during
compilation. It does <em>not</em> run after the execution of <code>foo</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> aspect Returning {
  after() returning(<span class="predefined-type">List</span>&lt;<span class="predefined-type">Double</span>&gt; listOfDoubles) : execution(* C.*(..)) {
     <span class="keyword">for</span>(<span class="predefined-type">Double</span> d : listOfDoubles) {
        <span class="comment">// process double...</span>
     }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As with <code>args</code> you can guarantee that after returning advice only
executes on lists <em>statically determinable</em> to be of the right type by
specifying a return type pattern in the associated pointcut. The
<code>@SuppressAjWarnings</code> annotation can also be used if desired.</p>
</div>
</div>
<div class="sect4">
<h5 id="_declaring_pointcuts_inside_generic_types">Declaring pointcuts inside generic types</h5>
<div class="paragraph">
<p>Pointcuts can be declared in both classes and aspects. A pointcut
declared in a generic type may use the type variables of the type in
which it is declared. All references to a pointcut declared in a generic
type from outside of that type must be via a parameterized type
reference, and not a raw type reference.</p>
</div>
<div class="paragraph">
<p>Consider the generic type <code>Generic</code> with a pointcut <code>foo</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Generic</span>&lt;T&gt; {
   <span class="comment">/**
    * matches the execution of any implementation of a method defined for T
    */</span>
   <span class="directive">public</span> pointcut foo() : execution(* T.*(..));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Such a pointcut must be refered to using a parameterized reference as
shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> aspect A {
  <span class="comment">// runs before the execution of any implementation of a method defined for MyClass</span>
  before() : Generic&lt;MyClass&gt;.foo() {
     <span class="comment">// ...</span>
  }

  <span class="comment">// runs before the execution of any implementation of a method defined for YourClass</span>
  before() : Generic&lt;YourClass&gt;.foo() {
      <span class="comment">// ...</span>
  }

  <span class="comment">// results in a compilation error - raw type reference</span>
  before() : Generic.foo() { }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_inter_type_declarations">Inter-type Declarations</h4>
<div class="paragraph">
<p>AspectJ 5 supports the inter-type declaration of generic methods, and of
members on generic types. For generic methods, the syntax is exactly as
for a regular method declaration, with the addition of the target type
specification:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>&lt;T extends Number&gt; T Utils.max(T first, T second) {&#8230;&#8203;}</code></dt>
<dd>
<p>Declares a generic instance method <code>max</code> on the class <code>Util</code>. The
<code>max</code> method takes two arguments, <code>first</code> and <code>second</code> which must both
be of the same type (and that type must be <code>Number</code> or a subtype of
<code>Number</code>) and returns an instance of that type.</p>
</dd>
<dt class="hdlist1"><code>static &lt;E&gt; E Utils.first(List&lt;E&gt; elements) {&#8230;&#8203;}</code></dt>
<dd>
<p>Declares a static generic method <code>first</code> on the class <code>Util</code>. The
<code>first</code> method takes a list of elements of some type, and returns an
instance of that type.</p>
</dd>
<dt class="hdlist1">&lt;T&gt; Sorter.new(List&lt;T&gt; elements,Comparator&lt;? super T&gt; comparator) <code>{&#8230;&#8203;}</code></dt>
<dd>
<p>Declares a constructor on the class <code>Sorter</code>. The constructor takes a
list of elements of some type, and a comparator that can compare
instances of the element type.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>A generic type may be the target of an inter-type declaration, used
either in its raw form or with type parameters specified. If type
parameters are specified, then the number of type parameters given must
match the number of type parameters in the generic type declaration.
Type parameter <em>names</em> do not have to match. For example, given the
generic type <code>Foo&lt;T,S extends Number&gt;</code> then:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>String Foo.getName() {&#8230;&#8203;}</code></dt>
<dd>
<p>Declares a <code>getName</code> method on behalf of the type <code>Foo</code>. It is not
possible to refer to the type parameters of Foo in such a declaration.</p>
</dd>
<dt class="hdlist1"><code>public R Foo&lt;Q, R&gt;.getMagnitude() {&#8230;&#8203;}</code></dt>
<dd>
<p>Declares a method <code>getMagnitude</code> on the generic class <code>Foo</code>. The
method returns an instance of the type substituted for the second type
parameter in an invocation of <code>Foo</code> If <code>Foo</code> is declared as
<code>Foo&lt;T,N extends Number&gt; {&#8230;&#8203;}</code> then this inter-type declaration is
equivalent to the declaration of a method <code>public N getMagnitude()</code>
within the body of <code>Foo</code>.</p>
</dd>
<dt class="hdlist1"><code>R Foo&lt;Q, R extends Number&gt;.getMagnitude() {&#8230;&#8203;}</code></dt>
<dd>
<p>Results in a compilation error since a bounds specification is not
allowed in this form of an inter-type declaration (the bounds are
determined from the declaration of the target type).</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>A parameterized type may not be the target of an inter-type declaration.
This is because there is only one type (the generic type) regardless of
how many different invocations (parameterizations) of that generic type
are made in a program. Therefore it does not make sense to try and
declare a member on behalf of (say) <code>Bar&lt;String&gt;</code>, you can only declare
members on the generic type <code>Bar&lt;T&gt;</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="declare-parents-java5">Declare Parents</h4>
<div class="paragraph">
<p>Both generic and parameterized types can be used as the parent type in a
<code>declare parents</code> statement (as long as the resulting type hierarchy
would be well-formed in accordance with Java&#8217;s sub-typing rules).
Generic types may also be used as the target type of a <code>declare parents</code>
statement.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>declare parents: Foo implements List&lt;String&gt;</code></dt>
<dd>
<p>The <code>Foo</code> type implements the <code>List&lt;String&gt;</code> interface. If <code>Foo</code>
already implements some other parameterization of the <code>List</code> interface
(for example, <code>List&lt;Integer&gt;</code> then a compilation error will result
since a type cannot implement multiple parameterizations of the same
generic interface type.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_declare_soft">Declare Soft</h4>
<div class="paragraph">
<p>It is an error to use a generic or parameterized type as the softened
exception type in a declare soft statement. Java 5 does not permit a
generic class to be a direct or indirect subtype of <code>Throwable</code> (JLS
8.1.2).</p>
</div>
</div>
<div class="sect3">
<h4 id="_generic_aspects">Generic Aspects</h4>
<div class="paragraph">
<p>AspectJ 5 allows an <em>abstract</em> aspect to be declared as a generic type.
Any concrete aspect extending a generic abstract aspect must extend a
parameterized version of the abstract aspect. Wildcards are not
permitted in this parameterization.</p>
</div>
<div class="paragraph">
<p>Given the aspect declaration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">abstract</span> aspect ParentChildRelationship&lt;P,C&gt; {
    <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>then</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>public aspect FilesInFolders extends ParentChildRelationship&lt;Folder,File&gt; {&#8230;&#8203;</code></dt>
<dd>
<p>declares a concrete sub-aspect, <code>FilesInFolders</code> which extends the
parameterized abstract aspect <code>ParentChildRelationship&lt;Folder,File&gt;</code>.</p>
</dd>
<dt class="hdlist1"><code>public aspect FilesInFolders extends ParentChildRelationship {&#8230;&#8203;</code></dt>
<dd>
<p>results in a compilation error since the <code>ParentChildRelationship</code>
aspect must be fully parameterized.</p>
</dd>
<dt class="hdlist1"><code>public aspect ThingsInFolders&lt;T&gt; extends ParentChildRelationship&lt;Folder,T&gt;</code></dt>
<dd>
<p>results in a compilation error since concrete aspects may not have
type parameters.</p>
</dd>
<dt class="hdlist1"><code>public abstract aspect ThingsInFolders&lt;T&gt; extends ParentChildRelationship&lt;Folder,T&gt;</code></dt>
<dd>
<p>declares a sub-aspect of <code>ParentChildRelationship</code> in which <code>Folder</code>
plays the role of parent (is bound to the type variable <code>P</code>).</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The type parameter variables from a generic aspect declaration may be
used in place of a type within any member of the aspect, <em>except for
within inter-type declarations</em>. For example, we can declare a
<code>ParentChildRelationship</code> aspect to manage the bi-directional
relationship between parent and child nodes as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">/**
 * a generic aspect, we've used descriptive role names for the type variables
 * (Parent and Child) but you could use anything of course
 */</span>
<span class="directive">public</span> <span class="directive">abstract</span> aspect ParentChildRelationship&lt;Parent,Child&gt; {

  <span class="comment">/** generic interface implemented by parents */</span>
  <span class="type">interface</span> <span class="class">ParentHasChildren</span>&lt;C <span class="directive">extends</span> ChildHasParent&gt;{
    <span class="predefined-type">List</span>&lt;C&gt; getChildren();
    <span class="type">void</span> addChild(C child);
    <span class="type">void</span> removeChild(C child);
  }

  <span class="comment">/** generic interface implemented by children */</span>
  <span class="type">interface</span> <span class="class">ChildHasParent</span>&lt;P <span class="directive">extends</span> ParentHasChildren&gt;{
    P getParent();
    <span class="type">void</span> setParent(P parent);
  }

  <span class="comment">/** ensure the parent type implements ParentHasChildren&lt;child type&gt; */</span>
  declare parents: Parent <span class="directive">implements</span> ParentHasChildren&lt;Child&gt;;

  <span class="comment">/** ensure the child type implements ChildHasParent&lt;parent type&gt; */</span>
  declare parents: Child <span class="directive">implements</span> ChildHasParent&lt;Parent&gt;;

  <span class="comment">// Inter-type declarations made on the *generic* interface types to provide</span>
  <span class="comment">// default implementations.</span>

  <span class="comment">/** list of children maintained by parent */</span>
  <span class="directive">private</span> <span class="predefined-type">List</span>&lt;C&gt; ParentHasChildren&lt;C&gt;.children = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;C&gt;();

  <span class="comment">/** reference to parent maintained by child */</span>
  <span class="directive">private</span> P ChildHasParent&lt;P&gt;.parent;

  <span class="comment">/** Default implementation of getChildren for the generic type ParentHasChildren */</span>
  <span class="directive">public</span> <span class="predefined-type">List</span>&lt;C&gt; ParentHasChildren&lt;C&gt;.getChildren() {
        <span class="keyword">return</span> <span class="predefined-type">Collections</span>.unmodifiableList(children);
  }

  <span class="comment">/** Default implementation of getParent for the generic type ChildHasParent */</span>
  <span class="directive">public</span> P ChildHasParent&lt;P&gt;.getParent() {
       <span class="keyword">return</span> parent;
  }

  <span class="comment">/**
    * Default implementation of addChild, ensures that parent of child is
    * also updated.
    */</span>
  <span class="directive">public</span> <span class="type">void</span> ParentHasChildren&lt;C&gt;.addChild(C child) {
       <span class="keyword">if</span> (child.parent != <span class="predefined-constant">null</span>) {
         child.parent.removeChild(child);
       }
       children.add(child);
       child.parent = <span class="local-variable">this</span>;
    }

   <span class="comment">/**
     * Default implementation of removeChild, ensures that parent of
     * child is also updated.
     */</span>
   <span class="directive">public</span> <span class="type">void</span> ParentHasChildren&lt;C&gt;.removeChild(C child) {
       <span class="keyword">if</span> (children.remove(child)) {
         child.parent = <span class="predefined-constant">null</span>;
       }
    }

    <span class="comment">/**
      * Default implementation of setParent for the generic type ChildHasParent.
      * Ensures that this child is added to the children of the parent too.
      */</span>
    <span class="directive">public</span> <span class="type">void</span> ChildHasParent&lt;P&gt;.setParent(P parent) {
       parent.addChild(<span class="local-variable">this</span>);
    }

    <span class="comment">/**
      * Matches at an addChild join point for the parent type P and child type C
      */</span>
    <span class="directive">public</span> pointcut addingChild(Parent p, Child c) :
      execution(* ParentHasChildren.addChild(ChildHasParent)) &amp;&amp; <span class="local-variable">this</span>(p) &amp;&amp; args(c);

    <span class="comment">/**
      * Matches at a removeChild join point for the parent type P and child type C
      */</span>
    <span class="directive">public</span> pointcut removingChild(Parent p, Child c) :
      execution(* ParentHasChildren.removeChild(ChildHasParent)) &amp;&amp; <span class="local-variable">this</span>(p) &amp;&amp; args(c);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example aspect captures the protocol for managing a bi-directional
parent-child relationship between any two types playing the role of
parent and child. In a compiler implementation managing an abstract
syntax tree (AST) in which AST nodes may contain other AST nodes we
could declare the concrete aspect:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> aspect ASTNodeContainment <span class="directive">extends</span> ParentChildRelationship&lt;ASTNode,ASTNode&gt; {
    before(ASTNode parent, ASTNode child) : addingChild(parent, child) {
      <span class="comment">// ...</span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As a result of this declaration, <code>ASTNode</code> gains members:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>List&lt;ASTNode&gt; children</code></p>
</li>
<li>
<p><code>ASTNode parent</code></p>
</li>
<li>
<p><code>List&lt;ASTNode&gt;getChildren()</code></p>
</li>
<li>
<p><code>ASTNode getParent()</code></p>
</li>
<li>
<p><code>void addChild(ASTNode child)</code></p>
</li>
<li>
<p><code>void removeChild(ASTNode child)</code></p>
</li>
<li>
<p><code>void setParent(ASTNode parent)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In a system managing orders, we could declare the concrete aspect:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> aspect OrderItemsInOrders <span class="directive">extends</span> ParentChildRelationship&lt;Order, OrderItem&gt; {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As a result of this declaration, <code>Order</code> gains members:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>List&lt;OrderItem&gt; children</code></p>
</li>
<li>
<p><code>List&lt;OrderItem&gt; getChildren()</code></p>
</li>
<li>
<p><code>void addChild(OrderItem child)</code></p>
</li>
<li>
<p><code>void removeChild(OrderItem child)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>and <code>OrderItem</code> gains members:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Order parent</code></p>
</li>
<li>
<p><code>Order getParent()</code></p>
</li>
<li>
<p><code>void setParent(Order parent)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A second example of an abstract aspect, this time for handling
exceptions in a uniform manner, is shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">abstract</span> aspect ExceptionHandling&lt;T <span class="directive">extends</span> <span class="predefined-type">Throwable</span>&gt; {

  <span class="comment">/**
   * method to be implemented by sub-aspects to handle thrown exceptions
   */</span>
  <span class="directive">protected</span> <span class="directive">abstract</span> <span class="type">void</span> onException(T anException);

  <span class="comment">/**
   * to be defined by sub-aspects to specify the scope of exception handling
   */</span>
  <span class="directive">protected</span> <span class="directive">abstract</span> pointcut inExceptionHandlingScope();

  <span class="comment">/**
   * soften T within the scope of the aspect
   */</span>
  declare soft: T : inExceptionHandlingScope();

  <span class="comment">/**
   * bind an exception thrown in scope and pass it to the handler
   */</span>
  after() throwing (T anException) : inExceptionHandlingScope() {
    onException(anException);
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice how the type variable <code>T extends Throwable</code> allows the components
of the aspect to be designed to work together in a type-safe manner. The
following concrete sub-aspect shows how the abstract aspect might be
extended to handle <code>IOExceptions</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> aspect IOExceptionHandling <span class="directive">extends</span> ExceptionHandling&lt;<span class="exception">IOException</span>&gt;{

  <span class="directive">protected</span> pointcut inExceptionHandlingScope() :
    call(* doIO*(..)) &amp;&amp; within(org.xyz..*);

  <span class="comment">/**
   * called whenever an IOException is thrown in scope.
   */</span>
  <span class="directive">protected</span> <span class="type">void</span> onException(<span class="exception">IOException</span> ex) {
    <span class="predefined-type">System</span>.err.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">handled exception: </span><span class="delimiter">&quot;</span></span> + ex.getMessage());
    <span class="keyword">throw</span> <span class="keyword">new</span> MyDomainException(ex);
  }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="autoboxing">Autoboxing and Unboxing</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="boxing-inJava5">Autoboxing and Unboxing in Java 5</h3>
<div class="paragraph">
<p>Java 5 (and hence AspectJ 1.5) supports automatic conversion of
primitive types (<code>int</code>, <code>float</code>, <code>double</code> etc.) to their object equivalents
(<code>Integer</code>, <code>Float</code>, <code>Double</code> etc.) in assignments and method and constructor
invocations. This conversion is know as autoboxing.</p>
</div>
<div class="paragraph">
<p>Java 5 also supports automatic unboxing, where wrapper types are
automatically converted into their primitive equivalents if needed for
assignments or method or constructor invocations.</p>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">int</span> i = <span class="integer">0</span>;
i = <span class="keyword">new</span> <span class="predefined-type">Integer</span>(<span class="integer">5</span>);  <span class="comment">// auto-unboxing</span>
<span class="predefined-type">Integer</span> i2 = <span class="integer">5</span>;      <span class="comment">// autoboxing</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="autoboxing-in-aspectj5">Autoboxing and Join Point matching in AspectJ 5</h3>
<div class="paragraph">
<p>Most of the pointcut designators match based on signatures, and hence
are unaffected by autoboxing. For example, a call to a method</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">void</span> foo(<span class="predefined-type">Integer</span> i);</code></pre>
</div>
</div>
<div class="paragraph">
<p>is <em>not</em> matched by a pointcut <code>call(void foo(int))</code> since the signature
declares a single <code>Integer</code> parameter, not an <code>int</code>.</p>
</div>
<div class="paragraph">
<p>The <code>args</code> pointcut designator is affected by autoboxing since it
matches based on the runtime type of the arguments. AspectJ 5 applies
autoboxing and unboxing in determining argument matching. In other
words, <code>args(Integer)</code> will match any join point at which there is a
single argument of type <code>Integer</code> or of type <code>int</code>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>args(Integer)</code> and <code>args(int)</code> are equivalent</p>
</li>
<li>
<p><code>args(Float)</code> and <code>args(float)</code> are equivalent</p>
</li>
<li>
<p><code>args(Double)</code> and <code>args(double)</code> are equivalent</p>
</li>
<li>
<p><code>args(Short)</code> and <code>args(short)</code> are equivalent</p>
</li>
<li>
<p><code>args(Byte)</code> and <code>args(byte)</code> are equivalent</p>
</li>
<li>
<p><code>args(Long)</code> and <code>args(long)</code> are equivalent</p>
</li>
<li>
<p><code>args(Boolean)</code> and <code>args(boolean)</code> are equivalent</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Autoboxing and unboxing are also applied when binding pointcut or advice
parameters, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">pointcut foo(<span class="type">int</span> i) : args(i);

before(<span class="predefined-type">Integer</span> i) : foo(i) {
  <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="autoboxing-and-method-dispatch">Inter-type method declarations and method dispatch</h3>
<div class="paragraph">
<p>Autoboxing, unboxing, and also varargs all affect the method dispatch
algorithm used in Java 5. In AspectJ 5, the target method of a call is
selected according to the following algorithm:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Attempt to locate a matching method or inter-type declared method
without considering autoboxing, unboxing, or vararg invocations.</p>
</li>
<li>
<p>If no match is found, try again considering autoboxing and unboxing.</p>
</li>
<li>
<p>Finally try again considering both autoboxing, unboxing, and varargs.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>One consequence is that a directly matching inter-type declared method
will take precedence over a method declared locally in the target class
but that only matches via autoboxing.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_covariance">Covariance</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="covariance-inJava5">Covariance in Java 5</h3>
<div class="paragraph">
<p>Java 5 (and hence AspectJ 5) allows you to narrow the return type in an
overriding method. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">A</span> {
  <span class="directive">public</span> A whoAreYou() {...}
}

<span class="type">class</span> <span class="class">B</span> <span class="directive">extends</span> A {
  <span class="comment">// override A.whoAreYou *and* narrow the return type.</span>
  <span class="directive">public</span> B whoAreYou() {...}
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="covariance-and-join-point-matching">Covariant methods and Join Point matching</h3>
<div class="paragraph">
<p>The join point matching rules for <code>call</code> and <code>execution</code> pointcut
designators are extended to match against covariant methods.</p>
</div>
<div class="paragraph">
<p>Given the classes <code>A</code> and <code>B</code> as defined in the previous section, and
the program fragment</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">A a = <span class="keyword">new</span> A();
B b = <span class="keyword">new</span> B();
a.whoAreYou();
b.whoAreYou();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The signatures for the call join point <code>a.whoAreYou()</code> are simply:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">A A.whoAreYou()</code></pre>
</div>
</div>
<div class="paragraph">
<p>The signatures for the call join point <code>b.whoAreYou()</code> are:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">A A.whoAreYou()
B B.whoAreYou()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Following the join point matching rules given in <a href="#jpsigs">Join Point Signatures</a>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>call(* whoAreYou())</code></dt>
<dd>
<p>Matches both calls, (since each call join point has at least one
matching signature).</p>
</dd>
<dt class="hdlist1"><code>call(* A.whoAreYou())</code></dt>
<dd>
<p>Matches both calls, (since each call join point has at least one
matching signature).</p>
</dd>
<dt class="hdlist1"><code>call(A whoAreYou())</code></dt>
<dd>
<p>Matches both calls, (since each call join point has at least one
matching signature).</p>
</dd>
<dt class="hdlist1"><code>call(A B.whoAreYou())</code></dt>
<dd>
<p>Does not match anything - neither of the call join points has a
signature matched by this pattern. A lint warning is given for the
call <code>a.whoAreYou()</code> ("does not match because declaring type is <code>A</code>, if
match required use <code>target(B)</code>").</p>
</dd>
<dt class="hdlist1"><code>call(A+ B.whoAreYou())</code></dt>
<dd>
<p>Matches the call to <code>b.whoAreYou()</code> since the signature pattern
matches the signature <code>B B.whoAreYou()</code>. A lint warning is given for
the call <code>a.whoAreYou()</code> ("does not match because declaring type is <code>A</code>,
if match required use <code>target(B)</code>").</p>
</dd>
<dt class="hdlist1"><code>call(B A.whoAreYou())</code></dt>
<dd>
<p>Does not match anything since neither join point has a signature
matched by this pattern.</p>
</dd>
<dt class="hdlist1"><code>call(B whoAreYou())</code></dt>
<dd>
<p>Matches the call to <code>b.whoAreYou()</code> only.</p>
</dd>
<dt class="hdlist1"><code>call(B B.whoAreYou())</code></dt>
<dd>
<p>Matches the call to <code>b.whoAreYou()</code> only.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The rule for signature matching at call and execution join points is
unchanged from AspectJ 1.2: a call or execution pointcut matches if the
signature pattern matches at least one of the signatures of the join
point, and if the modifiers of the method or constructor are matched by
any modifier pattern or annotation pattern that may be present.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_varargs">Varargs</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="varargs-inJava5">Variable-length Argument Lists in Java 5</h3>
<div class="paragraph">
<p>Java 5 (and hence AspectJ 5) allows you to specify methods that take a
variable number of arguments of a specified type. This is achieved using
an ellipsis (<code>&#8230;&#8203;</code>) in the method signature as shown:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">void</span> foo(<span class="type">int</span> i, <span class="predefined-type">String</span>... strings) {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A method or constructor may take at most one variable length argument,
and this must always be the last declared argument in the signature.</p>
</div>
<div class="sect3">
<h4 id="_calling_methods_and_constructors_with_variable_length_arguments">Calling Methods and Constructors with variable-length arguments</h4>
<div class="paragraph">
<p>A <em>varargs</em> method may be called with zero or more arguments in the
variable argument position. For example, given the definition of <code>foo</code>
above, the following calls are all legal:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">foo(<span class="integer">5</span>);
foo(<span class="integer">5</span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">One String</span><span class="delimiter">&quot;</span></span>);
foo(<span class="integer">7</span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">One String</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">Two Strings</span><span class="delimiter">&quot;</span></span>);
foo(<span class="integer">3</span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">One String</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">Two Strings</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">Three Strings</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>A <em>varargs</em> parameter is treated as an array within the defining member.
So in the body of <code>foo</code> we could write for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">void</span> foo(<span class="type">int</span> i, <span class="predefined-type">String</span>... strings) {
  <span class="predefined-type">String</span><span class="type">[]</span> someStrings = strings;
  <span class="comment">// rest of method body</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>One consequence of this treatment of a varargs parameter as an array is
that you can also call a varargs method with an array:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">foo(<span class="integer">7</span>,<span class="keyword">new</span> <span class="predefined-type">String</span><span class="type">[]</span> {<span class="string"><span class="delimiter">&quot;</span><span class="content">One String</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">Two Strings</span><span class="delimiter">&quot;</span></span>});</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="varargs-in-pcds">Using Variable-length arguments in advice and pointcut expressions</h3>
<div class="paragraph">
<p>AspectJ 5 allows variable-length arguments to be used for methods
declared within aspects, and for inter-type declared methods and
constructors, in accordance with the rules outlined in the previous
section.</p>
</div>
<div class="paragraph">
<p>AspectJ 5 also allows variable length arguments to be matched by
pointcut expressions and bound as formals in advice.</p>
</div>
<div class="sect3">
<h4 id="_matching_signatures_based_on_variable_length_argument_types">Matching signatures based on variable length argument types</h4>
<div class="paragraph">
<p>Recall from the definition of signature patterns given in the chapter on
annotations (<a href="#signaturePatterns">Signature Patterns</a>), that <code>MethodPattern</code> and
<code>ConstructorPattern</code> are extended to allow a <code>varargs</code> pattern in the
last argument position of a method or constructor signature.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">FormalsPattern :=
  '..' (',' FormalsPatternAfterDotDot)? |
  OptionalParensTypePattern (',' FormalsPattern)* |
  TypePattern '...'

FormalsPatternAfterDotDot :=
  OptionalParensTypePattern (',' FormalsPatternAfterDotDot)* |
  TypePattern '...'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Method and constructor patterns are used in the <code>call</code>, <code>execution</code>,
<code>initialization</code>, <code>preinitialization</code>, and <code>withincode</code> pointcut
designators. Some examples of usage follow:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>call(* org.xyz.<strong>.</strong>(int, String&#8230;&#8203;))</code></dt>
<dd>
<p>Matches a call join point for a call to a method defined in the
<code>org.xyz</code> package, taking an <code>int</code> and a <code>String</code> <em>vararg</em>.</p>
</dd>
<dt class="hdlist1"><code>execution(* org.xyz.<strong>.</strong>(Integer&#8230;&#8203;))</code></dt>
<dd>
<p>Matches an execution join point for the execution of a method defined
in the <code>org.xyz</code> package, taking an <code>Integer</code> <em>vararg</em>.</p>
</dd>
<dt class="hdlist1"><code>initialization(org.xyz.*.newFoo || Goo)&#8230;&#8203;</code></dt>
<dd>
<p>Matches the initialization join point for the construction of an
object in the <code>org.xyz</code> package via a constructor taking either a
variable number of <code>Foo</code> parameters or a variable number of <code>Goo</code>
parameters. (This example illustrating the use of a type pattern with
<code>&#8230;&#8203;</code>).</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>A variable argument parameter and an array parameter are treated as
distinct signature elements, so given the method definitions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">void</span> foo(<span class="predefined-type">String</span>...);
<span class="type">void</span> bar(<span class="predefined-type">String</span><span class="type">[]</span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The pointcut <code>execution(* <strong>.</strong>(String&#8230;&#8203;))</code> matches the execution join
point for <code>foo</code>, but not <code>bar</code>. The pointcut
<code>execution(* <strong>.</strong>(String[]))</code> matches the execution join point for <code>bar</code>
but not <code>foo</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_exposing_variable_length_arguments_as_context_in_pointcuts_and_advice">Exposing variable-length arguments as context in pointcuts and advice</h4>
<div class="paragraph">
<p>When a varargs parameter is used within the body of a method, it has an
array type, as discussed in the introduction to this section. We follow
the same convention when binding a varargs parameter via the <code>args</code>
pointcut designator. Given a method</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">void</span> foo(<span class="type">int</span> i, <span class="predefined-type">String</span>... strings) {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The call or execution join points for <code>foo</code> will be matched by the
pointcut <code>args(int,String[])</code>. It is not permitted to use the varargs
syntax within an args pointcut designator - so you <em>cannot</em> write
<code>args(int,String&#8230;&#8203;)</code>.</p>
</div>
<div class="paragraph">
<p>Binding of a varargs parameter in an advice statement is
straightforward:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">before(<span class="type">int</span> i, <span class="predefined-type">String</span><span class="type">[]</span> ss) : call(* foo(<span class="type">int</span>,<span class="predefined-type">String</span>...)) &amp;&amp; args(i,ss) {
  <span class="comment">// varargs String... argument is accessible in advice body through ss</span>
  <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since you cannot use the varargs syntax in the <code>args</code> pointcut
designator, you also cannot use the varargs syntax to declare advice
parameters.</p>
</div>
<div class="paragraph">
<p>Note: the proposal in this section does not allow you to distinguish
between a join point with a signature <code>(int, String&#8230;&#8203;)</code> and a join point
with a signature <code>(int, String[])</code> based <em>solely</em> on the use of the <code>args</code>
pointcut designator. If this distinction is required, <code>args</code> can always
be coupled with <code>call</code> or <code>execution</code>.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="enumeratedtypes">Enumerated Types</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="enums-in-java5">Enumerated Types in Java 5</h3>
<div class="paragraph">
<p>Java 5 (and hence AspectJ 5) provides explicit support for enumerated
types. In the simplest case, you can declare an enumerated type as
follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">enum</span> ProgrammingLanguages {
  COBOL, C, JAVA, ASPECTJ
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Enumerated types are just classes, and they can contain method and field
declarations, and may implement interfaces. Enums may only have private
constructors, and may not be extended.</p>
</div>
<div class="paragraph">
<p>Enumerated types in Java 5 all implicitly extend the type
<code>java.lang.Enum</code>. It is illegal to explicitly declare a subtype of this
class.</p>
</div>
</div>
<div class="sect2">
<h3 id="enums-in-aspectj5">Enumerated Types in AspectJ 5</h3>
<div class="paragraph">
<p>AspectJ 5 supports the declaration of enumerated types just as Java 5
does. Because of the special restrictions Java 5 places around
enumerated types, AspectJ makes the following additional restrictions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>You cannot use declare parents to change the super type of an enum.</p>
</li>
<li>
<p>You cannot use declare parents to declare <code>java.lang.Enum</code> as the parent
of any type.</p>
</li>
<li>
<p>You cannot make inter-type constructor declarations on an enum.</p>
</li>
<li>
<p>You cannot extend the set of values in an enum via any ITD-like
construct.</p>
</li>
<li>
<p>You cannot make inter-type method or field declarations on an enum.</p>
</li>
<li>
<p>You cannot use declare parents to make an enum type implement an
interface.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In theory, the last of these two items <em>could</em> be supported. However,
AspectJ 5 follows the simple rule that <em>an enum type cannot be the
target of an inter-type declaration or declare parents statement</em>. This
position may be relaxed in a future version of AspectJ.</p>
</div>
<div class="paragraph">
<p>If an enum is named explicitly as the target of a declare parents
statement, a compilation error will result. If an enumerated type is
matched by a non-explicit type pattern used in a declare parents
statement it will be ignored (and an XLint warning issued).</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="pertypewithin">The <code>pertypewithin</code> Aspect Instantiation Model</h2>
<div class="sectionbody">
<div class="paragraph">
<p>AspectJ 5 defines a new per-clause type for aspect instantiation:
<code>pertypewithin</code>. Unlike the other per-clauses, <code>pertypewithin</code> takes a
type pattern:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">PerTypeWithin := 'pertypewithin' '(' OptionalParensTypePattern ')'</code></pre>
</div>
</div>
<div class="paragraph">
<p>When an aspect is declared using the <code>pertypewithin</code> instantiation
model, one new aspect instance will be created for each type matched by
the associated type pattern.</p>
</div>
<div class="paragraph">
<p>Pertypewithin aspects have <code>aspectOf</code> and <code>hasAspect</code> methods with the
following signatures:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">/**
 * return true if this aspect has an instance associated with
 * the given type.
 */</span>
<span class="directive">public</span> <span class="directive">static</span> <span class="type">boolean</span> hasAspect(<span class="predefined-type">Class</span> clazz)

<span class="comment">/**
 * return the instance associated with the given type.
 * Throws NoAspectBoundException if there is no such
 * aspect.
 */</span>
<span class="directive">public</span> <span class="directive">static</span> P aspectOf(<span class="predefined-type">Class</span> clazz)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Where <code>P</code> is the type of the <code>pertypewithin</code> aspect.</p>
</div>
<div class="paragraph">
<p>In addition, <code>pertypewithin</code> aspects have a <code>getWithinTypeName</code> method
that can be called to return the package qualified name of the type for
which the aspect instance has been created.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">/**
 * return the package qualified name (eg. com.foo.MyClass) of the type
 * for which the aspect instance has been instantiated.
 */</span>
<span class="directive">public</span> <span class="predefined-type">String</span> getWithinTypeName()</code></pre>
</div>
</div>
<div class="paragraph">
<p>In common with the other per-clause instantiation models, the execution
of any advice declared within a <code>pertypewithin</code> aspect is conditional
upon an implicit pointcut condition. In this case, that any join point
be <code>within</code> the type that the executing aspect is an <code>aspectOf</code>. For
example, given the aspect definition</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">java.util</span>.*;

<span class="directive">public</span> aspect InstanceTracking pertypewithin(org.xyz..*) {

  <span class="comment">// use WeakHashMap for auto-garbage collection of keys</span>
  <span class="directive">private</span> <span class="predefined-type">Map</span>&lt;<span class="predefined-type">Object</span>,<span class="predefined-type">Boolean</span>&gt; instances = <span class="keyword">new</span> <span class="predefined-type">WeakHashMap</span>&lt;<span class="predefined-type">Object</span>,<span class="predefined-type">Boolean</span>&gt;();

  after(<span class="predefined-type">Object</span> o) returning() : execution(<span class="keyword">new</span>(..)) &amp;&amp; <span class="local-variable">this</span>(o) {
    instances.put(o,<span class="predefined-constant">true</span>);
  }

  <span class="directive">public</span> <span class="predefined-type">Set</span>&lt;?&gt; getInstances() {
    <span class="keyword">return</span> instances.keySet();
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then one aspect instance will be created for each type within
<code>org.xyz..<strong></code>. For each aspect instance, the after returning advice will
match only the execution of constructors within the matched
per-type-within type. The net result is that the aspect tracks all known
instances of each type within <code>org.xyz..</strong></code>. To get access to the
instances, a programmer can simply write
<code>InstanceTracking.aspectOf(org.xyz.SomeType.class).getInstances()</code>.</p>
</div>
<div class="paragraph">
<p>The <code>pertypewithin</code> aspect instantiation model should be used when the
implementation of a crosscutting concern requires that some state be
maintained for each type in a set of types. To maintain state for a
single type, it is easier to use a static inter-type declared field.
Examples of usage include instance tracking, profiling, and the
implementation of a common tracing idiom that uses one Logger per traced
class.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ataspectj">An Annotation Based Development Style</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="ataspectj-intro">Introduction</h3>
<div class="paragraph">
<p>In addition to the familiar AspectJ code-based style of aspect
declaration, AspectJ 5 also supports an annotation-based style of aspect
declaration. We informally call the set of annotations that support this
development style the "@AspectJ" annotations.</p>
</div>
<div class="paragraph">
<p>AspectJ 5 allows aspects and their members to be specified using either
the code style or the annotation style. Whichever style you use, the
AspectJ weaver ensures that your program has exactly the same semantics.
It is, to quote a famous advertising campaign, "a choice, not a
compromise". The two styles can be mixed within a single application,
and even within a single source file, though we doubt this latter mix
will be recommended in practice.</p>
</div>
<div class="paragraph">
<p>The use of the @AspectJ annotations means that there are large classes
of AspectJ applications that can be compiled by a regular Java 5
compiler, and subsequently woven by the AspectJ weaver (for example, as
an additional build stage, or as late as class load-time). In this
chapter we introduce the @AspectJ annotations and show how they can be
used to declare aspects and aspect members.</p>
</div>
</div>
<div class="sect2">
<h3 id="ataspectj-aspects">Aspect Declarations</h3>
<div class="paragraph">
<p>Aspect declarations are supported by the
<code>org.aspectj.lang.annotation.Aspect</code> annotation. The declaration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Aspect</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">Foo</span> {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Is equivalent to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> aspect Foo {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To specify an aspect an aspect instantiation model (the default is
singleton), provide the perclause as the <code>@Aspect</code> value. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Aspect</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">perthis(execution(* abc..*(..)))</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">Foo</span> {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>is equivalent to&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> aspect Foo perthis(execution(* abc..*(..))) {}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_limitations">Limitations</h4>
<div class="paragraph">
<p>Privileged aspects are not supported by the annotation style.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ataspectj-pcadvice">Pointcuts and Advice</h3>
<div class="paragraph">
<p>Pointcut and advice declarations can be made using the
<code>Pointcut, Before, After, AfterReturning, AfterThrowing,</code> and <code>Around</code>
annotations.</p>
</div>
<div class="sect3">
<h4 id="_pointcuts">Pointcuts</h4>
<div class="paragraph">
<p>Pointcuts are specified using the <code>org.aspectj.lang.annotation.Pointcut</code>
annotation on a method declaration. The method should have a <code>void</code>
return type. The parameters of the method correspond to the parameters
of the pointcut. The modifiers of the method correspond to the modifiers
of the pointcut.</p>
</div>
<div class="paragraph">
<p>As a general rule, the <code>@Pointcut</code> annotated method must have an empty
method body and must not have any <code>throws</code> clause. If formal are bound
(using
<code>args(), target(), this(), @args(), @target(), @this(), @annotation())</code>
in the pointcut, then they must appear in the method signature.</p>
</div>
<div class="paragraph">
<p>The <code>if()</code> pointcut is treated specially and is discussed in a later
section.</p>
</div>
<div class="paragraph">
<p>Here is a simple example of a pointcut declaration in both code and
@AspectJ styles:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Pointcut</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">call(* *.*(..))</span><span class="delimiter">&quot;</span></span>)
<span class="type">void</span> anyCall() {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>is equivalent to&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">pointcut anyCall() : call(* *.*(..));</code></pre>
</div>
</div>
<div class="paragraph">
<p>When binding arguments, simply declare the arguments as normal in the
annotated method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Pointcut</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">call(* *.*(int)) &amp;&amp; args(i) &amp;&amp; target(callee)</span><span class="delimiter">&quot;</span></span>)
<span class="type">void</span> anyCall(<span class="type">int</span> i, Foo callee) {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>is equivalent to&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">pointcut anyCall(<span class="type">int</span> i, Foo callee) : call(* *.*(<span class="type">int</span>)) &amp;&amp; args(i) &amp;&amp; target(callee);</code></pre>
</div>
</div>
<div class="paragraph">
<p>An example with modifiers (Remember that Java 5 annotations are not
inherited, so the <code>@Pointcut</code> annotation must be present on the
extending aspect&#8217;s pointcut declaration too):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Pointcut</span>(<span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>)
<span class="directive">protected</span> <span class="directive">abstract</span> <span class="type">void</span> anyCall();</code></pre>
</div>
</div>
<div class="paragraph">
<p>is equivalent to&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">protected</span> <span class="directive">abstract</span> pointcut anyCall();</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_type_references_inside_aspectj_annotations">Type references inside @AspectJ annotations</h5>
<div class="paragraph">
<p>Using the code style, types referenced in pointcut expressions are
resolved with respect to the imported types in the compilation unit.
When using the annotation style, types referenced in pointcut
expressions are resolved in the absence of any imports and so have to be
fully qualified if they are not by default visible to the declaring type
(outside of the declaring package and <code>java.lang</code> ). This does not apply
to type patterns with wildcards, which are always resolved in a global
scope.</p>
</div>
<div class="paragraph">
<p>Consider the following compilation unit:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.aspectprogrammer.examples</span>;

<span class="keyword">import</span> <span class="include">java.util.List</span>;

<span class="directive">public</span> aspect Foo {
  pointcut listOperation() : call(* <span class="predefined-type">List</span>.*(..));
  pointcut anyUtilityCall() : call(* java.util..*(..));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using the annotation style this would be written as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.aspectprogrammer.examples</span>;

<span class="keyword">import</span> <span class="include">java.util.List</span>; <span class="comment">// redundant but harmless</span>

<span class="annotation">@Aspect</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">Foo</span> {
  <span class="annotation">@Pointcut</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">call(* java.util.List.*(..))</span><span class="delimiter">&quot;</span></span>) <span class="comment">// must qualify</span>
  <span class="type">void</span> listOperation() {}

  <span class="annotation">@Pointcut</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">call(* java.util..*(..))</span><span class="delimiter">&quot;</span></span>)
  <span class="type">void</span> anyUtilityCall() {}
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_if_pointcut_expressions">if() pointcut expressions</h5>
<div class="paragraph">
<p>In code style, it is possible to use the <code>if(&#8230;&#8203;)</code> poincut to define a
conditional pointcut expression which will be evaluated at runtime for
each candidate join point. The <code>if(&#8230;&#8203;)</code> body can be any valid Java
boolean expression, and can use any exposed formal, as well as the join
point forms
<code>thisJoinPoint, thisJoinPointStaticPart and thisJoinPointEnclosingStaticPart</code>
.</p>
</div>
<div class="paragraph">
<p>When using the annotation style, it is not possible to write a full Java
expression within the annotation value so the syntax differs slightly,
whilst providing the very same semantics and runtime behaviour. An
<code>if()</code> pointcut expression can be declared in an <code>@Pointcut</code> , but must
have either an empty body (<code>if()</code>, or be one of the expression forms
<code>if(true)</code> or <code>if(false)</code> . The annotated method must be public, static,
and return a boolean. The body of the method contains the condition to
be evaluated. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Pointcut</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">call(* *.*(int)) &amp;&amp; args(i) &amp;&amp; if()</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="directive">static</span> <span class="type">boolean</span> someCallWithIfTest(<span class="type">int</span> i) {
    <span class="keyword">return</span> i &gt; <span class="integer">0</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>is equivalent to&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">pointcut someCallWithIfTest(<span class="type">int</span> i) :
  call(* *.*(<span class="type">int</span>)) &amp;&amp; args(i) &amp;&amp; <span class="keyword">if</span>(i &gt; <span class="integer">0</span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>and the following is also a valid form:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">static</span> <span class="type">int</span> COUNT = <span class="integer">0</span>;

<span class="annotation">@Pointcut</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">call(* *.*(int)) &amp;&amp; args(i) &amp;&amp; if()</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="directive">static</span> <span class="type">boolean</span> someCallWithIfTest(<span class="type">int</span> i, JoinPoint jp, JoinPoint.EnclosingStaticPart esjp) {
   <span class="comment">// any legal Java expression...</span>
   <span class="keyword">return</span> i &gt; <span class="integer">0</span>
          &amp;&amp; jp.getSignature().getName.startsWith(<span class="string"><span class="delimiter">&quot;</span><span class="content">doo</span><span class="delimiter">&quot;</span></span>)
          &amp;&amp; esjp.getSignature().getName().startsWith(<span class="string"><span class="delimiter">&quot;</span><span class="content">test</span><span class="delimiter">&quot;</span></span>)
          &amp;&amp; COUNT++ &lt; <span class="integer">10</span>;
}

<span class="annotation">@Before</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">someCallWithIfTest(anInt, jp, enc)</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">void</span> beforeAdviceWithRuntimeTest(<span class="type">int</span> anInt, JoinPoint jp, JoinPoint.EnclosingStaticPart enc) {
   <span class="comment">//...</span>
}

<span class="comment">// Note that the following is NOT valid</span>
<span class="comment">/*
@Before(&quot;call(* *.*(int)) &amp;&amp; args(i) &amp;&amp; if()&quot;)
public void advice(int i) {
   // so you were writing an advice or an if body ?
}
*/</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>It is thus possible with the annotation style to use the <code>if()</code> pointcut
only within an <code>@Pointcut</code> expression. The <code>if()</code> must not contain any
body. The annotated <code>@Pointcut</code> method must then be of the form
<code>public static boolean</code> and can use formal bindings as usual. Extra
<em>implicit</em> arguments of type JoinPoint, JoinPoint.StaticPart and
JoinPoint.EnclosingStaticPart can also be used (this is not permitted
for regular annotated pointcuts not using the <code>if()</code> form).</p>
</div>
<div class="paragraph">
<p>The special forms <code>if(true)</code> and <code>if(false)</code> can be used in a more
general way and don&#8217;t imply that the pointcut method must have a body.
You can thus write <code>@Before("somePoincut() &amp;&amp; if(false)")</code> .</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_advice">Advice</h4>
<div class="paragraph">
<p>In this section we first discuss the use of annotations for simple
advice declarations. Then we show how <code>thisJoinPoint</code> and its siblings
are handled in the body of advice and discuss the treatment of <code>proceed</code>
in around advice.</p>
</div>
<div class="paragraph">
<p>Using the annotation style, an advice declaration is written as a
regular Java method with one of the <code>Before, After, AfterReturning,
                    AfterThrowing,</code> or <code>Around</code> annotations. Except in
the case of around advice, the method should return void. The method
should be declared public.</p>
</div>
<div class="paragraph">
<p>A method that has an advice annotation is treated exactly as an advice
declaration by AspectJ&#8217;s weaver. This includes the join points that
arise when the advice is executed (an adviceexecution join point, not a
method execution join point).</p>
</div>
<div class="paragraph">
<p>The following example shows a simple before advice declaration in both
styles:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Before</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">call(* org.aspectprogrammer..*(..)) &amp;&amp; this(Foo)</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">void</span> callFromFoo() {
  <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Call from Foo</span><span class="delimiter">&quot;</span></span>);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>is equivalent to&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">before() : call(* org.aspectprogrammer..*(..)) &amp;&amp; <span class="local-variable">this</span>(Foo) {
  <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Call from Foo</span><span class="delimiter">&quot;</span></span>);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the advice body needs to know which particular <code>Foo</code> instance is
making the call, just add a parameter to the advice declaration.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">before(Foo foo) : call(* org.aspectprogrammer..*(..)) &amp;&amp; <span class="local-variable">this</span>(foo) {
  <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Call from Foo: </span><span class="delimiter">&quot;</span></span> + foo);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>can be written as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Before</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">call(* org.aspectprogrammer..*(..)) &amp;&amp; this(foo)</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">void</span> callFromFoo(Foo foo) {
  <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Call from Foo: </span><span class="delimiter">&quot;</span></span> + foo);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the advice body needs access to <code>thisJoinPoint</code> ,
<code>thisJoinPointStaticPart</code> , <code>thisEnclosingJoinPointStaticPart</code> then
these need to be declared as additional method parameters when using the
annotation style.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Before</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">call(* org.aspectprogrammer..*(..)) &amp;&amp; this(foo)</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">void</span> callFromFoo(JoinPoint thisJoinPoint, Foo foo) {
  <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Call from Foo: </span><span class="delimiter">&quot;</span></span> + foo + <span class="string"><span class="delimiter">&quot;</span><span class="content"> at </span><span class="delimiter">&quot;</span></span> + thisJoinPoint);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>is equivalent to&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">before(Foo foo) : call(* org.aspectprogrammer..*(..)) &amp;&amp; <span class="local-variable">this</span>(foo) {
  <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Call from Foo: </span><span class="delimiter">&quot;</span></span> + foo + <span class="string"><span class="delimiter">&quot;</span><span class="content"> at </span><span class="delimiter">&quot;</span></span> + thisJoinPoint);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Advice that needs all three variables would be declared:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Before</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">call(* org.aspectprogrammer..*(..)) &amp;&amp; this(Foo)</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">void</span> callFromFoo(
  JoinPoint thisJoinPoint,
  JoinPoint.StaticPart thisJoinPointStaticPart,
  JoinPoint.EnclosingStaticPart thisEnclosingJoinPointStaticPart
) {
    <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>JoinPoint.EnclosingStaticPart</code> is a new (empty) sub-interface of
<code>JoinPoint.StaticPart</code> which allows the AspectJ weaver to distinguish
based on type which of <code>thisJoinPointStaticPart</code> and
<code>thisEnclosingJoinPointStaticPart</code> should be passed in a given parameter
position.</p>
</div>
<div class="paragraph">
<p><code>After</code> advice declarations take exactly the same form as <code>Before</code> , as
do the forms of <code>AfterReturning</code> and <code>AfterThrowing</code> that do not expose
the return type or thrown exception respectively.</p>
</div>
<div class="paragraph">
<p>To expose a return value with after returning advice simply declare the
returning parameter as a parameter in the method body and bind it with
the "returning" attribute:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@AfterReturning</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">criticalOperation()</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">void</span> phew() {
  <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">phew</span><span class="delimiter">&quot;</span></span>);
}

<span class="annotation">@AfterReturning</span>(pointcut=<span class="string"><span class="delimiter">&quot;</span><span class="content">call(Foo+.new(..))</span><span class="delimiter">&quot;</span></span>,returning=<span class="string"><span class="delimiter">&quot;</span><span class="content">f</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">void</span> itsAFoo(Foo f) {
  <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">It's a Foo: </span><span class="delimiter">&quot;</span></span> + f);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>is equivalent to&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">after() returning : criticalOperation() {
  <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">phew</span><span class="delimiter">&quot;</span></span>);
}

after() returning(Foo f) : call(Foo+.new(..)) {
  <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">It's a Foo: </span><span class="delimiter">&quot;</span></span> + f);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>(Note the use of the <code>pointcut=</code> prefix in front of the pointcut
expression in the returning case).</p>
</div>
<div class="paragraph">
<p>After throwing advice works in a similar fashion, using the <code>throwing</code>
attribute when needing to expose a thrown exception.</p>
</div>
<div class="paragraph">
<p>For around advice, we have to tackle the problem of <code>proceed</code> . One of
the design goals for the annotation style is that a large class of
AspectJ applications should be compilable with a standard Java 5
compiler. A straight call to <code>proceed</code> inside a method body:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Around</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">call(* org.aspectprogrammer..*(..))</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="predefined-type">Object</span> doNothing() {
  <span class="keyword">return</span> proceed(); <span class="comment">// CE on this line</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>will result in a "No such method" compilation error. For this reason
AspectJ 5 defines a new sub-interface of <code>JoinPoint</code> ,
<code>ProceedingJoinPoint</code> .</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">ProceedingJoinPoint</span> <span class="directive">extends</span> JoinPoint {
  <span class="directive">public</span> <span class="predefined-type">Object</span> proceed(<span class="predefined-type">Object</span><span class="type">[]</span> args);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The around advice given above can now be written as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Around</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">call(* org.aspectprogrammer..*(..))</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="predefined-type">Object</span> doNothing(ProceedingJoinPoint thisJoinPoint) {
  <span class="keyword">return</span> thisJoinPoint.proceed();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here&#8217;s an example that uses parameters for the proceed call:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Aspect</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">ProceedAspect</span> {

  <span class="annotation">@Pointcut</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">call(* setAge(..)) &amp;&amp; args(i)</span><span class="delimiter">&quot;</span></span>)
  <span class="type">void</span> setAge(<span class="type">int</span> i) {}

  <span class="annotation">@Around</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">setAge(i)</span><span class="delimiter">&quot;</span></span>)
  <span class="directive">public</span> <span class="predefined-type">Object</span> twiceAsOld(ProceedingJoinPoint thisJoinPoint, <span class="type">int</span> i) {
    <span class="keyword">return</span> thisJoinPoint.proceed(<span class="keyword">new</span> <span class="predefined-type">Object</span><span class="type">[]</span>{i*<span class="integer">2</span>}); <span class="comment">//using Java 5 autoboxing</span>
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>is equivalent to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> aspect ProceedAspect {
  pointcut setAge(<span class="type">int</span> i): call(* setAge(..)) &amp;&amp; args(i);

  <span class="predefined-type">Object</span> around(<span class="type">int</span> i): setAge(i) {
    <span class="keyword">return</span> proceed(i*<span class="integer">2</span>);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the ProceedingJoinPoint does not need to be passed to the
<code>proceed(..)</code> arguments.</p>
</div>
<div class="paragraph">
<p>In code style, the proceed method has the same signature as the advice,
any reordering of actual arguments to the joinpoint that is done in the
advice signature must be respected. Annotation style is different. The
<code>proceed(..)</code> call takes, in this order:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If <code>this()</code> was used in the pointcut for binding, it must be passed first in
<code>proceed(..)</code>.</p>
</li>
<li>
<p>If <code>target()</code> was used in the pointcut for binding, it must be passed next in
<code>proceed(..)</code> - it will be the first argument to <code>proceed(..)</code> if <code>this()</code>
was not used for binding.</p>
</li>
<li>
<p>Finally come all the arguments expected at the join point, in the order they
are supplied at the join point. Effectively the advice signature is ignored -
it doesn&#8217;t matter if a subset of arguments were bound or the ordering was
changed in the advice signature, the <code>proceed(..)</code> calls takes all of them
in the right order for the join point.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Since <code>proceed(..)</code> in this case takes an <code>Object</code> array, AspectJ cannot do
as much compile time checking as it can for code style. If the rules
above aren&#8217;t obeyed, then it will unfortunately manifest as a runtime
error.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ataspectj-itds">Inter-type Declarations</h3>
<div class="paragraph">
<p>Inter-type declarations are challenging to support using an annotation
style. For code style aspects compiled with the <em>ajc</em> compiler, the entire
type system can be made aware of inter-type declarations (new
supertypes, new methods, new fields) and the completeness and
correctness of it can be guaranteed. Achieving this with an annotation
style is hard because the source code may simply be compiled with javac
where the type system cannot be influenced and what is compiled must be
'pure Java'.</p>
</div>
<div class="paragraph">
<p>AspectJ 1.5.0 introduced <code>@DeclareParents</code>, an attempt to offer something
like that which is achievable with code style declare parents and the
other intertype declarations (fields, methods, constructors). However,
it has proved too challenging to get close to the expressiveness and
capabilities of code style in this area and effectively <code>@DeclareParents</code>
is offering just a mixin strategy. The definition of mixin <code>I</code> am using
here is that when some <code>interface I</code> is mixed into some target type <code>T</code> then
this means that all the methods from <code>I</code> are created in <code>T</code> and their
implementations are simple forwarding methods that call a delegate which
that provides an implementation of <code>I</code>.</p>
</div>
<div class="paragraph">
<p>The next section covers <code>@DeclareParents</code> but AspectJ 1.6.4 introduces
<code>@DeclareMixin</code> - an improved approach to defining a mixin and the choice
of a different name for the annotation will hopefully alleviate some of
the confusion about why <code>@DeclareParents</code> just doesn&#8217;t offer the same
semantics as the code style variant. Offering <code>@DeclareMixin</code> also gives
code style developers a new tool for a simple mixin whereas previously
they would have avoided <code>@DeclareParents</code>, thinking what it could only do
was already achievable with code style syntax.</p>
</div>
<div class="paragraph">
<p>The <code>defaultImpl</code> attribute of <code>@DeclareParents</code> may become deprecated if
<code>@DeclareMixin</code> proves popular, leaving <code>@DeclareParents</code> purely as a way to
introduce a marker interface.</p>
</div>
<div class="sect3">
<h4 id="atDeclareParents">@DeclareParents</h4>
<div class="paragraph">
<p>Consider the following aspect:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> aspect MoodIndicator {

   <span class="directive">public</span> <span class="type">interface</span> <span class="class">Moody</span> {};

   <span class="directive">private</span> Mood Moody.mood = Mood.HAPPY;

   <span class="directive">public</span> Mood Moody.getMood() {
     <span class="keyword">return</span> mood;
   }

   declare parents : org.xyz..* <span class="directive">implements</span> Moody;

   before(Moody m) : execution(* *.*(..)) &amp;&amp; <span class="local-variable">this</span>(m) {
      <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">I'm feeling </span><span class="delimiter">&quot;</span></span> + m.getMood());
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This declares an interface <code>Moody</code> , and then makes two inter-type
declarations on the interface - a field that is private to the aspect,
and a method that returns the mood. Within the body of the inter-type
declared method <code>getMoody</code> , the type of <code>this</code> is <code>Moody</code> (the target
type of the inter-type declaration).</p>
</div>
<div class="paragraph">
<p>Using the annotation style this aspect can be written:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Aspect</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">MoodIndicator</span> {

   <span class="comment">// this interface can be outside of the aspect</span>
   <span class="directive">public</span> <span class="type">interface</span> <span class="class">Moody</span> {
     Mood getMood();
   };

   <span class="comment">// this implementation can be outside of the aspect</span>
   <span class="directive">public</span> <span class="directive">static</span> <span class="type">class</span> <span class="class">MoodyImpl</span> <span class="directive">implements</span> Moody {
      <span class="directive">private</span> Mood mood = Mood.HAPPY;

      <span class="directive">public</span> Mood getMood() {
        <span class="keyword">return</span> mood;
      }
   }

   <span class="comment">// the field type must be the introduced interface. It can't be a class.</span>
   <span class="annotation">@DeclareParents</span>(value=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.xzy..*</span><span class="delimiter">&quot;</span></span>,defaultImpl=MoodyImpl.class)
   <span class="directive">private</span> Moody implementedInterface;

   <span class="annotation">@Before</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">execution(* *.*(..)) &amp;&amp; this(m)</span><span class="delimiter">&quot;</span></span>)
   <span class="type">void</span> feelingMoody(Moody m) {
      <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">I'm feeling </span><span class="delimiter">&quot;</span></span> + m.getMood());
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is very similar to the mixin mechanism supported by AspectWerkz.
The effect of the <code>@DeclareParents</code> annotation is equivalent to a
declare parents statement that all types matching the type pattern
implement the given interface (in this case <code>Moody</code>). Each method declared
in the interface is treated as an inter-type declaration. Note how this
scheme operates within the constraints of Java type checking and ensures
that <code>this</code> has access to the exact same set of members as in the code
style example.</p>
</div>
<div class="paragraph">
<p>Note that it is illegal to use the <code>@DeclareParents</code> annotation on an
aspect' field of a non-interface type. The interface type is the
inter-type declaration contract that dictates which methods are declared
on the target type.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// this type will be affected by the inter-type declaration as the type pattern matches</span>
<span class="keyword">package</span> <span class="namespace">org.xyz</span>;
<span class="directive">public</span> <span class="type">class</span> <span class="class">MoodTest</span> {

   <span class="directive">public</span> <span class="type">void</span> test() {
       <span class="comment">// see here the cast to the introduced interface (required)</span>
       Mood mood = ((Moody)<span class="local-variable">this</span>).getMood();
       ...
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>@DeclareParents</code> annotation can also be used without specifying a
<code>defaultImpl</code> value (for example, <code>@DeclareParents("org.xyz..*")</code>). This
is equivalent to a <code>declare parents &#8230;&#8203; implements</code> clause, and does
<em>not</em> make any inter-type declarations for default implementation of the
interface methods.</p>
</div>
<div class="paragraph">
<p>Consider the following aspect:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> aspect SerializableMarker {
   declare parents : org.xyz..* <span class="directive">implements</span> <span class="predefined-type">Serializable</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using the annotation style this aspect can be written:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Aspect</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">SerializableMarker</span> {
   <span class="annotation">@DeclareParents</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">org.xyz..*</span><span class="delimiter">&quot;</span></span>)
   <span class="predefined-type">Serializable</span> implementedInterface;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the interface defines one or more operations, and these are not
implemented by the target type, an error will be issued during weaving.</p>
</div>
</div>
<div class="sect3">
<h4 id="atDeclareMixin">@DeclareMixin</h4>
<div class="paragraph">
<p>Consider the following aspect:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> aspect MoodIndicator {

   <span class="directive">public</span> <span class="type">interface</span> <span class="class">Moody</span> {};

   <span class="directive">private</span> Mood Moody.mood = Mood.HAPPY;

   <span class="directive">public</span> Mood Moody.getMood() {
     <span class="keyword">return</span> mood;
   }

   declare parents : org.xyz..* <span class="directive">implements</span> Moody;

   before(Moody m) : execution(* *.*(..)) &amp;&amp; <span class="local-variable">this</span>(m) {
      <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">I'm feeling </span><span class="delimiter">&quot;</span></span> + m.getMood());
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This declares an interface <code>Moody</code>, and then makes two inter-type
declarations on the interface - a field that is private to the aspect,
and a method that returns the mood. Within the body of the inter-type
declared method <code>getMoody</code>, the type of <code>this</code> is <code>Moody</code> (the target
type of the inter-type declaration).</p>
</div>
<div class="paragraph">
<p>Using the annotation style, this aspect can be written:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Aspect</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">MoodIndicator</span> {

   <span class="comment">// this interface can be outside of the aspect</span>
   <span class="directive">public</span> <span class="type">interface</span> <span class="class">Moody</span> {
     Mood getMood();
   };

   <span class="comment">// this implementation can be outside of the aspect</span>
   <span class="directive">public</span> <span class="directive">static</span> <span class="type">class</span> <span class="class">MoodyImpl</span> <span class="directive">implements</span> Moody {
      <span class="directive">private</span> Mood mood = Mood.HAPPY;

      <span class="directive">public</span> Mood getMood() {
        <span class="keyword">return</span> mood;
      }
   }

   <span class="comment">// The DeclareMixin annotation is attached to a factory method that can return instances of the delegate</span>
   <span class="comment">// which offers an implementation of the mixin interface.  The interface that is mixed in is the</span>
   <span class="comment">// return type of the method.</span>
   <span class="annotation">@DeclareMixin</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">org.xyz..*</span><span class="delimiter">&quot;</span></span>)
   <span class="directive">public</span> <span class="directive">static</span> Moody createMoodyImplementation() {
     <span class="keyword">return</span> <span class="keyword">new</span> MoodyImpl();
   }

   <span class="annotation">@Before</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">execution(* *.*(..)) &amp;&amp; this(m)</span><span class="delimiter">&quot;</span></span>)
   <span class="type">void</span> feelingMoody(Moody m) {
      <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">I'm feeling </span><span class="delimiter">&quot;</span></span> + m.getMood());
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Basically, the <code>@DeclareMixin</code> annotation is attached to a factory
method. The factory method specifies the interface to mixin as its
return type, and calling the method should create an instance of a
delegate that implements the interface. This is the interface which will
be delegated to from any target matching the specified type pattern.</p>
</div>
<div class="paragraph">
<p>Exploiting this syntax requires the user to obey the rules of pure Java.
So references to any targeted type as if it were affected by the Mixin
must be made through a cast, like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// this type will be affected by the inter-type declaration as the type pattern matches</span>
<span class="keyword">package</span> <span class="namespace">org.xyz</span>;
<span class="directive">public</span> <span class="type">class</span> <span class="class">MoodTest</span> {

   <span class="directive">public</span> <span class="type">void</span> test() {
       <span class="comment">// see here the cast to the introduced interface (required)</span>
       Mood mood = ((Moody)<span class="local-variable">this</span>).getMood();
       ...
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sometimes the delegate instance may want to perform differently
depending upon the type/instance for which it is behaving as a delegate.
To support this it is possible for the factory method to specify a
parameter. If it does, then when the factory method is called the
parameter will be the object instance for which a delegate should be
created:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Aspect</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">Foo</span> {

  <span class="annotation">@DeclareMixin</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">org.xyz..*</span><span class="delimiter">&quot;</span></span>)
  <span class="directive">public</span> <span class="directive">static</span> SomeInterface createDelegate(<span class="predefined-type">Object</span> instance) {
    <span class="keyword">return</span> <span class="keyword">new</span> SomeImplementation(instance);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is also possible to make the factory method non-static - and in this
case it can then exploit the local state in the surrounding aspect
instance, but this is only supported for singleton aspects:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Aspect</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">Foo</span> {
  <span class="directive">public</span> <span class="type">int</span> maxLimit=<span class="integer">35</span>;

  <span class="annotation">@DeclareMixin</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">org.xyz..*</span><span class="delimiter">&quot;</span></span>)
  <span class="directive">public</span> SomeInterface createDelegate(<span class="predefined-type">Object</span> instance) {
    <span class="keyword">return</span> <span class="keyword">new</span> SomeImplementation(instance,maxLimit);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Although the interface type is usually determined purely from the return
type of the factory method, it can be specified in the annotation if
necessary. In this example the return type of the method extends
multiple other interfaces and only a couple of them (<code>I</code> and <code>J</code>) should be
mixed into any matching targets:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// interfaces is an array of interface classes that should be mixed in</span>
<span class="annotation">@DeclareMixin</span>(value=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.xyz..*</span><span class="delimiter">&quot;</span></span>,interfaces={I.class,J.class})
<span class="directive">public</span> <span class="directive">static</span> InterfaceExtendingLotsOfInterfaces createMoodyImplementation() {
  <span class="keyword">return</span> <span class="keyword">new</span> MoodyImpl();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are clearly similarities between <code>@DeclareMixin</code> and
<code>@DeclareParents</code> but <code>@DeclareMixin</code> is not pretending to offer more
than a simple mixin strategy. The flexibility in being able to provide
the factory method instead of requiring a no-arg constructor for the
implementation also enables delegate instances to make decisions based
upon the type for which they are the delegate.</p>
</div>
<div class="paragraph">
<p>Any annotations defined on the interface methods are also put upon the
delegate forwarding methods created in the matched target type.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ataspectj-declare">Declare statements</h3>
<div class="paragraph">
<p>The previous section on inter-type declarations covered the case of
<code>declare parents &#8230;&#8203;</code> implements. The 1.5.0 release of AspectJ 5 does not
support annotation style declarations for <code>declare parents &#8230;&#8203; extends</code>
and <code>declare soft</code> (programs with these declarations would not in general
be compilable by a regular Java 5 compiler, reducing the priority of
their implementation). These may be supported in a future release.</p>
</div>
<div class="paragraph">
<p>Declare annotation is also not supported in the 1.5.0 release of AspectJ 5.</p>
</div>
<div class="paragraph">
<p>Declare precedence <em>is</em> supported. For declare precedence, use the
<code>@DeclarePrecedence</code> annotation as in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> aspect SystemArchitecture {
  declare precedence : <span class="predefined-type">Security</span>*, TransactionSupport, Persistence;
  <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>can be written as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Aspect</span>
<span class="annotation">@DeclarePrecedence</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Security*,org.xyz.TransactionSupport,org.xyz.Persistence</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">SystemArchitecture</span> {
  <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We also support annotation style declarations for declare warning and
declare error - any corresponding warnings and errors will be emitted at
weave time, not when the aspects containing the declarations are
compiled. (This is the same behaviour as when using declare warning or
error with the code style). Declare warning and error declarations are
made by annotating a string constant whose value is the message to be
issued.</p>
</div>
<div class="paragraph">
<p>Note that the String must be a literal and not the result of the
invocation of a static method for example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">declare warning : call(* javax.sql..*(..)) &amp;&amp; !within(org.xyz.daos..*)
                : <span class="string"><span class="delimiter">&quot;</span><span class="content">Only DAOs should be calling JDBC.</span><span class="delimiter">&quot;</span></span>;

declare error : execution(* IFoo+.*(..)) &amp;&amp; !within(org.foo..*)
              : <span class="string"><span class="delimiter">&quot;</span><span class="content">Only foo types can implement IFoo</span><span class="delimiter">&quot;</span></span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>can be written as&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@DeclareWarning</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">call(* javax.sql..*(..)) &amp;&amp; !within(org.xyz.daos..*)</span><span class="delimiter">&quot;</span></span>)
<span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">String</span> aMessage = <span class="string"><span class="delimiter">&quot;</span><span class="content">Only DAOs should be calling JDBC.</span><span class="delimiter">&quot;</span></span>;

<span class="annotation">@DeclareError</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">execution(* IFoo+.*(..)) &amp;&amp; !within(org.foo..*)</span><span class="delimiter">&quot;</span></span>)
<span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">String</span> badIFooImplementors = <span class="string"><span class="delimiter">&quot;</span><span class="content">Only foo types can implement IFoo</span><span class="delimiter">&quot;</span></span>;

<span class="comment">// the following is not valid since the message is not a String literal</span>
<span class="annotation">@DeclareError</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">execution(* IFoo+.*(..)) &amp;&amp; !within(org.foo..*)</span><span class="delimiter">&quot;</span></span>)
<span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">String</span> badIFooImplementorsCorrupted = getMessage();
<span class="directive">static</span> <span class="predefined-type">String</span> getMessage() {
  <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Only foo types can implement IFoo </span><span class="delimiter">&quot;</span></span> + <span class="predefined-type">System</span>.currentTimeMillis();
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ataspectj-aspectof"><code>aspectOf()</code> and <code>hasAspect()</code> methods</h3>
<div class="paragraph">
<p>A central part of AspectJ&#8217;s programming model is that aspects written
using the code style and compiled using ajc support <code>aspectOf</code> and
<code>hasAspect</code> static methods. When developing an aspect using the
annotation style and compiling using a regular Java 5 compiler, these
methods will not be visible to the compiler and will result in a
compilation error if another part of the program tries to call them.</p>
</div>
<div class="paragraph">
<p>To provide equivalent support for AspectJ applications compiled with a
standard Java 5 compiler, AspectJ 5 defines the <code>Aspects</code> utility class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Aspects</span> {

  <span class="comment">/* variation used for singleton, percflow, percflowbelow */</span>
  <span class="directive">static</span>&lt;T&gt; <span class="directive">public</span> <span class="directive">static</span> T aspectOf(T aspectType) {...}

  <span class="comment">/* variation used for perthis, pertarget */</span>
  <span class="directive">static</span>&lt;T&gt; <span class="directive">public</span> <span class="directive">static</span> T aspectOf(T aspectType, <span class="predefined-type">Object</span> forObject) {...}

  <span class="comment">/* variation used for pertypewithin */</span>
  <span class="directive">static</span>&lt;T&gt; <span class="directive">public</span> <span class="directive">static</span> T aspectOf(T aspectType, <span class="predefined-type">Class</span> forType) {...}

  <span class="comment">/* variation used for singleton, percflow, percflowbelow */</span>
  <span class="directive">public</span> <span class="directive">static</span> <span class="type">boolean</span> hasAspect(<span class="predefined-type">Object</span> anAspect) {...}

  <span class="comment">/* variation used for perthis, pertarget */</span>
  <span class="directive">public</span> <span class="directive">static</span> <span class="type">boolean</span> hasAspect(<span class="predefined-type">Object</span> anAspect, <span class="predefined-type">Object</span> forObject) {...}

  <span class="comment">/* variation used for pertypewithin */</span>
  <span class="directive">public</span> <span class="directive">static</span> <span class="type">boolean</span> hasAspect(<span class="predefined-type">Object</span> anAspect, <span class="predefined-type">Class</span> forType) {...}
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="reflection">New Reflection Interfaces</h2>
<div class="sectionbody">
<div class="paragraph">
<p>AspectJ 5 provides a full set of reflection APIs analogous to the
<code>java.lang.reflect</code> package, but fully aware of the AspectJ type system.
See the javadoc for the runtime and tools APIs for the full details. The
reflection APIs are only supported when running under Java 5 and for
code compiled by the AspectJ 5 compiler at target level 1.5.</p>
</div>
<div class="sect2">
<h3 id="reflection_api">Using <code>AjTypeSystem</code></h3>
<div class="paragraph">
<p>The starting point for using the reflection apis is
<code>org.aspectj.lang.reflect.AjTypeSystem</code> which provides the method
<code>getAjType(Class)</code> which will return the <code>AjType</code> corresponding to a
given Java class. The <code>AjType</code> interface corresponds to
<code>java.lang.Class</code> and gives you access to all of the method, field,
constructor, and also pointcut, advice, declare statement and inter-type
declaration members in the type.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="miscellaneous">Other Changes in AspectJ 5</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="pointcuts-change">Pointcuts</h3>
<div class="paragraph">
<p>AspectJ 5 is more liberal than AspectJ 1.2.1 in accepting pointcut
expressions that bind context variables in more than one location. For
example, AspectJ 1.2.1 does not allow:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">pointcut foo(Foo foo) :
  (execution(* *(..)) &amp;&amp; <span class="local-variable">this</span>(foo) ) ||
  (set(* *) &amp;&amp; target(foo));</code></pre>
</div>
</div>
<div class="paragraph">
<p>whereas this expression is permitted in AspectJ 5. Each context variable
must be bound exactly once in each branch of a disjunction, and the
disjunctive branches must be mutually exclusive. In the above example
for instance, no join point can be both an execution join point and a
set join point so the two branches are mutually exclusive.</p>
</div>
</div>
<div class="sect2">
<h3 id="declare-soft-change">Declare Soft</h3>
<div class="paragraph">
<p>The semantics of the <code>declare soft</code> statement have been refined in
AspectJ 5 to only soften exceptions that are not already runtime
exceptions. If the exception type specified in a declare soft statement
is <code>RuntimeException</code> or a subtype of <code>RuntimeException</code> then a new
XLint warning will be issued:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">declare soft : SomeRuntimeException : execution(* *(..));

<span class="comment">// &quot;SomeRuntimeException will not be softened as it is already a</span>
<span class="comment">// RuntimeException&quot; [XLint:runtimeExceptionNotSoftened]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This XLint message can be controlled by setting the
<code>runtimeExceptionNotSoftened</code> XLint parameter.</p>
</div>
<div class="paragraph">
<p>If the exception type specified in a declare soft statement is a super
type of <code>RuntimeException</code> (such as <code>Exception</code> for example) then any
<em>checked</em> exception thrown at a matched join point, where the exception
is an instance of the softened exception, will be softened to an
<code>org.aspectj.lang.SoftException</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> aspect SoftenExample {
  declare soft : <span class="exception">Exception</span> : execution(* Foo.*(..));
}

<span class="type">class</span> <span class="class">Foo</span> {
  <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
    Foo foo = <span class="keyword">new</span> Foo();
    foo.foo();
    foo.bar();
  }

  <span class="type">void</span> foo() <span class="directive">throws</span> <span class="exception">Exception</span> {
    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">Exception</span>();        <span class="comment">// this will be converted to a SoftException</span>
  }

  <span class="type">void</span> bar() <span class="directive">throws</span> <span class="exception">Exception</span> {
    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">RuntimeException</span>();  <span class="comment">// this will remain a RuntimeException</span>
  }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ltw">Load-Time Weaving</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="ltw-introduction">Introduction</h3>
<div class="paragraph">
<p>See <a href="../devguide/ltw.html#ltw">Developer&#8217;s Guide</a> for information on
load-time weaving support in AspectJ 5.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="grammar">A Grammar for the AspectJ 5 Language</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">== type patterns ===

TypePattern :=
    SimpleTypePattern |
    '!' TypePattern |
    '(' AnnotationPattern? TypePattern ')'
    TypePattern '&amp;&amp;' TypePattern |
    TypePattern '||' TypePattern

SimpleTypePattern := DottedNamePattern '+'? '[]'*

DottedNamePattern :=
    FullyQualifiedName RestOfNamePattern? |
    '*' NotStarNamePattern?

RestOfNamePattern := '..' DottedNamePattern | '*' NotStarNamePattern?

NotStarNamePattern :=
    FullyQualifiedName RestOfNamePattern? |
    '..' DottedNamePattern

FullyQualifiedName := JavaIdentifierCharacter+ ('.' JavaIdentifierCharacter+)*

== annotation patterns ===

AnnotationPattern := '!'? '@' AnnotationTypePattern AnnotationPattern*

AnnotationTypePattern := FullyQualifiedName | '(' TypePattern ')'

== signature patterns ===

-- field --

FieldPattern :=
    AnnotationPattern? FieldModifiersPattern?
    TypePattern (TypePattern DotOrDotDot)? SimpleNamePattern

FieldModifiersPattern := '!'? FieldModifier FieldModifiersPattern*

FieldModifier :=
    'public' | 'private' | 'protected' | 'static' |
    'transient' | 'final'

DotOrDotDot := '.' | '..'

SimpleNamePattern := JavaIdentifierChar+ ('*' SimpleNamePattern)?

-- method --

MethodPattern :=
    AnnotationPattern? MethodModifiersPattern? TypePattern
    (TypePattern DotOrDotDot)? SimpleNamePattern
    '(' FormalsPattern ')' ThrowsPattern?

MethodModifiersPattern := '!'? MethodModifier MethodModifiersPattern*

MethodModifier :=
    'public' | 'private' | 'protected' | 'static' |
    'synchronized' | 'final'

FormalsPattern :=
    '..' (',' FormalsPatternAfterDotDot)? |
    OptionalParensTypePattern (',' FormalsPattern)* |
    TypePattern '...'

FormalsPatternAfterDotDot :=
    OptionalParensTypePattern (',' FormalsPatternAfterDotDot)* |
    TypePattern '...'

ThrowsPattern := 'throws' TypePatternList

TypePatternList := TypePattern (',' TypePattern)*

-- constructor --

ConstructorPattern :=
    AnnotationPattern? ConstructorModifiersPattern?
    (TypePattern DotOrDotDot)? 'new' '(' FormalsPattern ')'
    ThrowsPattern?

ConstructorModifiersPattern :=
    '!'? ConstructorModifier ConstructorModifiersPattern*

ConstructorModifier := 'public' | 'private' | 'protected'

== Pointcuts ===

PointcutPrimitive :=
    Call | Execution | Get | Set | Handler |
    Initialization | PreInitialization |
    StaticInitialization | AdviceExecution |
    This | Target | Args | CFlow | CFlowBelow |
    Within | WithinCode | If |
    AnnotationPointcut

AnnotationPointcut :=
    AtAnnotation | AtThis | AtTarget |
    AtWithin | AtWithinCode | AtArgs

Call := 'call' '(' MethodOrConstructorPattern ')'

MethodOrConstructorPattern := MethodPattern | ConstructorPattern

Execution := 'execution' '(' MethodOrConstructorPattern ')'

Get := 'get' '(' FieldPattern ')'
Set := 'set' '(' FieldPattern ')'
Handler := 'handler' '(' OptionalParensTypePattern ')'
Initialization := 'initialization' '(' ConstructorPattern ')'
PreInitialization := 'preinitialization' '(' ConstructorPattern ')'
StaticInitialization := 'staticinitialization' '(' OptionalParensTypePattern ')'
AdviceExecution := 'adviceexecution' '(' ')'
This := 'this' '(' TypeOrIdentifier ')'
Target := 'target' '(' TypeOrIdentifier ')'
Args := 'args' '(' FormalsOrIdentifiersPattern ')'
CFlow := 'cflow' '(' Pointcut ')'
CFlowBelow := 'cflowbelow' '(' Pointcut ')'
Within := 'within' '(' OptionalParensTypePattern ')'
WithinCode := 'withincode' '(' OptionalParensTypePattern ')'
If := 'if' '(' BooleanJavaExpression ')'

TypeOrIdentifier := FullyQualifiedName ('[' ']')* | Identifier
Identifier := JavaIdentifierChar+

FormalsOrIdentifiersPattern :=
    '..' (',' FormalsOrIdentifiersPatternAfterDotDot)? |
    TypeOrIdentifier (',' FormalsOrIdentifiersPattern)* |
    '*' (',' FormalsOrIdentifiersPattern)*

FormalsOrIdentifiersPatternAfterDotDot :=
    TypeOrIdentifier (',' FormalsOrIdentifiersPatternAfterDotDot)* |
    '*' (',' FormalsOrIdentifiersPatternAfterDotDot)*

AtAnnotation := '@annotation' '(' AnnotationOrIdentifier ')'
AtThis := '@this' '(' AnnotationOrIdentifer ')'
AtTarget := '@target' '(' AnnotationOrIdentifier ')'
AtWithin := '@within' '(' AnnotationOrIdentifier ')'
AtWithinCode := '@withincode' '(' AnnotationOrIdentifier ')'

AnnotationOrIdentifier := FullyQualifiedName | Identifier

AtArgs := '@args' '(' AnnotationsOrIdentifiersPattern ')'

AnnotationsOrIdentifiersPattern :=
    '..' (',' AnnotationsOrIdentifiersPatternAfterDotDot)? |
    AnnotationOrIdentifier (',' AnnotationsOrIdentifiersPattern)* |
    '*' (',' AnnotationsOrIdentifiersPattern)*

AnnotationsOrIdentifiersPatternAfterDotDot :=
    AnnotationOrIdentifier (',' AnnotationsOrIdentifiersPatternAfterDotDot)* |
    '*' (',' AnnotationsOrIdentifiersPatternAfterDotDot)*

PointcutDeclaration :=
    PointcutModifiers? 'pointcut' Identifier Formals ':' PointcutExpression

PointcutModifiers := PointcutModifier*

PointcutModifier := 'public' | 'private' | 'protected' | 'abstract'

Formals := '(' ParamList? ')'
ParamList := FullyQualifiedName Identifier (',' ParamList)*

ReferencePointcut := (FullyQualifiedName '.')? Identifier Formals

PointcutExpression :=
    (PointcutPrimitive | ReferencePointcut) |
    '!' PointcutExpression |
    '(' PointcutExpression ')' |
    PointcutExpression '&amp;&amp;' PointcutExpression |
    PointcutExpression '||' PointcutExpression

== Advice ===

to be written...

== Inter-type Declarations ===

to be written...

== Declare Statements ===

to be written...

== Aspects ===

to be written...</code></pre>
</div>
</div>
</div>
</div>
</div>
</body>
</html>