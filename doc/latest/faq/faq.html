<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.20">
<title>AspectJ FAQ</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="./asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="./coderay-asciidoctor.css">
</head>
<body id="faq" class="article toc2 toc-left">
<div id="header">
<h1>AspectJ FAQ</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_overview">Overview</a></li>
<li><a href="#quickstart">Quick Start</a></li>
<li><a href="#typicalprograms">Typical AspectJ programs</a></li>
<li><a href="#concepts">Basic AOP and AspectJ Concepts</a></li>
<li><a href="#whyaop">Why AOP?</a></li>
<li><a href="#related">Related Technology</a></li>
<li><a href="#adoption">Deciding to adopt AspectJ</a></li>
<li><a href="#compiler">Using the AspectJ compiler</a></li>
<li><a href="#devtools">Integrating AspectJ into your development environment</a></li>
<li><a href="#notes">Programming notes and tips</a></li>
<li><a href="#problems">Common Problems</a></li>
<li><a href="#aj11">AspectJ 1.1 and eclipse.org</a></li>
<li><a href="#AspectJ5">AspectJ 5 and Java 5</a></li>
<li><a href="#Technology">Understanding AspectJ Technology</a></li>
<li><a href="#Developers">AspectJ Project Development</a></li>
<li><a href="#help">Getting Help</a></li>
<li><a href="#project">About the AspectJ Project</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><em>Copyright (c) 1997-2001 Xerox Corporation, 2002 Palo Alto Research
Center, Incorporated, 2003-2006 Contributors. All rights reserved.</em></p>
</div>
<div class="paragraph">
<p><em>Last updated November 3, 2006</em></p>
</div>
<div class="paragraph">
<p>For a list of recently-updated FAQ entries, see #q:faqchanges[Q:What has
changed since the last FAQ version?]</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_overview">Overview</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Q:</strong> What is AspectJ?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> AspectJ(tm) is a simple and practical extension to the Java(tm)
programming language that adds to Java aspect-oriented programming (AOP)
capabilities. AOP allows developers to reap the benefits of modularity
for concerns that cut across the natural units of modularity. In
object-oriented programs like Java, the natural unit of modularity is
the class. In AspectJ, aspects modularize concerns that affect more than
one class.</p>
</div>
<div class="paragraph">
<p>You compile your program using the AspectJ compiler (perhaps using the
supported development environments) and then run it, supplying a small
(&lt; 100K) runtime library.</p>
</div>
<div class="paragraph">
<p>The AspectJ technologies include a compiler (<code>ajc</code>), a debugger
(<code>ajdb</code>), a documentation generator (<code>ajdoc</code>) and integration with Eclipse and
Ant.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> What are the benefits of using AspectJ?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> AspectJ can be used to improve the modularity of software systems.</p>
</div>
<div class="paragraph">
<p>Using ordinary Java, it can be difficult to modularize design concerns
such as</p>
</div>
<div class="ulist">
<ul>
<li>
<p>system-wide error-handling</p>
</li>
<li>
<p>contract enforcement</p>
</li>
<li>
<p>distribution concerns</p>
</li>
<li>
<p>feature variations</p>
</li>
<li>
<p>context-sensitive behavior</p>
</li>
<li>
<p>persistence</p>
</li>
<li>
<p>testing</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The code for these concerns tends to be spread out across the system.
Because these concerns won&#8217;t stay inside of any one module boundary, we
say that they <em>crosscut</em> the system&#8217;s modularity.</p>
</div>
<div class="paragraph">
<p>AspectJ adds constructs to Java that enable the modular implementation
of crosscutting concerns. This ability is particularly valuable because
crosscutting concerns tend to be both complex and poorly localized,
making them hard to deal with.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> Can AspectJ work with any Java program?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> AspectJ has been designed as a <em>compatible</em> extension to Java. By
compatible, we mean</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>upward compatible</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">All legal Java programs are legal AspectJ
programs.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>platform compatible</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">All legal AspectJ programs run on standard Java
virtual machines.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>tool compatible</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Existing tools can be extended to work with AspectJ.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>programmer compatible</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Programming in AspectJ feels natural to Java
programmers.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The AspectJ tools run on any Java 2 Platform compatible platform. The
AspectJ compiler produces classes that run on any Java 1.1 (or later)
compatible platform.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> How is AspectJ licensed?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> Since AspectJ 1.9.7, source code and documentation is available
under the
<a href="https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt">Eclipse Public
License v 2.0</a>.</p>
</div>
<div class="paragraph">
<p>AspectJ 1.5.2 through 1.9.6 source code and documentation is available
under the <a href="https://www.eclipse.org/org/documents/epl-v10.php">Eclipse
Public License v 1.0</a>.</p>
</div>
<div class="paragraph">
<p>AspectJ 1.1 through 1.5.1 source code and documentation is available
under the <a href="https://eclipse.org/legal/cpl-v10.html">Common Public License
1.0</a>.</p>
</div>
<div class="paragraph">
<p>The AspectJ 1.0 tools are open-source software available under the
<a href="https://www.opensource.org/licenses/mozilla1.1">Mozilla Public License
1.1</a>. That documentation is available under a separate license that
precludes for-profit or commercial redistribution.</p>
</div>
<div class="paragraph">
<p>The runtime jar aspectjrt.jar and its distribution are also covered by
the <a href="https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt">Eclipse
Public License</a>.</p>
</div>
<div class="paragraph">
<p>For answers to common licensing questions, see the
<a href="https://www.eclipse.org/legal/eplfaq.php">Eclipse Public License FAQ</a>.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> What is the AspectJ Project?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> AspectJ is based on over ten years of research at
<a href="https://www.parc.xerox.com">Xerox Palo Alto Research Center</a> as funded by
Xerox, a U.S. Government grant (NISTATP), and a DARPA contract.</p>
</div>
<div class="paragraph">
<p>It has evolved through open-source releases to a strong user community
and now operates as an open source project at <a href="https://eclipse.org/aspectj" class="bare">https://eclipse.org/aspectj</a>
The AspectJ team works closely with the community to ensure AspectJ
continues to evolve as an effective aspect-oriented programming language
and tool set.</p>
</div>
<div class="paragraph">
<p>The latest release is 1.2 which can be downloaded from the
<a href="https://eclipse.org/aspectj">AspectJ project page</a>, including sources as
described <a href="#buildingsource">Q:How do I get and compile the source code
for AspectJ?</a>. Development is focused on supporting applications,
improving quality and performance, enhancing integration with IDE&#8217;s, and
building the next generations of the language.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="quickstart">Quick Start</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Q:</strong> What Java versions does AspectJ require and support?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> The AspectJ compiler produces programs for any released version of
the Java platform (jdk1.1 and later). When running, your program classes
must be able to reach classes in the small (&lt; 100K) runtime library
(aspectjrt.jar) from the distribution. The tools themselves require J2SE
1.3 or later to run, but the compiler can produce classes for any
1.1-compliant version of the Java platform.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> How do I download and install AspectJ?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> From AspectJ&#8217;s <a href="https://eclipse.org/aspectj">web page</a> , download the
AspectJ distribution. The <code>jar</code> file is installed by executing</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">java -jar jar file name</code></pre>
</div>
</div>
<div class="paragraph">
<p>Do <strong>not</strong> try to extract the <code>jar</code> file contents and then attempt to
execute <code>java org.aspectj.tools.Main</code>. (A <code>NoClassDefFoundError</code>
exception will be thrown.) The AspectJ distribution is not designed to
be installed this way. Use the <code>java -jar</code> form shown above.</p>
</div>
<div class="paragraph">
<p>To uninstall, remove the files the installer wrote in your file system.
In most cases, you can delete the top-level install directory (and all
contained files), after you remove any new or updated files you want to
keep. On Windows, no registry settings were added or changed, so nothing
needs to be undone. Do not install over prior versions, which might have
different files. Delete the prior version first.</p>
</div>
<div id="howToStartUsing" class="paragraph">
<p><strong>Q:</strong> How should I start using AspectJ?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> Many users adopt AspectJ in stages, first using it to understand
and validate their systems (relying on it only in development) and then
using it to implement crosscutting concerns in production systems.
AspectJ has been designed to make each step discrete and beneficial.</p>
</div>
<div class="paragraph">
<p>In order of increasing reliance, you may use AspectJ:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>In the development process</strong> Use AspectJ to trace or log interesting
information. You can do this by adding simple AspectJ code that performs
logging or tracing. This kind of addition may be removed ("unplugged")
for the final build since it does not implement a design requirement;
the functionality of the system is unaffected by the aspect.</p>
</li>
<li>
<p><strong>As an ancillary part of your system</strong> Use AspectJ to more completely
and accurately test the system. Add sophisticated code that can check
contracts, provide debugging support, or implement test strategies. Like
pure development aspects, this code may also be unplugged from
production builds. However, the same code can often be helpful in
diagnosing failures in deployed production systems, so you may design
the functionality to be deployed but disabled, and enable it when
debugging.</p>
</li>
<li>
<p><strong>As an essential part of your system</strong> Use AspectJ to modularize
crosscutting concerns in your system by design. This uses AspectJ to
implement logic integral to a system and is delivered in production
builds.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This adoption sequence works well in practice and has been followed by
many projects.</p>
</div>
<div id="integrateWithDevTools" class="paragraph">
<p><strong>Q:</strong> How does AspectJ integrate with existing Java development tools?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> AspectJ products are designed to make it easy to integrate AspectJ
into an existing development process. Each release includes Ant tasks
for building programs, the AspectJ Development Environment (AJDE) for
writing aspects inside popular IDE&#8217;s, and command-line tools for
compiling and documenting Java and AspectJ code.</p>
</div>
<div class="paragraph">
<p>AspectJ provides replacements for standard Java tools:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ajc</code>, the AspectJ compiler, runs on any Java 2 compatible platform,
and produces classes that run on any Java 1.1 (or later) compatible
platform.</p>
</li>
<li>
<p><code>ajdoc</code> produces API documentation like javadoc, with additional
crosscutting links. For example, it shows advice affecting a particular
method or all code affected by a given aspect. At present, <code>ajdoc</code> is
only supported in AspectJ 1.0.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For debugging, AspectJ supports JSR-45, which provides a mechanism for
debugging .class files that have multiple source files. Debugger clients
and VM&#8217;s are beginning to support this; see Sun&#8217;s J2SE 1.4.1 VM and jdb
debugger and recent versions of JBuilder.</p>
</div>
<div class="paragraph">
<p>The AspectJ Development Environment (AJDE) enables programmers to view
and navigate the crosscutting structures in their programs, integrated
with existing support in popular Java IDE&#8217;s for viewing and navigating
object-oriented structures. For many programmers this provides a deeper
understanding of how aspects work to modularize their concerns and
permits them to extend some of their development practices without
having to abandon their existing tools.</p>
</div>
<div class="paragraph">
<p>AJDE is a set of API&#8217;s providing the basis for the following development
tool integrations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Eclipse (version 2.0) in the Eclipse AspectJ Development Tools project
<a href="https://eclipse.org/ajdt" class="bare">https://eclipse.org/ajdt</a></p>
</li>
<li>
<p>Emacs (GNU version 20.3) and XEmacs (version 21.1 on Unix and 21.4 on
Windows), in the SourceForge AspectJ for Emacs project
<a href="https://aspectj4emacs.sourceforge.net" class="bare">https://aspectj4emacs.sourceforge.net</a></p>
</li>
<li>
<p>JBuilder (versions 4 through 7) from Borland in the SourceForge
AspectJ for JBuilder project <a href="https://aspectj4jbuildr.sourceforge.net" class="bare">https://aspectj4jbuildr.sourceforge.net</a></p>
</li>
<li>
<p>Netbeans up to 3.4 (and Sun Microsystems' Forte for Java (versions 2
and 3), Sun/One) in the SourceForge AspectJ for NetBeans project
<a href="https://aspectj4netbean.sourceforge.net" class="bare">https://aspectj4netbean.sourceforge.net</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Finally, as mentioned above, AspectJ also supports building with Ant by
providing task interfaces to the ajc and ajdoc tools.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="typicalprograms">Typical AspectJ programs</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Q:</strong> Are aspects always optional or non-functional parts of a program?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> No. Although AspectJ can be used in a way that allows AspectJ code
to be removed for the final build, aspect-oriented code is not <em>always</em>
optional or non-functional. Consider what AOP really does: it makes the
modules in a program correspond to modules in the design. In any given
design, some modules are optional, and some are not.</p>
</div>
<div class="paragraph">
<p>The examples directory included in the AspectJ distribution contains
some examples of the use aspects that are not optional. Without aspects,</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>bean</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Point objects would not be JavaBeans.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>introduction</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Point objects would not be cloneable, comparable or
serializable.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>spacewar</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Nothing would be displayed.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>telecom</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No calls would be billed.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Q:</strong> What is the difference between development and production aspects?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> Production aspects are delivered with the finished product, while
development aspects are used during the development process. Often
production aspects are also used during development.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> What are some common development aspects?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> Aspects for logging, tracing, debugging, profiling or performance
monitoring, or testing.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> What are some common production aspects?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> Aspects for performance monitoring and diagnostic systems, display
updating or notifications generally, security, context passing, and
error handling.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="concepts">Basic AOP and AspectJ Concepts</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Q:</strong> What are scattering, tangling, and crosscutting?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> "Scattering" is when similar code is distributed throughout many
program modules. This differs from a component being used by many other
components since it involves the risk of misuse at each point and of
inconsistencies across all points. Changes to the implementation may
require finding and editing all affected code.</p>
</div>
<div class="paragraph">
<p>"Tangling" is when two or more concerns are implemented in the same body
of code or component, making it more difficult to understand. Changes to
one implementation may cause unintended changes to other tangled
concerns.</p>
</div>
<div class="paragraph">
<p>"Crosscutting" is how to characterize a concern than spans multiple
units of OO modularity - classes and objects. Crosscutting concerns
resist modularization using normal OO constructs, but aspect-oriented
programs can modularize crosscutting concerns.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> What are join points?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> Join points are well-defined points in the execution of a program.
Not every execution point is a join point: only those points that can be
used in a disciplined and principled manner are. So, in AspectJ, the
execution of a method call is a join point, but "the execution of the
expression at line 37 in file Foo.java" is not.</p>
</div>
<div class="paragraph">
<p>The rationale for restricting join points is similar to the rationale
for restricting access to memory (pointers) or restricting control flow
expressions (<code>goto</code>) in Java: programs are easier to understand,
maintain and extend without the full power of the feature.</p>
</div>
<div class="paragraph">
<p>AspectJ join points include reading or writing a field; calling or
executing an exception handler, method or constructor.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> What is a pointcut?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> A pointcut picks out #q:joinpoints[ join points ]. These join
points are described by the pointcut declaration. Pointcuts can be
defined in classes or in aspects, and can be named or be anonymous.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> What is advice?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> Advice is code that executes at each #q:joinpoints[join point]
picked out by a #q:pointcut[pointcut]. There are three kinds of advice:
before advice, around advice and after advice. As their names suggest,
before advice runs before the join point executes; around advice
executes before and after the join point; and after advice executes
after the join point. The power of advice comes from the advice being
able to access values in the execution context of a pointcut.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> What are inter-type declarations?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> AspectJ enables you to declare members and supertypes of another
class in an aspect, subject to Java&#8217;s type-safety and access rules.
These are visible to other classes only if you declare them as
accessible. You can also declare compile-time errors and warnings based
on pointcuts.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> What is an aspect?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> Aspects are a new class-like language element that has been added
to Java by AspectJ. Aspects are how developers encapsulate concerns that
cut across classes, the natural unit of modularity in Java.</p>
</div>
<div class="paragraph">
<p>Aspects are similar to classes because&#8230;&#8203;</p>
</div>
<div class="ulist">
<ul>
<li>
<p>aspects have type</p>
</li>
<li>
<p>aspects can extend classes and other aspects</p>
</li>
<li>
<p>aspects can be abstract or concrete</p>
</li>
<li>
<p>non-abstract aspects can be instantiated</p>
</li>
<li>
<p>aspects can have static and non-static state and behavior</p>
</li>
<li>
<p>aspects can have fields, methods, and types as members</p>
</li>
<li>
<p>the members of non-privileged aspects follow the same accessibility
rules as those of classes</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Aspects are different than classes because&#8230;&#8203;</p>
</div>
<div class="ulist">
<ul>
<li>
<p>aspects can additionally include as members pointcuts, advice, and
inter-type declarations;</p>
</li>
<li>
<p>aspects can be qualified by specifying the context in which the
non-static state is available</p>
</li>
<li>
<p>aspects can&#8217;t be used interchangeably with classes</p>
</li>
<li>
<p>aspects don&#8217;t have constructors or finalizers, and they cannot be
created with the new operator; they are automatically available as
needed.</p>
</li>
<li>
<p>privileged aspects can access private members of other types</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="whyaop">Why AOP?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Q:</strong> Are crosscutting concerns induced by flaws in parts of the system
design, programming language, operating system, etc. Or is there
something more fundamental going on?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> AOP&#8217;s fundamental assumption is that in any sufficiently complex
system, there will inherently be some crosscutting concerns.</p>
</div>
<div class="paragraph">
<p>So, while there are some cases where you could re-factor a system to
make a concern no longer be crosscutting, the AOP idea is that there are
many cases where that is not possible, or where doing so would damage
the code in other ways.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> Does it really make sense to define aspects in terms of
crosscutting?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> Yes.</p>
</div>
<div class="paragraph">
<p>The short summary is that it is right to define AOP in terms of
crosscutting, because well-written AOP programs have clear crosscutting
structure. It would be a mistake to define AOP in terms of "cleaning up
tangling and scattering", because that isn&#8217;t particular to AOP, and past
programming language innovations also do that, as will future
developments.</p>
</div>
<div class="paragraph">
<p>(Slides for a long talk on this topic were once available at
<a href="https://www.cs.ubc.ca/~gregor/vinst-2-17-01.zip" class="bare">https://www.cs.ubc.ca/~gregor/vinst-2-17-01.zip</a>.)</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> Is AOP restricted to domain-specific applications?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> No. Some implementations of AOP are domain-specific, but AspectJ
was specifically designed to be general-purpose.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> Why do I need AOP if I can use interceptors (or JVMPI or ref
lection)?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> There are many mechanisms people use now to implement some
crosscutting concerns. But they don&#8217;t have a way to express the actual
structure of the program so you (and your tools) can reason about it.
Using a language enables you to express the crosscutting in first-class
constructs. You can not only avoid the maintenance problems and
structural requirements of some other mechanisms, but also combine forms
of crosscutting so that all the mechanisms for a particular concern are
one piece of code.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="related">Related Technology</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Q:</strong> How does AspectJ compare to other new forms of programming?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> There are many recent proposals for programming languages that
provide control over crosscutting concerns. Aspect-oriented programming
is an overall framework into which many of these approaches fit. AspectJ
is one particular instance of AOP, distinguished by the fact that it was
designed from the ground up to be compatible with Java.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> How do you compare the features of AspectJ with reflective systems?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> Reflective and aspect-oriented languages have an important
similarity: both provide programming support for dealing with
crosscutting concerns. In this sense reflective systems proved that
independent programming of crosscutting concerns is possible.</p>
</div>
<div class="paragraph">
<p>But the control that reflection provides tends to be low-level and
extremely powerful. In contrast, AspectJ provides more carefully
controlled power, drawing on the rules learned from object-oriented
development to encourage a clean and understandable program structure.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> How do AspectJ features compare with those of mixin-based
inheritance?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> Some features of AspectJ, such as introduction, are related to
<em>mixin-based inheritance</em>. But, in order to support crosscutting, a core
goal for AspectJ, AspectJ goes beyond mixin-based inheritance.</p>
</div>
<div class="paragraph">
<p>Firstly, an aspect imposes behavior on a class, rather than a class
requesting behavior from an aspect. An aspect can modify a class without
needing to edit that class. This property is sometimes called <em>reverse
inheritance</em>.</p>
</div>
<div class="paragraph">
<p>Secondly, a single aspect can affect multiple classes in different ways.
A single paint aspect can add different paint methods to all the classes
that know how to paint, unlike mixin classes.</p>
</div>
<div class="paragraph">
<p>So mixin-based inheritance doesn&#8217;t have the reverse inheritance
property, and mixins affect every class that mixes them in the same. If
I want to do something like SubjectObserverProtocol, I need two mixins,
SubjectPartofSubjectObserverProtocol and ObserverPartof&#8230;&#8203; In AspectJ,
both halves of the protocol can be captured in a single aspect.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> How does AspectJ compare with more dynamic AOP?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> Some AOP techniques are presented as "dynamic" because the weaving
occurs when classes are loaded, because aspects can be configured in a
separate XML file before launch, or because some advice depends on
runtime reflection. They are said to be more flexible than AspectJ.</p>
</div>
<div class="paragraph">
<p>This is a misconception. First, the AspectJ 1.1 weaver has always
supported weaving at compile-time or class-load-time. Weaving at
compile-time reduces application launch and running time, and it helps
IDE&#8217;s offer support for tracking down weaving errors and understanding
the impact of aspects on a system. On the other hand, weaving at
load-time simplifies build and deployment. Before AspectJ 1.2, the user
had to write a class loader that used the weaver API to weave at load
time; since 1.2, AspectJ comes with a command-line launcher to support
weaving at class-load-time without any other changes to a build
configuration. In AspectJ 5, we expect to get a similar level of support
as AspectWerkz, and to exploit the class bytecode weaving hook available
in Java 5 VM&#8217;s.</p>
</div>
<div class="paragraph">
<p>Second, AspectJ programs, like Java programs generally, can be written
to support any level of XML configuration or to depend on runtime
reflection. There are some benefits to using AspectJ; e.g., the
proceed() form within around advice simplifies a lot of the work that
otherwise would go into writing a generalized interceptor, without
introducing many of the runtime errors that can result from
interceptors. For AspectJ examples of configurable or
reflection-dependent programs, see the sample code linked off the
AspectJ documentation page or the examples discussed on the mailing
list, e.g.,
<a href="https://dev.eclipse.org/mhonarc/lists/aspectj-users/msg02151.html">Incremental
and runtime weaving support?</a>.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> What is the relationship between AOP and XP (extreme programming
AKA agile methods)?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> From a question on the user list:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">&gt; Anyone know the connections between AOP and Extreme Programming?
&gt; I am really confused. It seems AOP is a programming paradigm, which
&gt; is the next level of abstraction of OOP. Extreme Programming, however,
&gt; this is a lightweight software development process. One of the common
&gt; motivations of AOP and XP is designed to adopt to the requirement
&gt; changes, so that it can save the cost of software development.</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is Raymond Lee&#8217;s answer:</p>
</div>
<div class="paragraph">
<p>You&#8217;re not really that confused. AOP and XP are orthogonal concepts,
although AOP can be used to help accomplish XP goals. One of the goals
of XP is to respond to changing requirements. Another is to reduce the
overall cost of development. These are not necessarily the same thing.</p>
</div>
<div class="paragraph">
<p>One of the principles of XP that contribute to meeting those goals is to
maintain clean, simple designs. One of the criteria for clean, simple
designs is to factor out duplication from the code. Benefits of removing
duplication include the code being easier to understand, better
modularity of the design, lower costs of code changes, less chance of
conflicting changes when practicing collective code ownership, etc.</p>
</div>
<div class="paragraph">
<p>Different types of duplication lend themselves to being addressed by
different design paradigms and language features. Duplicate snippets of
code can be factored out into methods. Duplicate methods can be factored
out to common classes, or pushed up to base classes. Duplicate patterns
of methods and their use can be factored out to mechanisms of classes
and methods (i.e. instantiations of design patterns).</p>
</div>
<div class="paragraph">
<p>AOP addresses a type of duplication that is very difficult to handle in
the other common paradigms, namely cross-cutting concerns. By factoring
out duplicate cross-cutting code into aspects, the target code becomes
simpler and cleaner, and the cross-cutting code becomes more centralized
and modular.</p>
</div>
<div class="paragraph">
<p>So, AOP as a paradigm, and the associated tools, gives an XPer, or
anyone wanting to remove duplication from the code base, a powerful way
to remove a form of duplication not easily addressed until now.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> Will you support C#?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> Not at this time. Although the resemblances between C# and Java
means it would probably be a fairly straightforward matter to take the
AspectJ language design and produce AspectC#, our current focus is only
on supporting effective uses of AspectJ.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="adoption">Deciding to adopt AspectJ</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Q:</strong> Is it safe to use AspectJ in my product plans?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> You may use AspectJ in your product or project with little risk.
Several factors play a role in reducing the risk of adopting this new
technology:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>AspectJ is an <em>addition</em> to Java, and can be introduced into a project
in a way that limits risk. See #q:startUsingAJ[Q: How should I start
using AspectJ?] for some suggestions on how to do this.</p>
</li>
<li>
<p>The AspectJ compiler accepts standard Java as input and produces
standard Java bytecode as output. In 1.0, an optional mode produces
standard Java source code which may then be compiled with any compliant
Java compiler (e.g. Sun&#8217;s <code>javac</code> compiler or IBM&#8217;s <code>jikes</code> compiler).
In 1.1, an optional mode accepts standard Java bytecode from any
compliant Java compiler and weaves in the aspects to produce new
bytecode.</p>
</li>
<li>
<p>AspectJ is available under a non-proprietary, open source license, the
<a href="https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt">Eclipse Public
License v 2.0</a>. AspectJ will continue to evolve and be available,
regardless of the fate of any particular organization involved with
AspectJ.</p>
</li>
<li>
<p>Removing AspectJ from your program is not difficult, although you will
lose the flexibility and economy that AspectJ provided.</p>
</li>
<li>
<p>A number of significant open-source projects and industry products use
AspectJ successfully. A prominent example is the Spring framework which supports
both native AspectJ and its internal "AOP lite" framework Spring AOP. Spring AOP
is based on dynamic proxies, offers a subset of AspectJ features and offers the
corresponding subset of the @AspectJ annotation-based aspect syntax.</p>
</li>
<li>
<p>You may also search for search for, e.g., "AspectJ in real world" on the WWW
or in AspectJ mailing list archives, as described in
<a href="#searchingsite">How can I search the email archives or the web site?</a>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Q:</strong> What is the effect of using AspectJ on the source code size of
programs?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> Using aspects reduces, as a side effect, the number of source lines
in a program. However, the major benefit of using aspects comes from
<em>improving</em> the modularity of a program, not because the program is
smaller. Aspects gather into a module concerns that would otherwise be
scattered across or duplicated in multiple classes.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> Does AspectJ add any performance overhead?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> The issue of performance overhead is an important one. It is also
quite subtle, since knowing what to measure is at least as important as
knowing how to measure it, and neither is always apparent.</p>
</div>
<div class="paragraph">
<p>We aim for the performance of our implementation of AspectJ to be on par
with the same functionality hand-coded in Java. Anything significantly
less should be considered a bug.</p>
</div>
<div class="paragraph">
<p>There is currently no benchmark suite for AOP languages in general or
for AspectJ in particular. It is probably too early to develop such a
suite because AspectJ needs more maturation of the language and the
coding styles first. Coding styles really drive the development of the
benchmark suites since they suggest what is important to measure.</p>
</div>
<div class="paragraph">
<p>Though we cannot show it without a benchmark suite, we believe that code
generated by AspectJ has negligible performance overhead. Inter-type
member and parent introductions should have very little overhead, and
advice should only have some indirection which could be optimized away
by modern VM&#8217;s.</p>
</div>
<div class="paragraph">
<p>The <code>ajc</code> compiler will use static typing information to only insert the
advice and dynamic pointcut tests that are absolutely necessary. Unless
you use 'thisJoinPoint' or 'if', the main dynamic checks will be
'instanceof' checks which are generally quite fast. These checks will
only be inserted when they can not be inferred from the static type
information.</p>
</div>
<div class="paragraph">
<p>When measuring performance, write AspectJ code fragments and compare
them to the performance of the corresponding code written without
AspectJ. For example, don&#8217;t compare a method with before/after advice
that grabs a lock to just the method. That would be comparing apples and
oranges. Also be sure to watch out for JIT effects that come from empty
method bodies and the like. Our experience is that they can be quite
misleading in understanding what you&#8217;ve measured.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> I&#8217;ve heard that AspectJ leads to modularity violations. Does it?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> Well I haven&#8217;t yet seen a language in which you can&#8217;t write bad
code!</p>
</div>
<div class="paragraph">
<p>But seriously, most AspectJ users find that just like when they learned
OO, it takes a while to really get the hang of it. They tend to start in
the usual way, by copying canonical examples and experimenting with
variations on them.</p>
</div>
<div class="paragraph">
<p>But users also find that rather than being dangerous, AspectJ helps them
write code that is more clear and has better encapsulation&#8201;&#8212;&#8201;once they
understand the kind of modularity AspectJ supports. There are several
good papers that talk about this (see below), but here&#8217;s a basic point
to keep in mind: when properly used, AspectJ makes it possible program
in a modular way, something that would otherwise be spread throughout
the code. Consider the following code, adapted from the AspectJ
tutorial:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect PublicErrorLogging {
    Log log = <span class="keyword">new</span> Log();

    pointcut publicInterface(<span class="predefined-type">Object</span> o):
        call(<span class="directive">public</span> * com.xerox.*.*(..)) &amp;&amp; target(o);

    after(<span class="predefined-type">Object</span> o) throwing (<span class="exception">Error</span> e): publicInterface(o) {
        log.write(o, e);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The effect of this code is to ensure that whenever any public method of
an interface or class in the <code>com.xerox</code> package throws an error, that
error is logged before being thrown to its caller.</p>
</div>
<div class="paragraph">
<p>Of course in the alternative implementation a large number of methods
have a try/catch around their body.</p>
</div>
<div class="paragraph">
<p>The AspectJ implementation of this crosscutting concern is clearly
modular, whereas the other implementation is not. As a result, if you
want to change it, its easier in the AspectJ implementation. For
example, if you also want to pass the name of the method, or its
arguments to <code>log.write</code>, you only have to edit one place in the AspectJ
code.</p>
</div>
<div class="paragraph">
<p>This is just a short example, but I hope it shows how what happens with
AOP and AspectJ is that the usual benefits of modularity are achieved
for crosscutting concerns, and that leads to better code, not more
dangerous code.</p>
</div>
<div class="paragraph">
<p>One paper someone else just reminded me of that talks some more about
this is:
<a href="https://www.cs.ubc.ca/~kdvolder/Workshops/OOPSLA2001/submissions/12-nordberg.pdf" class="bare">https://www.cs.ubc.ca/~kdvolder/Workshops/OOPSLA2001/submissions/12-nordberg.pdf</a></p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> Why does AspectJ permit aspects to access and add members of
another type? Isn&#8217;t that violating OO encapsulation?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> In the spirit of Smalltalk, we have decided to give more power to
the language in order to let the user community experiment and discover
what is right. To date this has proven to be a successful strategy
because it has permitted the construction of many useful aspects that
crosscut the internal state of an object, and as such need access the
its private members. However, we are not discounting that some sort of
restrictions are useful, rather, we are seeking input from the community
in order to decide on what these restrictions should be.</p>
</div>
<div class="paragraph">
<p>In that light, our position on encapsulation is :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>we respect Java&#8217;s visibility rules</p>
</li>
<li>
<p>we also provide open-classes, a mature OO technology</p>
</li>
<li>
<p>we provide "privileged" access if you really need it.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Introducing parents or members to classes is a well-studied OO technique
known as open classes.</p>
</div>
<div class="paragraph">
<p>Open classes have been used in many languages prior to AspectJ,
including CLOS, Python, Smalltalk, Objective-C, and others. Building
from Java, introduction in AspectJ provides better name hygiene and
access control than prior languages. Introduced code obeys all of Java&#8217;s
normal accessibility rules for its lexical location in the aspect that
it is introduced from. Such code can not even see, much less access,
private members of the class it is introduced into. Further,
introductions can be declared private to the aspect, so they are not
visible to other clients of the class.</p>
</div>
<div class="paragraph">
<p>Privileged aspects do permit access to private members of another class.
They are a response to the very few cases where developers genuinely
need such access (typically for testing purposes where it access is
necessary), but it would be more risky to open access by putting the
aspect in the same package, adding test code, or changing access in the
target class. We recommend using privileged aspects only as necessary,
and believe that marking them "privileged" makes any potential misuse
apparent.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> Can I use AspectJ with J2EE?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> Consider the component types in J2EE:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Servlet: AspectJ works well within servlets</p>
</li>
<li>
<p>JSP: It is possible to use AspectJ to affect code in JSPs by
precompiling them into Java sources and compiling these with ajc. This
can be used, e.g., to customize displays by turning on and off custom
JSP taglibs. The mapping from a given jsp source to java package and
class name is not standardized, which means doing this imposes
dependencies on specific container versions.</p>
</li>
<li>
<p>EJB: AspectJ supports a wide variety of aspects for EJBs. It can be
used for logging, tracing, debugging, error handling by layers,
correlated method-level interception (e.g., chargebacks), metering,
fine-grained transactions, etc. Indeed, it can be used to enforce
adherence to coding restrictions within an EJB (e.g., not using java.io,
creating a class loader, or listening on sockets) using <code>declare error</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The basic limitations are that there is no built-in support for writing
J2EE analogs for AspectJ extensions to Java, like distributed aspects,
distributed cflow, or managing state between invocations. These don&#8217;t
prevent one from using AspectJ to do useful intra-container
implementation, nor need they prevent one from building distributed
support, state management, and inter-component implementations that
leverage AspectJ. It just takes some work. In more detail:</p>
</div>
<div class="paragraph">
<p>All AspectJ implementations may define "code the implementation
controls". The AspectJ 1.0 implementation defines this as the files
passed to the compiler (AspectJ 1.1 will also support bytecode weaving).</p>
</div>
<div class="paragraph">
<p>Some advice on EJB operations will generate methods that confuse ejb
compilers. To avoid this problem, you can use the -XaddSafePrefix flag
when compiling with ajc.</p>
</div>
<div class="paragraph">
<p>EJB components may be invoked remotely, and containers may passivate and
pool EJB&#8217;s. Servlets have similar limitations, and in both cases the
lifespan of the defining class loader is implementation-dependent
(though it must span the operation of a particular request).</p>
</div>
<div class="paragraph">
<p>Being limited by lifecycle and namespace, the AspectJ 1.0 implementation
supports aspects that operate through non-remote invocations during the
lifetime of the namespace for a particular deployment unit compiled in
its entirety by the ajc compiler. This means AspectJ supports common
aspects only within a single local runtime namespace (usually
implemented as a class loader hierarchy).</p>
</div>
<div class="paragraph">
<p>Further, AspectJ recognizes language-level join points (object
initialization, method calls, etc.), not their EJB analogs (ejb find or
create methods&#8230;&#8203;). These lead to the following consequences:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Issingleton aspects (the default) are limited to the lifetime of the
defining class loader, which in some implementations may not span
multiple invocations of the same application or EJB component.</p>
</li>
<li>
<p>EJB lifecycles are different from object lifecycles, so perthis and
pertarget aspects will make little sense. They do not work in the
current implementation, which uses synchronized methods to ensure a
correct association in threaded environments (EJB&#8217;s may not have
synchronized methods).</p>
</li>
<li>
<p>Percflow or percflowbelow aspects are restricted to a chain of
non-remote invocations. While EJB 2.0 permits declaring an interface
local, this information is not available to the AspectJ compiler today.
For same reasons as stated above fore perthis, these will not work even
in the EJB container.</p>
</li>
<li>
<p>Evaluation of cflow or cflowbelow pointcuts will be valid only with
respect to a chain of non-remote invocations.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In addition, any AspectJ code should respect EJB operations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The EJB container accesses EJB component fields directly, i.e., in
code outside the control of the compiler. There is no join point for
these accesses, and hence no way to write a pointcut to advise that
access.</p>
</li>
<li>
<p>The EJB container may pool EJB components, so any initialization join
points may run once per component constructed, not once per component
initialized for purposes of a client call.</p>
</li>
<li>
<p>The EJB container is permitted to change class loaders, even between
invocations of a particular EJB component (by passivating and activating
with a new class loader). In this case, instances of singleton aspects
will not operate over multiple invocations of the component, or that
static initialization join point recur for a given class as it is
re-loaded. This behavior depends on the container implementation.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Q:</strong> Can I use AspectJ with Generic Java?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> We plan to support Generics when Java 1.5 is available.</p>
</div>
<div class="paragraph">
<p>But at this time, unfortunately not. The two compilers are just not at
all compatible. In an ideal world, there would be a wonderful Open
Source extensible compiler framework for Java that both GJ and AspectJ
would be built on top of, and they would seamlessly interoperate along
with all other extensions to Java that you might be interested in, but
that&#8217;s not the case (yet?).</p>
</div>
<div class="paragraph">
<p>However, on 09 October 2000, the Java Community Process approved a
proposal to add generic types to Java that is largely based on GJ (JSR
14). A draft specification was submitted for public review, which closed
on 01 August 2001, and a prototype implementation has been released by
Sun.</p>
</div>
<div class="paragraph">
<p>We are committed to moving very rapidly to add support for generic types
in AspectJ when generic types become part of the Java language
specification. Everyone on the AspectJ team is looking forward to this,
because we too would really like to be able to write code that includes
both aspects and generic types.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> Can I use AspectJ with J2ME?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> The J2ME platform has several different components. The diagram
below shows how the different profiles build on top of the two
configurations CDC (Connected Device Configuration) and CLDC (Connected
Limited Device Configuration):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">    --------------
    |  Personal  |
    --------------      --------
    | Foundation |      | MIDP |
  ------------------  ------------------
  |      CDC       |  |      CLDC      |
------------------------------------------
|                 Java                   |
------------------------------------------</code></pre>
</div>
</div>
<div class="paragraph">
<p>Which configuration you have dictates the restrictions when running
AspectJ compiled programs.</p>
</div>
<div class="paragraph">
<p>If you&#8217;re running with a profile which sits on top of CDC then there are
not, as far as we are aware, any restrictions when running AspectJ
compiled code on this flavour of J2ME.</p>
</div>
<div class="paragraph">
<p>If you&#8217;re running with a profile sitting on top of CLDC 1.1 you are
currently unable to use the <code>thisJoinPoint,
            thisJoinPointStaticPart</code> and `
            thisEnclosingJoinPointStaticPart` variables, the <code>cflow</code> and
<code>cflowbelow</code> pointcuts and the <code>percflow</code> and `
            percflowbelow` perClauses.</p>
</div>
<div class="paragraph">
<p>Finally, if you&#8217;re running with a profile which sits on top of CLDC 1.0
you have all the restrictions of CLDC 1.1. There may be further
restrictions due to the lack of types corresponding to the primitive
types (e.g. Integer.TYPE), however, at the time of writing we have been
unable to do any extensive testing on this.</p>
</div>
<div class="paragraph">
<p>Note that the aspectj runtime jar is now (as of AspectJ5) quite large
but only a small subset is required for executing code in J2ME
environments. We plan to ship a second aspectjrt.jar built for the J2ME
environment at some point.</p>
</div>
<div class="paragraph">
<p>For more discussion and to raise any issues you have with AspectJ and
J2ME, refer to
<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=92933">bugzilla entry
92933</a>.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> Are you working to put AOP into Java? It seems that every AOP
toolset currently uses proprietary mechanisms to describe point-cuts,
etc.</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> We are working on standardization, but it&#8217;s a question of
timing/ripeness (imagine going from thousands of users to millions).
(See #q:standardization[Q:What are your plans to make AspectJ a general
feature of Java supported by Sun and the other key-players in the Java
Industry?].) We believe AspectJ addresses this question in the best way
possible now:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It&#8217;s open-source. Rather than being proprietary or controlled by a
vendor, it&#8217;s available for anybody to use and build upon, forever.</p>
</li>
<li>
<p>AspectJ is not a set of mechanisms, it&#8217;s a language. It is currently
implemented using certain techniques, but there&#8217;s nothing that prevents
it from being implemented with other techniques. That means users can
adopt the language with confidence that implementations will get better.</p>
</li>
<li>
<p>There is no engineering need to change Java. The AspectJ language uses
the join point model already in Java, so there is no need to extend the
programming model. Our implementation produces valid Java bytecode,
which runs in any compliant J2SE VM and supports standard debuggers for
those VM&#8217;s that support JSR-45 (debugging support for
multi-language/multi-file sources). This is a huge benefit to Sun since
Sun must be extremely cautious about extensions to the language or VM;
before adopting AOP, Sun should demand the kind of actual-proof that
AspectJ implementations offer.</p>
</li>
<li>
<p>On the issue of "proprietary mechanisms to describe pointcuts, etc.":
Any AOP has to have some language to describe pointcuts and the like
("pointcuts" of course being the AspectJ term). Users would like to have
one language (to avoid having to learn or transform between many
languages) and the choice of multiple implementations (tailored for a
configuration, subject to competitive pressure, etc.). That&#8217;s what
AspectJ offers.</p>
</li>
<li>
<p>That said, we believe the AspectJ extensions to Java could form the
basis for bringing AOP to Java; when that happens, there will be
engineering opportunities to make the implementation and tool support
better.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Q:</strong> What kind of support is available?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> The mailing lists provide the primary support for everyone in the
community (See #q:mailingLists[Q: What mailing lists are there?]). To
request commercial support, tutorials, or presentations, use the
developer mailing list, <code>aspectj-dev@eclipse.org</code>.</p>
</div>
<div class="paragraph">
<p>To find out about known issues, see the
<a href="progguide/implementation.html">AspectJ Programming Guide Appendix,
"Implementation Notes"</a> and the AspectJ bugs in the database at
<a href="https://bugs.eclipse.org/bugs" class="bare">https://bugs.eclipse.org/bugs</a> (using the product <code>AspectJ</code>). Here are
direct links to
<a href="https://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler&amp;bug_status=UNCONFIRMED&amp;bug_status=NEW&amp;bug_status=ASSIGNED&amp;bug_status=REOPENED">view
open compiler bugs</a>,
<a href="https://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ">view all
Aspectj bugs (open or closed)</a>, or
<a href="https://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ">add new
bugs</a>.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> What mailing lists are there?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> The AspectJ users mailing list (<code>aspectj-users@eclipse.org</code>)
provides an informal network of AspectJ language users who can answer
usage questions about AspectJ programs and the AspectJ tools. This is
the place to ask how to code something in AspectJ or how to write Ant or
shell scripts to invoke the tools.</p>
</div>
<div class="paragraph">
<p>The AspectJ developers mailing list (<code>aspectj-dev@eclipse.org</code>) provides
an informal network of AspectJ technology experts who aim to understand
the technology behind AspectJ. The committers to the AspectJ project use
this list for open technical and planning discussions. Developers can
answer questions about what&#8217;s possible and about integrating AspectJ
technology with other technologies.</p>
</div>
<div class="paragraph">
<p>For both mailing lists, only subscribed members may post messages. To
subscribe, visit the <a href="https://eclipse.org/aspectj">AspectJ web site</a>.</p>
</div>
<div class="paragraph">
<p>There you can also subscribe to <code>aspectj-announce@eclipse.org</code>, a
low-traffic list containing only announcements about significant AspectJ
events and product releases.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="compiler">Using the AspectJ compiler</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Q:</strong> Do I have to use the AspectJ compiler?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> The AspectJ compiler or weaver is required at some point, but many
people can use AspectJ without changing their build or deployment
process significantly. For aspects that are not required to compile, you
can use the AspectJ binary weaver, run at build-time or class-load-time.
You can write aspects using the original code style (which must be
compiled with the AspectJ compiler) or using the annotation style new in
AspectJ 5 (which may be compiled with Javac or the AspectJ compiler).</p>
</div>
<div class="paragraph">
<p>For more information, see #q:codeversusannotationstyles[Q:Should I use
code- or annotation-style aspects?].</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> What files do I need to include when compiling AspectJ programs?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> You need to specify to the compiler the files that contain your
aspects and the files that contain the types affected by your aspects.
See #q:knowWhenAspectsAffectClasses[Q: How do I know which aspects
affect a class when looking at that class&#8217;s source code?]. The AspectJ
compiler will not search the source path for types that may be affected
(unlike Javac and Jikes). In AspectJ 1.0, ajc requires all code to be in
source form; in AspectJ 1.1, Java and AspectJ code may be in either
source or binary form.</p>
</div>
<div class="paragraph">
<p>In some cases you should compile your entire system all at once. If this
is too slow, then you can try to make reasonable divisions between sets
of source files whose aspects do not interact to achieve a shorter
compile cycle (particularly for development aspects). If you have
aspects that apply to different modules, you can try compiling them into
a binary form and using them to weave each module. However, if you get
any problems or if you wish to run tests or do a release, you should
recompile the entire system.</p>
</div>
<div class="paragraph">
<p>For more information, see the <a href="devguide/index.html">Development
Environment Guide</a> <a href="devguide/ajc-ref.html">Reference for ajc</a>.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> I have to list many files in the command line to compile with
<code>ajc</code>. Is there any other way to provide the file names to <code>ajc</code>?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> Yes, use the argfile option to ajc. List source files in a
line-delimited text file and direct ajc to that file using <code>-argfile</code> or
<code>@</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">ajc @sources.lst
ajc -argfile sources.lst</code></pre>
</div>
</div>
<div class="paragraph">
<p>Another way in AspectJ 1.1 is to use the <code>-sourceroots</code> options, which
reads all source files in a given set of directories:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">ajc -sourceroots &quot;src;testsrc&quot;</code></pre>
</div>
</div>
<div class="paragraph">
<p>For more information, see the <a href="devguide/index.html">Development
Environment Guide</a> <a href="devguide/ajc-ref.html">Reference for ajc</a>.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> What Java virtual machine (JVM) do I use to run the AspectJ
compiler?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> Use the latest, greatest, fastest JVM you can get your hands on for
your platform. The compiler&#8217;s performance is dependent on the
performance of the JVM it is running on, so the faster a JVM you can
find to run it on, the shorter your compile times will be. At a minimum
you need to use a Java 2 or later JVM to run the compiler (J2SE 1.3 for
AspectJ 1.1). We realize that this constraint can be a problem for users
who don&#8217;t currently have a Java 2 JVM available. We&#8217;re sorry for the
inconvenience, but we had to make the hard decision that the advantages
of being able to rely on Java 2 were worth the cost of losing a number
of developers who are working on platforms without Java 2 support. Here
is a list of starting places where you might find support for your
system.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://java.sun.com/j2se/">Java 2 Platform, Standard Edition</a></p>
</li>
<li>
<p><a href="https://www-106.ibm.com/developerworks/java/jdk/">developerWorks : Java
technology : Tools and products - Developer kits</a></p>
</li>
<li>
<p><a href="https://www-124.ibm.com/developerworks/oss/jikes/">developerWorks : Open
Source - Jikes Project</a></p>
</li>
<li>
<p><a href="https://java.sun.com/cgi-bin/java-ports.cgi">Java Platform Ports</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The requirement of Java 2 support is only for <em>running</em> the AspectJ
compiler. The AspectJ compiler can be used to build programs that will
run on Java 1.1 (or probably even on Java 1.0) systems. This means that
it can build programs that will run on Macintosh, FreeBSD, and applets
that will run in Internet Explorer and Netscape Navigator that are still
not yet Java 2 compliant.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> How can I use <code>ajc</code> to compile programs for a JVM that is different
from the one used to run it?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> <code>ajc</code> can be used to develop programs that are targeted at the Java
1.1 platform, even though the <code>ajc</code> compiler won&#8217;t run on that platform.
Here&#8217;s an example of using <code>ajc</code> in this sort of cross-compilation mode
(assuming a Windows platform with all the default installation
directories):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">ajc -target 1.1 -bootclasspath c:\jdk1.1.7\lib\classes.zip \
   -classpath c:\aspectj1.0\lib\aspectjrt.jar -extdirs &quot;&quot; \
   -argfile jdk11system.lst</code></pre>
</div>
</div>
<div class="paragraph">
<p>This same technique can be used if you want to run <code>ajc</code> on a JDK 1.3
JVM (highly recommended) but need to generate code for JDK 1.2. That
would look something like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">ajc -bootclasspath c:\jdk1.2\jre\lib\rt.jar \
   -classpath c:\aspectj1.0\lib\aspectjrt.jar \
    -extdirs c:\jdk1.2\jre\lib\ext
            -argfile jdk12system.lst</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Q:</strong> Does the <code>ajc</code> compiler support the <code>assert</code> keyword in Java 1.4?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> Yes. As with <code>Javac</code>, use the <code>-source 1.4</code> option as described in
the <a href="devguide/index.html">Development Environment Guide</a>
<a href="devguide/ajc-ref.html">Reference for ajc</a>.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> Does the <code>ajc</code> compiler support generics and the other new language
features of Java 5?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> Yes. As with <code>Javac</code>, use the <code>-1.5</code> option as described in the
<a href="devguide/index.html">Development Environment Guide</a>
<a href="devguide/ajc-ref.html">Reference for ajc</a>.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> Will aspects work with different versions of the compiler/weaver
and runtime?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> Yes. Both <code>ajc</code> and <code>aspectjrt.jar</code> should work with versions of
aspect code and libraries back to AspectJ 1.2.1. Any aspects should be
deployed with the same version of <code>aspectjrt.jar</code> they were compiled
with. For more information, see the <a href="devguide/index.html">Development
Environment Guide</a> <a href="devguide/ajc-ref.html">Reference for ajc</a> and
<a href="devguide/deployment.html">Deployment notes</a> section on
<a href="devguide/versionCompatibility.html">Version compatibility</a>.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> Are there any issues using AspectJ with the Microsoft JVM?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> Since AspectJ requires Java 2 or later, it will not run on the
Microsoft JVM, which does not support Java 2.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> Does <code>ajc</code> rely on <code>javac</code> for generating Java bytecode (<code>.class</code>)
files?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> No. Some previous versions of AspectJ had this requirement. In
AspectJ 1.0, <code>javac</code> can still be used as <code>ajc</code> back end by using the
<code>-usejavac</code> flag. You can also run <code>ajc</code> in preprocessor mode to
generate Java source (<code>.java</code>) files to be compiled using <code>javac</code> or
another java compiler. Neither option is supported in AspectJ 1.1.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> I noticed the AspectJ compiler doesn&#8217;t use a parser generator. Why
is that?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> In AspectJ 1.0, the PARSER for ajc is written by hand. This choice
was made with full awareness of the generator tools out there. (Jim had
for example used the excellent javacc tool for building the parser for
JPython (now Jython)). One of the reasons that AspectJ uses a
hand-written parser is that using javacc taught Jim about the LL-k
design for parsers (pioneered by antlr). As opposed to the state-machine
parsers produced by yacc, these parsers are very readable and writable
by humans.</p>
</div>
<div class="paragraph">
<p>Antlr and javacc did not really suit the project:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Antlr&#8217;s support for unicode in the lexer is still immature and this
makes using it with Java challenging. This was an even bigger issue 3
years ago when we started on the Java implementation of ajc.</p>
</li>
<li>
<p>While javacc is freely available, it is not Open Source. Depending on
a closed-source tool to build an Open Source compiler would reduce some
of the transparency and control of open-source.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There were also several things that were easier to implement with a
hand-written parser than with any of the exiting tools.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Semi-keywords&#8201;&#8212;&#8201;it&#8217;s important to us that "every legal Java program
is also a legal AspectJ program." This wouldn&#8217;t be true if we made
'before' and 'call' full keywords in AspectJ. It is easier to support
these sorts of semi-keywords with a hand-written parser. (Note:
ajc-1.0.x handles 'aspect' and 'pointcut' slightly specially which can
break a few unusual pure Java programs. This is a compiler limitation
that will be fixed in a future release.)</p>
</li>
<li>
<p>Deprecated syntax warnings&#8201;&#8212;&#8201;the syntax of AspectJ changed many times
from version 0.2 to the 1.0 release. It was easier to provide helpful
warning messages for these changes with our hand-written parser.</p>
</li>
<li>
<p>Grammar modularity&#8201;&#8212;&#8201;We like being able to have AspectJParser extend
JavaParser.</p>
</li>
<li>
<p>Part of the grammar for AspectJ is extremely hard for existing tools
to capture. This is the type pattern syntax, i.e. "com.xerox..<strong>.</strong>(..)".
The sort of case that gives standard parser generators fits is something
like "*1.f(..)" which no one would ever write, but which must be
supported for a consistent language.</p>
<div class="paragraph">
<p>In AspectJ 1.1, the parser was written as it is for the underlying
Eclipse compiler, with some hand-coding of the sort that avoids adding
keywords to the language.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Q:</strong> How does incremental mode work?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> In incremental mode, ajc minimizes the files that need to be
recompiled after another file has changed. In Java, only the changed
files need to be recompiled, but in AspectJ, other files might also need
to be recompiled or re-woven.</p>
</div>
<div class="paragraph">
<p>Depending on what is modified, we may need to re-weave code.  If you
change a pointcut and save it, we currently have to check everywhere in
case a new match is occurring or an old match is no longer correct.
 However, if you simply change the body of an advice in an aspect, there
is (usually) no need to reweave as the affected classes call the advice
and the advice (by design) maintains its name in the recompiled aspect.</p>
</div>
<div class="paragraph">
<p>If you make a change to a class (as opposed to an aspect) and save it,
we usually can get away with merely having to compile that class then
weave the existing aspects with it - rather than doing a full recompile
of the entire system.</p>
</div>
<div class="paragraph">
<p>There are a lot of possible optimizations to the algorithms we use, by
performing more complete analysis of the change made to a file that will
enable us to know more accurately whether we need to reweave and if we
do then what we need to reweave - we just haven&#8217;t gotten around to
implementing them yet.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="devtools">Integrating AspectJ into your development environment</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Q:</strong> How do I know which aspects affect a class when looking at that
class&#8217;s source code?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> When you are working with the IDE support, you can get an
understanding of which aspects affect any class. This enables AspectJ
programmers to get the benefits of modularizing crosscutting concerns
while still having immediate access to what aspects affect a class.</p>
</div>
<div class="paragraph">
<p>For example, the <a href="devguide/index.html">Development Environment Guide</a>
shows that you can list
or navigate between method and advice affecting that method and between
a type and declarations in an aspect on that type. (The IDE support may
have more features than that, depending on the IDE. See
#q:integrateWithDevTools[Q: How well does AspectJ integrate with
existing Java development tools?] for more information on which Java
development environments are supported.)</p>
</div>
<div class="paragraph">
<p>When you are looking at documentation for AspectJ 1.0 programs, <code>ajdoc</code>
will provide links from aspects and advice to the affected code, but it
provides less information than the IDE support because it only parses
declarations.</p>
</div>
<div class="paragraph">
<p>When you are compiling your program, pointcuts that are
statically-determinable can be used in declare statements to identify
the code picked out by the pointcut. (A pointcut is statically
determinable if it only uses the pointcut designators <code>within</code>,
<code>withincode</code>, <code>execution</code>, <code>call</code>, <code>get</code>, <code>set</code>, <code>initialiation</code>, and
<code>staticinitialiation</code>.) The compiler will list the static code points
which will be affected by any advice specifying the same pointcut. For
example, the following will print a warning whereever some code in class
Bar gets a field value from Foo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">declare warning: get(* Foo.*) &amp;&amp; within(Bar)
   : <span class="string"><span class="delimiter">&quot;</span><span class="content">reading Foo state from Bar</span><span class="delimiter">&quot;</span></span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you are running your program, you can trace advice as it executes.
This enables you to identify advice on join points picked out
dynamically, which cannot be reflected precisely by IDE support. For a
related tracing question, see #q:seeingjoinpoints[Q:I don&#8217;t understand
what join points exist. How can I see them?]</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> What kind of IDE support is available for developing AspectJ
programs?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> See #q:integrateWithDevTools[Q: How well does AspectJ integrate
with existing Java development tools?]</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> What plans are there to support my IDE?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> The AspectJ team directly provided components for JBuilder, Forte,
and Emacs and supported the open-source AspectJ plugin project at
<a href="https://eclipse.org/ajdt" class="bare">https://eclipse.org/ajdt</a> which uses the AJDE API support for IDE&#8217;s.
Supporting new IDE&#8217;s is a matter of building on the AJDE API&#8217;s, mostly
likely adopting one of the existing open-source IDE extensions as a
design template. Here are the IDE&#8217;s where we know people have expressed
interest, so interested developer may want to join with others in their
developer communities to build the integration.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>IDEA/IntelliJ has an enthusiastic community and the developers are
working on an extensibility API - <a href="https://intellij.com" class="bare">https://intellij.com</a></p>
</li>
<li>
<p>jEdit comes from a very active open-source community.</p>
</li>
<li>
<p>Some have suggested Codeguide from Omnicore
<a href="https://www.omnicore.com">https://www.omnicore.com/</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For questions on AJDE, join the developer&#8217;s list
<code>aspectj-dev@eclipse.org</code>. For questions on the current IDE
integrations, contact those projects.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> Can I port AJDE support to my development environment?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> Yes. The core AJDE API is extensible and the source code is
available for download. Start by studying the sources for the existing
IDE support linked off the AspectJ site <a href="https://eclipse.org/aspectj" class="bare">https://eclipse.org/aspectj</a>.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> I want the aspects for development builds but remove them for
production builds. How can I set up the build system so they are
unpluggable? And so I use <code>javac</code> in my production build?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> If you are using development-time-only aspects - aspects that only
exist when you are developing the code, not when you ship it - you can
use implement a hybrid build process by listing the production source
files into a javac-compliant argfile, and the development source files
in another ajc argfiles:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">-- file &quot;production.lst&quot;:
One.java
two/Three.java
...

-- file &quot;tracing.lst&quot;:
trace/Library.java
Trace.java

-- file &quot;development.lst&quot;:
@production.lst
@tracing.lst</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then your development build can use <code>ajc</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">ajc @development.lst</code></pre>
</div>
</div>
<div class="paragraph">
<p>And your development build can use <code>ajc</code> or <code>javac</code> or <code>jikes</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">jikes @production.lst</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Q:</strong> We compile module jars and then assemble them. Can we continue this
with AspectJ?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> Aspects apply to everything in a namespace, as if everything is
compiled together. Sometimes you can break the build down into separate
steps without breaking this model, but we haven&#8217;t stated exactly where
it could break because it depends on the interactions between all types.
You can try the approaches below, but remember to rebuild everything in
one go if there are problems.</p>
</div>
<div class="paragraph">
<p>The simplest scenario is when the aspects apply to all modules and the
modules compile without the aspects. In that case, weaving in the
aspects is just the final assembly step for the build.</p>
</div>
<div class="paragraph">
<p>Next is the case where the aspects make changes to a common library that
are visible to other clients, which themselves are otherwise unaffected
by the aspects. In this case, the common library can be built using ajc,
and used on the classpath for the module builds:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">ajc -outjar common.jar -sourceroots &quot;aspectj-src:src&quot; ...
cd ../otherProject
javac -classpath &quot;../common/common.jar:${aspectjrt.jar}&quot; {src}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Combining these last two, there&#8217;s the case where a common set of aspects
should affect two or more modules that are in a dependency relationship
to one another. It should work to reuse the aspects in binary form for
each compile, in dependency order:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">ajc -outjar common-aspects.jar
    -sourceroots &quot;aspectj-src&quot; ...

ajc -outjar common.jar
    -sourceroots &quot;src&quot;
    -aspectpath common-aspects.jar ...

cd ../module1
ajc -outjar module1.jar
    -sourceroots &quot;src&quot;
    -classpath common.jar
    -aspectpath ../common-aspects.jar ...

cd ../module2
ajc -outjar module2.jar
    -sourceroots &quot;src&quot;
    -classpath &quot;common.jar;../module1.jar&quot;
    -aspectpath ../common-aspects.jar ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>If two modules are visibly affected by aspects and mutually-dependent,
the only thing to do is compile them together.</p>
</div>
<div class="paragraph">
<p>It&#8217;s safest to assume that all aspects can affect all types in a
namespace; using build boundaries to effect crosscutting limits causes a
dangerous dependency on the build process and might cause problems.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> We use modules and would like to use incremental compilation. Is
that possible?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> Just incrementally-compile the whole system. Specify to ajc the
modules as multiple source roots (or input jars if you are weaving
libraries).</p>
</div>
<div class="paragraph">
<p>In Eclipse&#8217;s AJDT, you can create a top-level project with symbolic
links out to the sources:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">app-assembly/
{link common/aspects}
{link common/src}
{link module1/src}
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then everything is part of one huge incremental compile. Also, you can
close this master project and work the others using the Java compiler or
AJDT.</p>
</div>
<div class="paragraph">
<p>The links make incremental development possible without affecting the
modularized Ant builds. (Our practice runs along those lines.)</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="notes">Programming notes and tips</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Q:</strong> Is it possible to change methods by introducing keywords (like
<code>synchronized</code>), adding parameters, or changing the "throws" clause?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> AspectJ does not enable you to change the signature of a method,
but you can (by express declaration) work around some limits imposed by
the signature. You can convert a checked exception to unchecked using
<code>declare soft</code>, privileged aspects have access to private methods, and
you can use a percflow aspect to ferry additional state to a callee
without changing intervening signatures. For more details, see
<a href="progguide/index.html">The AspectJ Programming Guide</a>. In the case of
<code>synchronized</code>, we have what we consider a better solution that uses
around advice instead of introduction. This solution is described in
<a href="https://aspectj.org/pipermail/users/2000/000534.html">this thread (no
longer available)</a> on the AspectJ users list, with some
<a href="https://aspectj.org/pipermail/users/2000/000536.html">additional comments
(no longer available)</a> .</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> I don&#8217;t understand what join points exist. How can I see them?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> You can trace them using using an aspect. For example, you can
start logging at a particular method call and see what join points occur
after the call and before it returns.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s some code Jim Hugunin wrote to trace join points and posted to
the users list. To reuse the aspect, define a subaspect and implement
the pointcuts, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect JoinPointSampleAspect <span class="directive">extends</span> aj.TraceJoinPoints {
    <span class="directive">protected</span> pointcut entry() :
        execution(<span class="directive">static</span> <span class="type">void</span> JoinPointSample.main(<span class="predefined-type">String</span><span class="type">[]</span>));
    <span class="directive">protected</span> pointcut exit() :
        call(<span class="directive">static</span> <span class="type">void</span> JoinPointSampleAspect.exit());

    <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main (<span class="predefined-type">String</span><span class="type">[]</span> args) {
        JoinPointSample.main(args);
        JoinPointSampleAspect.exit();
    }
    <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> exit() {}
}

<span class="type">class</span> <span class="class">JoinPointSample</span> {
    <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here&#8217;s the aspect:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">/* TraceJoinPoints.java */</span>

<span class="keyword">package</span> <span class="namespace">aj</span>;

<span class="keyword">import</span> <span class="include">org.aspectj.lang</span>.*;
<span class="keyword">import</span> <span class="include">org.aspectj.lang.reflect</span>.*;
<span class="keyword">import</span> <span class="include">java.io</span>.*;

<span class="directive">public</span> <span class="directive">abstract</span> aspect TraceJoinPoints {
    <span class="directive">protected</span> <span class="directive">abstract</span> pointcut entry();
    <span class="directive">protected</span> pointcut exit(): call(* java..*.*(..));
    <span class="comment">// this line is for AspectJ 1.1; for 1.0, use &quot;dominates&quot;</span>
    declare precedence : TraceJoinPoints, *;
    <span class="directive">final</span> pointcut start(): entry() &amp;&amp; !cflowbelow(entry());

    <span class="directive">final</span> pointcut trace():
        cflow(entry()) &amp;&amp; !cflowbelow(exit()) &amp;&amp; !within(TraceJoinPoints+);

    before(): start() { makeLogStream(); }

    before(): trace() { logEnter(thisJoinPointStaticPart); }
    after(): trace() { logExit(thisJoinPointStaticPart); }

    after(): start() { closeLogStream(); }

    <span class="comment">//------------ added</span>
    <span class="comment">/**
     * Emit a message in the log, e.g.,
     * &lt;pre&gt;TraceJoinPoints tjp = TraceJoinPoints.aspectOf();
     * if (null != tjp) tjp.message(&quot;Hello, World!&quot;);&lt;/pre&gt;
     */</span>
    <span class="directive">public</span> <span class="type">void</span> message(<span class="predefined-type">String</span> s) {
        out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">&lt;message&gt;</span><span class="delimiter">&quot;</span></span> + prepareMessage(s) + <span class="string"><span class="delimiter">&quot;</span><span class="content">&lt;/message&gt;</span><span class="delimiter">&quot;</span></span>);
    }
    <span class="directive">public</span> <span class="type">void</span> message(<span class="predefined-type">String</span> sink, <span class="predefined-type">String</span> s) {
        <span class="keyword">if</span> (<span class="predefined-constant">null</span> == sink) {
            message(s);
        } <span class="keyword">else</span> {
            out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">&lt;message sink=</span><span class="delimiter">&quot;</span></span> + quoteXml(sink)
                        + <span class="string"><span class="delimiter">&quot;</span><span class="content"> &gt;</span><span class="delimiter">&quot;</span></span> + prepareMessage(s) + <span class="string"><span class="delimiter">&quot;</span><span class="content">&lt;/message&gt;</span><span class="delimiter">&quot;</span></span>);
        }
    }
    <span class="directive">protected</span> <span class="predefined-type">String</span> prepareMessage(<span class="predefined-type">String</span> s) { <span class="keyword">return</span> s; } <span class="comment">// XXX implement</span>

    <span class="comment">//--------- end of added</span>

    <span class="predefined-type">PrintStream</span> out;
    <span class="type">int</span> logs = <span class="integer">0</span>;
    <span class="directive">protected</span> <span class="type">void</span> makeLogStream() {
        <span class="keyword">try</span> {
            out = <span class="keyword">new</span> <span class="predefined-type">PrintStream</span>(<span class="keyword">new</span> <span class="predefined-type">FileOutputStream</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">log</span><span class="delimiter">&quot;</span></span> + logs++ + <span class="string"><span class="delimiter">&quot;</span><span class="content">.xml</span><span class="delimiter">&quot;</span></span>));
        } <span class="keyword">catch</span> (<span class="exception">IOException</span> ioe) {
            out = <span class="predefined-type">System</span>.err;
        }
    }

    <span class="directive">protected</span> <span class="type">void</span> closeLogStream() {
        out.close();
    }


    <span class="type">int</span> depth = <span class="integer">0</span>;
    <span class="type">boolean</span> terminal = <span class="predefined-constant">false</span>;
    <span class="directive">protected</span> <span class="type">void</span> logEnter(JoinPoint.StaticPart jp) {
        <span class="keyword">if</span> (terminal) out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">&gt;</span><span class="delimiter">&quot;</span></span>);
        indent(depth);
        out.print(<span class="string"><span class="delimiter">&quot;</span><span class="content">&lt;</span><span class="delimiter">&quot;</span></span> + jp.getKind());
        writeSig(jp);
        writePos(jp);

        depth += <span class="integer">1</span>;
        terminal = <span class="predefined-constant">true</span>;
    }

    <span class="type">void</span> writeSig(JoinPoint.StaticPart jp) {
        out.print(<span class="string"><span class="delimiter">&quot;</span><span class="content"> sig=</span><span class="delimiter">&quot;</span></span>);
        out.print(quoteXml(jp.getSignature().toShortString()));
    }

    <span class="type">void</span> writePos(JoinPoint.StaticPart jp) {
        SourceLocation loc = jp.getSourceLocation();
        <span class="keyword">if</span> (loc == <span class="predefined-constant">null</span>) <span class="keyword">return</span>;

        out.print(<span class="string"><span class="delimiter">&quot;</span><span class="content"> pos=</span><span class="delimiter">&quot;</span></span>);
        out.print(quoteXml(loc.getFileName() +
                           <span class="string"><span class="delimiter">&quot;</span><span class="content">:</span><span class="delimiter">&quot;</span></span> + loc.getLine() +
                           <span class="string"><span class="delimiter">&quot;</span><span class="content">:</span><span class="delimiter">&quot;</span></span> + loc.getColumn()));
    }

    <span class="predefined-type">String</span> quoteXml(<span class="predefined-type">String</span> s) {
        <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="char">\&quot;</span><span class="delimiter">&quot;</span></span> + s.replace(<span class="string"><span class="delimiter">'</span><span class="content">&lt;</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">_</span><span class="delimiter">'</span></span>).replace(<span class="string"><span class="delimiter">'</span><span class="content">&gt;</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">_</span><span class="delimiter">'</span></span>) + <span class="string"><span class="delimiter">&quot;</span><span class="char">\&quot;</span><span class="delimiter">&quot;</span></span>;
    }

    <span class="directive">protected</span> <span class="type">void</span> logExit(JoinPoint.StaticPart jp) {
        depth -= <span class="integer">1</span>;
        <span class="keyword">if</span> (terminal) {
            out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">/&gt;</span><span class="delimiter">&quot;</span></span>);
        } <span class="keyword">else</span> {
            indent(depth);
            out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">&lt;/</span><span class="delimiter">&quot;</span></span> + jp.getKind() + <span class="string"><span class="delimiter">&quot;</span><span class="content">&gt;</span><span class="delimiter">&quot;</span></span>);
        }
        terminal = <span class="predefined-constant">false</span>;
    }

    <span class="type">void</span> indent(<span class="type">int</span> i) {
        <span class="keyword">while</span> (i-- &gt; <span class="integer">0</span>) out.print(<span class="string"><span class="delimiter">&quot;</span><span class="content">  </span><span class="delimiter">&quot;</span></span>);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that if you are using AspectJ 1.0, the line starting with
<code>declare precedence</code> would be removed, and the aspect declaration would
look like <code>aspect TraceMyJoinPoints dominates *</code>.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> What is the difference between call and execution join points?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> Briefly, there are two interesting times when a constructor or
method is run. Those times are when it is called, and when it actually
executes.</p>
</div>
<div class="paragraph">
<p>The main difference is that a call join point happens outside of the
target object (for non-static methods) or class (for static methods and
constructors), and that an execution join point happens inside the
object or class. This means that the <code>within</code> and <code>withincode</code> pointcuts
pick them out differently: A call join point is picked out within the
caller, while an execution join point is picked out where it is actually
defined.</p>
</div>
<div class="paragraph">
<p>A call join point is the ``outermost'' join point for a particular call.
Once a call join point proceeds, then a number of different things
happen. For non-static methods, for example, method dispatch happens,
which will cause one method execution join point&#8201;&#8212;&#8201;perhaps more, if
there are super calls. For constructors, the super constructor is
called, and fields are initialized, and then various constructor
execution join points will occur.</p>
</div>
<div class="paragraph">
<p>A call join point matches only the <code>`external'' calls of a method or
constructor, based on a signature, and it does not pick out calls made
with `super</code>, or <code>this</code> constructor calls.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s more detail:</p>
</div>
<div class="paragraph">
<p>Consider method execution in Java as (1) the initial call from this
object to some method on the target object with a particular signature;
and (2) the execution of the actual code in the particular method
dispatched in the target object. The call join point starts with the
initial call and ends when control returns to the call (by return or
perhaps thrown exception). The execution join point starts with the
method body and ends when the body completes (again by return or
throwing an exception), so the execution join point always happens
within the bounds of the corresponding call join point. You can see this
if you use the join-point tracing aspect in see #q:seeingjoinpoints[Q:I
don&#8217;t understand what join points exist. How can I see them?].</p>
</div>
<div class="paragraph">
<p>As you would expect, the context differs in advice on pointcuts picking
out execution and call join points; for call, <code>this</code> refers to the
caller, whereas for execution <code>this</code> refers to the called (executing)
object.</p>
</div>
<div class="paragraph">
<p>There are some subtle interactions with other AspectJ semantics. First,
the meaning of the signature in the <code>execution()</code> and <code>call()</code> pointcut
designators (PCD&#8217;s) differ: the call type depends upon the type of the
reference making the call, while the execution type depends on the
enclosing class. Second, you may choose one over another if you cannot
bring all your sources within the code the compiler controls (described
in the <a href="progguide/semantics.html">appendix</a> to the
<code>Programming Guide</code>). For example, to trace calls into a method from
classes which are outside the code the compiler controls at compile
time, then using <code>execution()</code> will work while using <code>call()`may not.
Finally, since `super</code> invocations are not considered method calls, to
trace <code>super.foo()</code> would require using <code>execution</code>.</p>
</div>
<div class="paragraph">
<p>Because of differences in the way AspectJ 1.0 and 1.1 are implemented,
in 1.0 you should use the <code>call()</code> pointcut designator unless you have a
good reason to use <code>execution()</code>; in AspectJ 1.1, the reverse is true.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> What is the difference between cflow and cflowbelow?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> Both pick out all the join points in the control flow of the
specified join points. They differ only in that the <code>cflowbelow()</code>
pointcut designator does not pick out the join points specified, while
<code>cflow()</code> does.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> How do I say that I want the topmost entrypoint in a recursive
call? How about the most-recent prior entrypoint?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> This is best seen by way of example. Given a recursive call to
<code>int factorial(int)</code> you can print the arguments for (a) the current and
most-recent recursive call or (b) the current and original recursive
call:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect LogFactorial {
    pointcut f(<span class="type">int</span> i) : call(<span class="type">int</span> factorial(<span class="type">int</span>)) &amp;&amp; args(i);

    <span class="comment">// most-recent</span>
    before(<span class="type">int</span> i, <span class="directive">final</span> <span class="type">int</span> j) : f(i) &amp;&amp; cflowbelow(f(j)) {
        <span class="predefined-type">System</span>.err.println(i + <span class="string"><span class="delimiter">&quot;</span><span class="content">-</span><span class="delimiter">&quot;</span></span> + j);
    }

    <span class="comment">// original</span>
    before(<span class="type">int</span> i, <span class="directive">final</span> <span class="type">int</span> j) : f(i)
        &amp;&amp; cflowbelow(cflow(f(j)) &amp;&amp; !cflowbelow(f(<span class="type">int</span>))) {
        <span class="predefined-type">System</span>.err.println(i + <span class="string"><span class="delimiter">&quot;</span><span class="content">@</span><span class="delimiter">&quot;</span></span> + j);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Q:</strong> What is the difference between constructor call, constructor
execution, initialization, and static initialization join points?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> Static initialization pertains to initialization of a class or
interface type. Constructor call and execution are akin to method call,
and initialization generalizes this and picks out the first constructor
called.</p>
</div>
<div class="paragraph">
<p>Their relations are best demonstrated by tracing the join points. Below
is the class Test which implements an interface and extends a class
along with a trace of the join points below and including the
constructor call obtained using <code>TraceJointPoints.java</code> from
#q:seeingjoinpoints[Q:I don&#8217;t understand what join points exist. How can
I see them?].</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Init</span> {
    <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main (<span class="predefined-type">String</span><span class="type">[]</span> args) {
        <span class="keyword">new</span> Test();
        end();
    }
    <span class="directive">static</span> <span class="type">void</span> end() {}
}
<span class="type">class</span> <span class="class">Super</span> {}
<span class="type">interface</span> <span class="class">I</span> {}
<span class="type">class</span> <span class="class">Test</span> <span class="directive">extends</span> Super <span class="directive">implements</span> I {
    Test() {}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For a program compiled with AspectJ 1.0, the result is this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;constructor-call</span> <span class="attribute-name">sig</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Test()</span><span class="delimiter">&quot;</span></span> <span class="tag">&gt;</span>
  <span class="tag">&lt;staticinitialization</span> <span class="attribute-name">sig</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Super._init_</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
  <span class="tag">&lt;staticinitialization</span> <span class="attribute-name">sig</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Test._init_</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
  <span class="tag">&lt;initialization</span> <span class="attribute-name">sig</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Super()</span><span class="delimiter">&quot;</span></span> <span class="tag">&gt;</span>
    <span class="tag">&lt;instanceinitializer-execution</span> <span class="attribute-name">sig</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Super._init_</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
    <span class="tag">&lt;constructor-execution</span> <span class="attribute-name">sig</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Super()</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
  <span class="tag">&lt;/initialization&gt;</span>
  <span class="tag">&lt;initialization</span> <span class="attribute-name">sig</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">I()</span><span class="delimiter">&quot;</span></span> <span class="tag">&gt;</span>
    <span class="tag">&lt;instanceinitializer-execution</span> <span class="attribute-name">sig</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">I._init_</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
    <span class="tag">&lt;constructor-execution</span> <span class="attribute-name">sig</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">I()</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
  <span class="tag">&lt;/initialization&gt;</span>
  <span class="tag">&lt;initialization</span> <span class="attribute-name">sig</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Test()</span><span class="delimiter">&quot;</span></span> <span class="tag">&gt;</span>
    <span class="tag">&lt;instanceinitializer-execution</span> <span class="attribute-name">sig</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Test._init_</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
    <span class="tag">&lt;constructor-execution</span> <span class="attribute-name">sig</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Test()</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
  <span class="tag">&lt;/initialization&gt;</span>
<span class="tag">&lt;/constructor-call&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Ordinarily, using a <code>call</code> pointcut designator is best because the call
join point surrounds the others, but in the case of constructors there
is no target object for the call (because it has not been constructed
yet), so you might prefer to use the <code>initialization</code> pointcut
designator.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> How do I work with an object right when it is created?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> You can advise some form of constructor join point. Constructors
are tricky in Java, and that&#8217;s exposed in AspectJ. Here are some rules
of thumb:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If you want the join point on the "outside" of object creation, use
after returning from call to the constructor:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">after() returning (Foo newlyCreatedObject): call(Foo.new(..)) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>You might be tempted to use "this" or "target" to expose the new object,
but remember that if you&#8217;re on the "outside" of object creation, the
object itself might not be created yet&#8230;&#8203; it only exists "on the way
out", when you return the object.</p>
</div>
</li>
<li>
<p>If you want the join point inside a particular constructor, use:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">after(Foo newlyCreatedObject) returning: <span class="local-variable">this</span>(newlyCreatedObject) &amp;&amp; execution(Foo.new(..)) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Remember, though, that if you use "before" advice here, the body of the
constructor will not have run, and so the object may be somewhat
uninitialized.</p>
</div>
</li>
<li>
<p>In the rare case that there are all sorts of constructors for the
object that call each other with <code>this(&#8230;&#8203;)</code> and you want exactly one
join point for each initialization of <code>Foo</code>, regardless of the path of
constructors it takes, then use:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">after(Foo f) returning: <span class="local-variable">this</span>(f) &amp;&amp; initialization(Foo.new(..)) { ... }</code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Q:</strong> I want advice to run at two join points, but it doesn&#8217;t run at all.
What gives?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> This usually reflects both a conceptual error and a programming
mistake. Most likely you want to do something like "run the advice for
all public and private calls," and the code looks something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">within(com.xerox.printing..*) &amp;&amp; call(<span class="directive">public</span> * *(..)) &amp;&amp; call(<span class="directive">private</span> * *(..))</code></pre>
</div>
</div>
<div class="paragraph">
<p>But a pointcut is evaluated at <strong>each</strong> join point. The expression above
would never pick out any call join point, because no method signature
has both public and private access. In a pointcut, <code>pc1() &amp;&amp; pc2()</code>
means both must be true at a given join point for advice to run at that
join point. The correct pointcut would use <code>||</code> as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">within(com.xerox.printing..*) &amp;&amp; (call(<span class="directive">public</span> * *(..)) || call(<span class="directive">private</span> * *(..)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then the advice will run at the join point.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> How do I refer to a static field when my advice crosscuts multiple
classes?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> There is no way in advice to refer to the type of the code
executing in a static context except by specification. This makes it
impossible to refer to static members using runtime information.</p>
</div>
<div class="paragraph">
<p>However, AspectJ can determine the class for something in the join point
context, which you can use as a per-class key. Then you can actually
declare an instance field to contain the per-class value (see the next
question). This comes at the cost of an extra reference, but the field
can be final.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> I would like to reuse a type pattern, e.g., to write advice that is
limited to a certain set of classes. Do I have to retype it each time?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> No. You can declare that all the types implement an interface you
define, and then use the interface type in your program. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">/**
 * Example of using an interface to represent a type pattern.
 * sub-aspects use declare parents to add to traced types, e.g.,
 *    declare parents: com.mycompany.whatever..* implements Marked;
 */</span>
<span class="directive">abstract</span> aspect MarkerExample {
  <span class="comment">/** marker interface for types that we want to trace */</span>
  <span class="type">interface</span> <span class="class">Marked</span> {}

  <span class="comment">/** calls to an instance of Marked not from an instance of Marked */</span>
  pointcut dynamicCallsIn(): call(* *(..)) &amp;&amp; target(Marked) &amp;&amp; !<span class="local-variable">this</span>(Marked);

  <span class="comment">/** calls to methods defined by a subtype of Marked
   *  that don't come from the body of a subtype of Marked
   */</span>
  pointcut staticCallsIn(): call(* Marked+.*(..)) &amp;&amp; !within(Marked+);

  <span class="comment">/** print dynamic calls */</span>
  before(): dynamicCallsIn() { <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">before </span><span class="delimiter">&quot;</span></span> + thisJoinPoint); }
}

aspect MyMarker <span class="directive">extends</span> MarkerExample {
  declare parents: com.mycompany.whatever..* <span class="directive">implements</span> Marked;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Q:</strong> Where do I find example programs and how-to&#8217;s?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> There are a number of places to find sample code and instructions
for using AspectJ with other programming tools.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The AspectJ release includes examples in its <code>doc</code> directory.</p>
</li>
<li>
<p>There is a community repository of sample code and tutorials in the
AspectJ CVS tree <code>docs</code> module <code>sandbox</code> directory. These are extracted
and published (online only)
<a href="https://dev.eclipse.org/viewcvs/indextech.cgi/<sub>checkout</sub>/aspectj-home/sample-code.html">here</a>
.</p>
</li>
<li>
<p>The <code>teaching</code> directory of the <code>docs</code> module contains public
materials the AspectJ committers use for presentations, some of which
include example code. To access CVS, see <a href="#buildingsource">Q:How do I
get and compile the source code for AspectJ?</a>.</p>
</li>
<li>
<p>The archives for the user and developer mailing lists contain many
good examples. To search the archives, see #q:searchingsite[Q:How can I
search the email archives or the web site?].</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This code can vary in quality. Code that we publish or include with
AspectJ is generally correct. However, code found in our CVS tree might
not have been tested thoroughly, and code from the mailing lists might
be untested or use older versions of the language.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> Are aspect libraries available?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> Some libraries are distributed in the release under the examples
folder in the distribution. These are "libraries" in the sense that they
are reusable, but they are delivered in source form. Similarly, some of
the sample code is reusable; for that, see #q:exampleprograms[Q:Where do
I find example programs and how-to&#8217;s?]. If you develop such a library
and want to make it available to other users, feel to send it to the
users mailing list <code>aspectj-users@eclipse.org</code>.</p>
</div>
<div class="paragraph">
<p>In AspectJ 1.1, ajc supports binary aspects, so you can distribute
aspect libraries without distributing the source. For more information,
see the <code>-aspectpath</code> option in the <a href="devguide/ajc-ref.html">Reference
for ajc</a>.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> How does <code>ajc</code> interact with the <code>serialVersionUID</code>?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> The current version of <code>ajc</code> can change the <code>serialVersionUID</code> of
generated <code>.class</code> files as a result of weaving in advice. This is an
important fact that developers using both aspects and serialization
should be aware of. It is likely that a future version of the compiler
will be better behaved regarding the <code>serialVersionUID</code>.</p>
</div>
<div class="paragraph">
<p>However, changes to the <code>serialVersionUID</code> attribute are typically only
important when using serialization for the long-term persistence of
objects. Using standard Java serialization for long-term persistence has
a number of drawbacks and many developers already use alternative
solutions. For one possibly standard solution, see
<a href="https://jcp.org/jsr/detail/057.jsp">Long-Term Persistence for JavaBeans
Specification</a> .</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> How can I use AspectJ with applets?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> Just include the aspectjrt.jar as a required archive. For example,
here is the HTML code for an HTML editor applet that contains some
debugging aspects:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;APPLET</span>
   <span class="attribute-name">CODE</span>=<span class="string"><span class="delimiter">'</span><span class="content">com.company.swing.applets.EditorApplet</span><span class="delimiter">'</span></span>
  <span class="attribute-name">WIDTH</span>=<span class="string"><span class="delimiter">'</span><span class="content">700</span><span class="delimiter">'</span></span>
 <span class="attribute-name">HEIGHT</span>=<span class="string"><span class="delimiter">'</span><span class="content">525</span><span class="delimiter">'</span></span><span class="tag">&gt;</span>
    <span class="tag">&lt;PARAM</span> <span class="attribute-name">NAME</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">CODE</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">VALUE</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.company.swing.applets.EditorApplet</span><span class="delimiter">&quot;</span></span> <span class="tag">&gt;</span>
    <span class="tag">&lt;PARAM</span> <span class="attribute-name">NAME</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">ARCHIVE</span><span class="delimiter">&quot;</span></span>
         <span class="attribute-name">VALUE</span> =<span class="string"><span class="delimiter">&quot;</span><span class="content">../company-applets.jar,../aspectjrt.jar,../xmlrpc-applet.jar</span><span class="delimiter">&quot;</span></span> <span class="tag">&gt;</span>
    <span class="tag">&lt;PARAM</span> <span class="attribute-name">NAME</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">VALUE</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">application/x-java-applet;version=1.4</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
    <span class="tag">&lt;PARAM</span> <span class="attribute-name">NAME</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">scriptable</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">VALUE</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">false</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
<span class="tag">&lt;/APPLET&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The above markup has worked reliably with the Java Plugin (included in
the JRE 1.4.x) in IE 6, Mozilla 1.1 (Win32), and Mozilla 1.0.1 (Red Hat
Linux 8.0). The following link describes how to configure
Mozilla/Netscape 6.x/7.x to use the Java Plugin from a JRE/SDK
installation: <a href="https://java.sun.com/j2se/1.4.1/manual_install_linux.html" class="bare">https://java.sun.com/j2se/1.4.1/manual_install_linux.html</a>.
(Thanks to Chris Bartling for this answer.)</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> How can I specify types for advice that captures primitives, void,
etc.?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> In some cases, AspectJ allows conversion from values of primitive
types to Object, so that highly polymorphic advice may be written. This
works if an advice parameter or the return type for around is typed to
Object. So:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">Test</span> {
    <span class="directive">static</span> <span class="type">int</span> i;
    <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
        i = <span class="integer">37</span>;
    }
}

aspect TraceSet {
    before(<span class="predefined-type">Object</span> val): set(* Test.*) &amp;&amp; args(val) {
        <span class="predefined-type">System</span>.err.println(val);
        <span class="predefined-type">System</span>.err.println(val.class);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>will print out</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">37
java.lang.Integer</code></pre>
</div>
</div>
<div class="paragraph">
<p>For more information, see the Programming Guide
<a href="progguide/semantics-pointcuts.html">semantics section "Context
Exposure"</a> .</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> How do I detect which version I am running?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> The <code>ajc</code> compiler emits the version when passed the <code>-version</code>
flag as an argument.</p>
</div>
<div class="paragraph">
<p>To programmatically detect the version of the AspectJ runtime while
running under Java 1.4 or later, get the version from the package:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">Package</span> lang = org.aspectj.lang.JoinPoint.class.getPackage();
<span class="predefined-type">String</span> version = lang.getImplementationVersion();</code></pre>
</div>
</div>
<div class="paragraph">
<p>When running under Java 1.3 or earlier, read the manifest directly. For
example code, see the source for
<code>AjBuildManager.checkRtJar(AjBuildConfig)</code> in the
<code>org.aspectj.ajdt.internal.core.builder</code> package of the
<code>org.aspectj.ajdt.core</code> module, available as described in
<a href="#buildingsource">Q:How do I get and compile the source code for
AspectJ?</a>.</p>
</div>
<div class="paragraph">
<p>Note that the version of AspectJ for the tools in <code>aspectjtools.jar</code> is
in <code>org.aspectj.bridge.Version</code>.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> How do I write synchronized advice?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> The only modifier advice can take is <code>strictfp</code>. However, you can
enclose the body of the advice in a synchronized clause:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">before() : pc() {
  <span class="directive">synchronized</span> (<span class="local-variable">this</span>) {
    <span class="comment">// advice code here</span>
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It should not be necessary to synchronize a percflow aspect, but you
might do this for perthis, pertarget, or issingleton (default) aspects.
To serialize advice in multiple aspects, synchronize on a lock object
available (only) to the aspects.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="problems">Common Problems</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Q:</strong> When I run, I get a <code>StackOverflowError</code> (or a long stack trace or
no output whatsoever)</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> Most likely this is a case of infinite recursion, where advice is
advising itself. It presents as a <code>StackOverflowError</code> or silence as the
VM exhausts itself in the recursion.</p>
</div>
<div class="paragraph">
<p>Of course, infinite recursion is possible in Java:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Main</span> {
    <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
        <span class="keyword">try</span> {
           main(args);
        } <span class="keyword">finally</span> {
           main(args);
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you compile and run this program, and it will fail silently, trying
to process the finally clause even after throwing the
StackOverflowError.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s a similar AspectJ program where the recursion is not so obvious:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect A {
    after():  call(* *(..)) { <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">after </span><span class="delimiter">&quot;</span></span> + thisJoinPoint); }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This re-invokes itself because it advises any call. It invokes itself
even after an exception is thrown, since <code>after</code> advice, like a finally
clause, runs even after exceptions are thrown. You can fix this by
following two practices:</p>
</div>
<div class="paragraph">
<p>In AspectJ 1.1, the String concatenation operator (+) is advised in its
StringBuffer form, so if your advise uses String + in a way that is
picked out by your pointcut, you will get infinite recursion.</p>
</div>
<div class="paragraph">
<p>(1) Use <code>after returning</code> to advise normal completions or
<code>after throwing</code> to advise abrupt completions. If you use <code>after</code> or
<code>after throwing</code>, write the advice with the same care you would a
finally clause, understanding that it may run after some failure.</p>
</div>
<div class="paragraph">
<p>(2) Avoid writing advice that advises itself. One simple way to
do so is to exclude the code within the current aspect:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect A {
    after() returning:  !within(A) &amp;&amp; call(* *(..)) {
        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">after </span><span class="delimiter">&quot;</span></span> + thisJoinPoint);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A better way is often to re-write the pointcut. If the advice is
advising itself accidentally, that&#8217;s a sign that the pointcut is not
saying what you mean.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect A {
    pointcut withinTargetClasses() : within(A+) || within(B+);
    after() returning:  withinTargetClasses() &amp;&amp; call(* *(..)) {
        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">after </span><span class="delimiter">&quot;</span></span> + thisJoinPoint);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Q:</strong> I&#8217;ve declared a field on every class in my package; how do I use it
in advice?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect A {
    <span class="type">boolean</span> com.xerox..*.dirtyFlag;
    after (<span class="predefined-type">Object</span> target) returning
        : target(target) &amp;&amp; call(* com.xerox..*.set*(..)) {
        target.dirtyFlag = <span class="predefined-constant">true</span>; <span class="comment">// compile fails here</span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>A:</strong> You need a type to refer to any member, field or method. It&#8217;s
generally better to introduce onto an interface and declare classes to
implement the interface, which permits you to use the interface type in
advice formals.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect A {
    <span class="type">interface</span> <span class="class">TrackingSets</span> {}
    <span class="type">boolean</span> TrackingSets.dirtyFlag;
    declare parents : com.xerox..* <span class="directive">implements</span> TrackingSets;

    after (TrackingSets target) returning
        : target(target) &amp;&amp; call(* com.xerox..*.set*(..)) {
        target.dirtyFlag = <span class="predefined-constant">true</span>;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Q:</strong> The AspectJ compiler aborts with an OutOfMemoryError when compiling
many classes. How can I fix this?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> <code>ajc</code> can use more memory than a javac compile of the corresponding
pure-java sources when aspects are added to the mix. You&#8217;ll need to
increase the memory available.</p>
</div>
<div class="paragraph">
<p>The command <code>ajc</code> is actually a script that launches a Java virtual
machine with the correct classpath. You should make a copy of this
script, rename it, and then edit it. Change the -Xmx option, size of
memory allocation pool (heap). You might try <code>-Xmx128M</code> or even
<code>-Xmx256M</code>.</p>
</div>
<div class="paragraph">
<p>When running under Ant, give Ant more memory or use the <code>fork</code> option
together with the <code>Xmaxmem</code> option.</p>
</div>
<div class="paragraph">
<p>When running under an IDE, look to the documentation for the IDE to
determine how to increase available memory.</p>
</div>
<div class="paragraph">
<p>In either case, doing incremental compilations can hold on to more
memory than a one-shot compile process, as the compiler trades space for
time in recompiles.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> Why do I get a message that my class is already defined?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> Most commonly, a source file was specified twice on the command
line (e.g., directly and by a *.java entry in a .lst file). However,
sometimes you have defined a class in two files in the same package, and
you need to rename the class or change its scope. You should get this
message from any Java compiler.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> <code>ajc</code> recompiles all files every time. How can I make it recompile
only the files that have changed?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> <code>ajc</code> 1.0 does not support incremental compilation, but since 1.1
<code>ajc</code> does when passed the <code>-incremental</code> option. It may still recompile
files that have not changed, if they could be affected by aspects in
particular ways, but the files compiled should be fewer and result in
faster compiles. Further, the 1.1 release supports binary weaving, so
you need not recompile if you already have .class files.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> <code>ajc</code> is using the wrong JVM. How do I fix it?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> The easiest way to fix this is to re-install <code>ajc</code> (using the same
<code>.class</code> or <code>.exe</code> file that you originally downloaded) and this time
make sure to tell it to use the desired JDK (typically the JDK versions
1.2 or 1.3 from Sun).</p>
</div>
<div class="paragraph">
<p>If you are familiar with DOS batch files or shell programming, you could
also fix this by simply editing the <code>bin\ajc.bat</code> or <code>bin/ajc</code> script.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> My IDE is trying to parse AspectJ files which makes my project
unusable. What can I do?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> When working with an unsupported IDE that objects to the syntax of
AspectJ source files (and, e.g., automatically gathers them in a source
tree as Java files based on the .java extension), you can use the .aj
extension for your AspectJ files. The ajc compiler accepts both .java
and .aj files, and you can set up your build scripts to include the
correct list of source files. (You will have to find another editor for
editing AspectJ files and possible viewing crosscutting structure.)</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> I used to be able to compile my program in my IDE, but when I use
AJDE, I run out of memory (or it goes really slow).</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> The ajc compiler does more analysis than (e.g.,) javac, and AJDE
may in some IDE&#8217;s hold a copy of the structure tree until the next tree
is available from the compile process. Both mean that you may need extra
memory to compile the same program. However, increasing available memory
to the point that you are swapping to disk can slow the process
considerably.</p>
</div>
<div class="paragraph">
<p>If you are having problems and would like to find the optimal memory
allocation, iteratively decrease the amount of memory available until
AJDE or ajc signals out-of-memory errors, and then increase that amount
by 5-10%.</p>
</div>
<div class="paragraph">
<p>To increase memory for the ajc compiler, see #q:ajcoom[Q:The AspectJ
compiler aborts with an OutOfMemoryError when compiling many classes.
How can I fix this?]. For your IDE, do something similar or follow the
provider&#8217;s instructions. For example, to increase memory, add something like
this to your IDE&#8217;s config file or start script:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">vmparam -Xmx384m</code></pre>
</div>
</div>
<div class="paragraph">
<p>If it turns out that your project is too big to use with AJDE, your IDE
may nonetheless support external commands or Ant build processes, which
run outside the IDE memory space. For a JBuilder Ant plugin, some people
have directed us to <a href="https://antrunner.sourceforge.net" class="bare">https://antrunner.sourceforge.net</a>.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> When I run, I get a <code>NoAspectBoundException</code> or a ClassNotFound
message for <code>NoAspectBoundException</code>.</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> This happens when an aspect is not associated with an object that
is being advised. We have seen this happen two ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>You get a ClassNotFound message for <code>NoAspectBoundException</code> when
loading a class affected by aspects if <code>aspectjrt.jar</code> classes are not
on the runtime classpath. To fix this, put the classes on the classpath.</p>
</li>
<li>
<p>You can get a <code>NoAspectBoundException</code> when there is a cycle in aspect
initialization or static initialization, most commonly when an aspect
advises its own initializer. To fix this, first find the class that
fails to load by running java in debug mode or looking at the
<code>NoAspectBoundException</code> trace, and then fix the offending (probably
unintended) dependency. Most often, it comes from a pointcut like
<code>staticinitialization(com.company..<strong>)</code> or <code>within(com.company..</strong>)</code>,
which can include any aspects in the same subpackages. You can avoid
advising most join points associated with the aspect <code>TheAspect</code> by
adding <code>&amp;&amp; !within(TheAspect)</code> to your pointcut.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Q:</strong> My stack traces don&#8217;t make sense. What gives?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> In 1.0, unless you are using the <code>ajdb</code> debugger, stack traces may
have synthetic methods in the stack, and the line numbers may not track
your source code. The <a href="devguide/index.html">Development Environment
Guide</a> discusses how to interpret stack at the end of the
<a href="devguide/ajc-ref.html">Reference for ajc</a>.</p>
</div>
<div class="paragraph">
<p>In 1.1, line numbers should work correctly. The only difference from a
normal stack might be the addition of extra stack frames for call-backs.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> My advice is not running (or running twice), and I don&#8217;t know why.</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> When advice is not running, there is probably a problem in the
pointcut. Sometimes users specify pointcuts that do not mean what they
intend - most often when they misspell a type name. Run the compiler in
<code>-Xlint</code> mode, which will flag some likely mistakes, like the type name.
If that does not work, and your pointcut is staticly-determinable, use a
declare statement to identify affected code. (For more information, see
#q:knowWhenAspectsAffectClasses[Q: How do I know which aspects affect a
class when looking at that class&#8217;s source code?].) If that does not work
and your pointcut is dynamically determined, see if your join points are
executing at all by using TraceJoinPoints.java from
#q:seeingjoinpoints[Q:I don&#8217;t understand what join points exist. How can
I see them?].</p>
</div>
<div class="paragraph">
<p>When advice is running more than it should, either (1) your advice is in
an abstract aspect and the pointcut picks out the same join point for
more than one concrete instantiation of the aspect, or (2) your pointcut
picks out more join points than you intend.</p>
</div>
<div class="paragraph">
<p>In the case of advice in abstract aspects, the advice will run once for
each concrete instance of the aspect. If the pointcut for that advice
picks out the same join point for two concrete aspects, then the correct
behavior is for the advice to run the advice twice at that join point.</p>
</div>
<div class="paragraph">
<p>To see if your pointcut picks out the join points you intend, you can
use IDE support, logging, or declare-warnings. If you are using IDE
support, you should be able to trace back from the pointcut or advice to
the join points which can be statically determined to be affected.
Without IDE support, you can write declare-warning statements to
identify code affected by staticly- determinable pointcuts. To identify
advised dynamic join points, you can try using <code>TraceJoinPoints.java</code> as
above, or update the advice to print the source location of the join
point. Doing any of these should show if the advice applies to code that
you did not expect.</p>
</div>
<div class="paragraph">
<p>If you&#8217;ve done this and convinced yourself it&#8217;s not working, it may be a
bug. See #q:bugreports[Q:How do I submit a bug report?].</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> My advice runs for each overridden method!</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> Most likely you are advising the method execution join point and
specifying the defining signature. Since all overriding methods share
this signature, the advice runs for each method executed. (This happens,
e.g., when one method invokes the same method in the superclass using
<code>super.{method}(..)</code>). This is the correct behavior.</p>
</div>
<div class="paragraph">
<p>To avoid this, use the <code>call(..)</code> pointcut designator, or use
<code>!cflow(..)</code> to pick out only the initial method-execution.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> I don&#8217;t understand when thisEnclosingJoinPointStaticPart is
available.</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> <code>thisEnclosingJoinPointStaticPart</code> is a special variable available
in the context of advice to refer to the join point, if any, lexically
enclosing the current join point:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. thisEnclosingJoinPointStaticPart</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">One of these&#8230;&#8203;</th>
<th class="tableblock halign-left valign-top">will be tEJSP for each of these:</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">constructor-execution, method-execution, advice execution,
initialization, pre-initialization, static initialization</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">constructor-call, method-call, handler, field-set, field-get</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Expressions in the body of handlers have the same
<code>thisEnclosingJoinPointStaticPart</code> as the handler itself.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> I declared a member on a class with package access, but other
classes in the package cannot see it.</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> When declaring parents on other types from an aspect, package
access only applies to code the implementation controls. For AspectJ
1.0, that is the set of files passed to the compiler. That means other
classes not compiled with the aspect will not be able to access the
aspect-declared members even if they are in the same package. The only
way for classes outside the control of the implementation to access
aspect-declared members is to declare them public.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> I declared a member on a interface, but javac does not see it.</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> You have to compile all the top-level implementating classes of the
interface using <code>ajc</code>. From an email by Jim Hugunin on the requirements
for AspectJ 1.1 to implement members declared by an aspect on an
interface:</p>
</div>
<div class="paragraph">
<p>If you introduce non-static fields or non-abstract methods on an
interface from an aspect, then all of the top-most implementors of that
interface must be woven by that same aspect. (A class C is a top-most
implementor of an interface I if C implements I and the superclass of C
does not implement I.)</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> <code>ajc</code> 1.0 complains that it can&#8217;t find <code>javac</code>. What&#8217;s wrong?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> <code>ajc</code> 1.0 does not try to locate <code>javac</code> in your path: it uses the
<code>javac</code> classes directly. In JDK 1.2 and 1.3 these classes are found in
<code>tools.jar</code> (in the <code>lib</code> directory of the JDK distribution), which must
be on your classpath to make <code>ajc</code> work with <code>javac</code>. Inspect the java
command that launches ajc to make sure that <code>tools.jar</code> is on the
classpath for ajc; the -classpath option only applies to the sources
compiled.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> I&#8217;m running under 1.4, but <code>ajdoc</code> asks for 1.3 (or throws
IllegalAccessError for HtmlWriter.configuration)</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> The 1.0 implementation of <code>ajdoc</code> uses specific javadoc classes in
the J2SE 1.3 tools.jar. We are working on addressing this limitation,
but in the interim it is best to run ajdoc under 1.3.</p>
</div>
<div class="paragraph">
<p>When running from the command-line scripts, edit the scripts directly to
put the 1.3 tools.jar first on the classpath. (The installer does not
know about this limitation of ajdoc.)</p>
</div>
<div class="paragraph">
<p>When running from Ant, users often have tools.jar in $\{ant.classpath}
(to make javac, et al work). That makes it impossible to run the ajdoc
taskdef (which does not currently support forking), so you&#8217;ll need to
run a separate ant process, either from the command-line or via Ant&#8217;s
exec task (the Ant task will propagate the classpath). If the wrong
tools.jar is not on the ant classpath, then it should work to put the
1.3 tools.jar in the taskdef classpath.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> I set up different files to my compiles to change what the aspects
see, but now I don&#8217;t understand how the aspects are working.</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> It is a bad practice to use the compilation unit to control
crosscutting. Aspects and pointcuts especially should be written to
specify crosscutting precisely. Aspects will behave the same when you
add files if you initially included all files affected by your aspects.
If you use the compilation unit, then your code will behave differently
in AspectJ implementations that do not limit themselves to specified
files.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> I&#8217;m reading the code generated by <code>ajc</code> 1.0 in <code>-preprocess</code> mode,
and it seems like it would not work (or "like it works this way").</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> The generated code can be difficult for a human to read and
understand. The compiler uses implementation techniques which might not
be apparent. To determine if the code is behaving correctly, you should
write and run a program that attempts to provoke the error you suspect.
Similarly, you should not rely on invariants you infer from the
generated code (especially naming conventions for generated members).
Please rely only on the semantics stated in the appendix of the AspectJ
<a href="progguide/index.html">Programming Guide</a>.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> I&#8217;ve heard AspectJ can generate or inject code into my code. Is
this true?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> This is a misconception spawned from the early implementation.</p>
</div>
<div class="paragraph">
<p>AspectJ does not "inject" or "generate" code. In AspectJ the pointcut
constructs allow the programmer to identify join points, and the advice
constructs define additional code to run at those join points.</p>
</div>
<div class="paragraph">
<p>So the semantic model of advice is like the semantic model of a method&#8201;&#8212;&#8201;it says "when any of these things happen, do this".</p>
</div>
<div class="paragraph">
<p>People who worked with earlier versions of AspectJ, in which ajc was
very explicitly a pre-processor, sometimes thought of AspectJ as
injecting code. But that was an artifact of the implementation, not the
underlying language semantics.</p>
</div>
<div class="paragraph">
<p>This distinction is important for two reasons. One is that thinking
about it this way will make more sense at the implementation continues
to evolve towards load-time or runtime weaving. The other is that it
makes it much easier to understand the semantics of advice on cflow
pointcuts.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> Why can&#8217;t AspectJ pick out local variables (or array elements or
&#8230;&#8203;)?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> Users have sometimes wanted AspectJ to pick out many more join
points, including</p>
</div>
<div class="ulist">
<ul>
<li>
<p>method-local field access</p>
</li>
<li>
<p>array-element access</p>
</li>
<li>
<p>loop iteration</p>
</li>
<li>
<p>method parameter evaluation</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Most of these have turned out not to make sense, for a variety of
reasons:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>it is not a commonly-understood unit for Java programmers</p>
</li>
<li>
<p>there are very few use-cases for advice on the join point</p>
</li>
<li>
<p>a seemingly-insignificant change to the underlying program causes a
change in the join point</p>
</li>
<li>
<p>pointcuts can&#8217;t really distinguish the join point in question</p>
</li>
<li>
<p>the join point would differ too much for different implementations of
AspectJ, or would only be implementable in one way</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>We prefer to be very conservative in the join point model for the
language, so a new join point would have to be useful, sensible, and
implementable. The most promising of the new join points proposed are
for exception throws clauses and for synchronized blocks.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> Why doesn&#8217;t AspectJ pick out reflective calls? The pointcut
<code>call(void run())</code> won&#8217;t pick out a call using reflection, like
<code>((Method)run).invoke(null, args)</code>.</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> The pointcut <code>execution(void run())</code> will work. The call pointcut
doesn&#8217;t work because <code>Method.invoke(..)</code> is the Java method-call, and
AspectJ cannot delve into the Java reflection library to implement call
semantics. To advise a reflective call (e.g., because the compiler does
not control the code for the method execution), test the context for
<code>invoke(..)</code>. Here&#8217;s a pointcut that tests only if the method name is
correct:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect A {
    pointcut runReflectiveCall(<span class="predefined-type">Method</span> run) : target(run) &amp;&amp;
         call(<span class="predefined-type">Object</span> <span class="predefined-type">Method</span>.invoke(..)) &amp;&amp; <span class="keyword">if</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">run</span><span class="delimiter">&quot;</span></span>.equals(run.getName()));
    before() : runReflectiveCall(<span class="predefined-type">Method</span>) {
        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">before reflective call </span><span class="delimiter">&quot;</span></span> + thisJoinPoint);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Q:</strong> What are the bugs now most affecting users?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> The bugs affecting the semantics of the language are marked with
the "info" keyword. Find them with the query
<a href="https://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;keywords=info" class="bare">https://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;keywords=info</a></p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> What extra memory is required at runtime?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> When running classes produced by the AspectJ weaver or compiler,
there are no significant hidden uses of memory. As would be expected,
each aspect is instantiated. The per-object aspects (like <code>pertarget</code> or
<code>perthis</code>) in some implementations use a map to link aspects and the
associated object. When using <code>cflow</code>-related pointcuts, a <code>ThreadLocal</code>
is used to track control flow for each affected thread.</p>
</div>
<div class="paragraph">
<p>Of course, the size and code in an aspect can require memory. Aside from
normal Java practices, take care with join point references. When
referencing the static part of a join point (e.g.,
<code>thisJoinPointStaticPart</code>), only one object is created. However, if you
reference the join point itself (e.g., <code>thisJoinPoint</code>), then one
<code>JoinPoint</code> object will be created for each join point running advice.</p>
</div>
<div class="paragraph">
<p>Aspect instances will be garbage collected just like regular objects
after there are no more strong references to them. For the default
aspect instantiation model, <code>issingleton</code>, the aspect class retains a
reference to the singleton instance, in order to implement
<code>static {AspectClass} aspectOf()</code>, so singleton instances will not be
garbage collected until the class is. For long-running or
memory-critical programs, consider using weak references in singleton
aspects for state that should be garbage collected.</p>
</div>
<div class="paragraph">
<p>Finally, when using load-time weaving, the weaver can require memory in
its own right. Because the class loader never can know when it is done
loading classes, the weaver can hold on to the aspects required to weave
for some time. There are strategies for minimizing this (with different
trade-off&#8217;s), so the time and memory required for load-time weaving will
vary as load-time weaving evolves.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> I get a VerifyError when running CGLIB generated code that has been
woven by AspectJ. Why is this?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> When weaving after advice into any piece of code, the AspectJ
strategy is to make all exit points from that code jump to a single exit
point that executes the advice before returning. There is a verifier
rule in the JVM specification that specifies that all routes to a jump
destination must have the same height stack when they get there,
regardless of the route taken to get there through the bytecode. The
CGLIB generated code has different stack heights at the various exit
points. This is not a problem with the CGLIB generated code, it is
perfectly valid - it is just unusual and the AspectJ weaving strategy
causes the verify error to trigger when it makes all exits jump to a
single destination.</p>
</div>
<div class="paragraph">
<p>AspectJ could cope with this and instead implement after advice by
calling the advice and returning at each exit point. However, it is
unlikely that the user actually meant to weave the CGLIB generated code
in the first place - and so usually the right thing to do is to exclude
CGLIB generate code from the weaving process by appropriate use of the
exclude element in the aop.xml. A typical clause in the aop.xml might
look as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;weaver&gt;</span>
  <span class="tag">&lt;exclude</span> <span class="attribute-name">within</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">*CGLIB*</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
<span class="tag">&lt;/weaver&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="aj11">AspectJ 1.1 and eclipse.org</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Q:</strong> Why did the AspectJ project move to eclipse.org?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> From the message sent to users:</p>
</div>
<div class="paragraph">
<p>AspectJ has come a long way&#8201;&#8212;&#8201;the language has stabilized; there are a
rapidly growing number of commercial users; the 1.1 release is imminent
and will include byte-code weaving and incremental compilation; and the
tool support is now well integrated with several major IDEs.</p>
</div>
<div class="paragraph">
<p>This growth of the community and the technology means that the original
research and prototype development of AspectJ is complete. As such it is
time for ongoing development and support of AspectJ to move outside of
PARC. This has already started to happen; the Eclipse AJDT plug-in and
the several books in preparation are examples.</p>
</div>
<div class="paragraph">
<p>To encourage the growth of the AspectJ technology and community, PARC is
transferring AspectJ to an openly-developed eclipse.org project. This
project will include documentation, web site, mailing lists, bug
database, and sources for the compiler. The command-line AspectJ
compiler is still the primary tool produced by this project, in addition
to APIs that support integration with a variety of IDEs. The Eclipse
plug-in will remain at eclipse.org, while the NetBeans, JBuilder and
Emacs support will move to SourceForge.net projects. We look forward to
your involvement with and contribution to those projects.</p>
</div>
<div class="paragraph">
<p>We see Eclipse as an excellent new home for core AspectJ technology
development&#8201;&#8212;&#8201;it is an active community of Open Source development and
innovation in the Java space. Once development moves to Eclipse.org,
others will be able to contribute more easily.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> Do I have to download Eclipse to use AspectJ?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> No. The AspectJ tools download is completely self-contained and
does not require that you work in Eclipse. For information on IDE
support, see #q:integrateWithDevTools[Q: How well does AspectJ integrate
with existing Java development tools?].</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> What are the relationships between AspectJ, JDT, Eclipse, AJDT, and
IDE support generally?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> Eclipse is a software platform.</p>
</div>
<div class="paragraph">
<p>JDT is an eclipse project to support Java development. JDT has a Java
compiler.</p>
</div>
<div class="paragraph">
<p>AspectJ 1.1 is built on Eclipse/JDT&#8217;s Java compiler but is distributed
standalone and can run standalone. With the AspectJ distribution, you
can compile and run AspectJ programs and use the AspectJ structure
browser.</p>
</div>
<div class="paragraph">
<p>AJDT is an eclipse project to integrate AspectJ into Eclipse/JDT so you
can use Eclipse to develop AspectJ programs. AJDT aims to support the
full Eclipse experience - searching, compiler-error tasks, etc. AJDT
will use the AspectJ Development Environment (AJDE) API&#8217;s for creating
IDE integrations, as well as hooking in to the model underlying the Java
compiler.</p>
</div>
<div class="paragraph">
<p>Similarly, Sourceforge has projects integrating AspectJ into other
development environments using the AJDE API&#8217;s:
<a href="https://aspectj4emacs.sourceforge.net">AspectJ for Emacs</a>,
<a href="https://aspectj4jbuildr.sourceforge.net">AspectJ for JBuilder</a>, and
<a href="https://aspectj4netbean.sourceforge.net">AspectJ for NetBeans</a>.</p>
</div>
<div class="paragraph">
<p>This is the right level of separation/integration. AspectJ is available
standalone, leverages an existing open-source compliant Java compiler,
and supports external projects doing IDE integrations in Eclipse, Emacs,
JBuilder, and NetBeans through a common API, AJDE.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="AspectJ5">AspectJ 5 and Java 5</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Q:</strong> What are the new features of AspectJ 5?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> All the new features are documented in the
<a href="../adk15notebook/index.html">AspectJ 5 Developer&#8217;s Notebook</a> and the
<a href="../devguide/index.html">AspectJ Development Environment Guide</a>. To
summarize:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Java 5 support: as an extension to Java, AspectJ supports all the new
language features of Java 5, including generics (parameterized types),
autoboxing, covariant return types, enhanced for-loops, enums, varargs,
and of course annotations.</p>
</li>
<li>
<p>Java 5 extensions: the AspectJ language has been extended to make use
of Java 5 language features.</p>
<div class="ulist">
<ul>
<li>
<p>Generic aspects: an abstract aspect can be declared with a generic
type parameter which can be used in pointcuts and when declaring members
on the aspect (but not when declaring members on other types).</p>
</li>
<li>
<p>Annotations: pointcuts can now pick out join points based on the
associated annotations, annotation values can be bound in the same way
that other context variables are bound at the join point, and
annotations may be declared on other types in an aspect.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Annotation-style aspects: AspectJ 5 integrates AspectWerkz-style
aspects declared in annotations. This permits aspects to be written and
compiled in pure-java code and woven using build-time or load-time
weaving with the AspectJ weaver. (The original AspectJ language aspects
are distinguished as "code-style" aspects.)</p>
</li>
<li>
<p>AspectWerkz load-time weaving: Load-time weaving is greatly improved
for all versions of Java, and now supports an XML configuration file
which can declare concrete aspects. This means developers can deploy
binary abstract aspects that deployers configure using only XML.</p>
</li>
<li>
<p>pertypewithin instantiation model: aspects may now be instantiated on
a per-class basis.</p>
</li>
<li>
<p>Reflection and runtime support: AspectJ 5 supports reflection on
aspects using the Aspect class, and also support runtime evaluation of
pointcuts using a pointcut parser.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Q:</strong> Should I use code- or annotation-style aspects?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> To use AspectJ, you can use the original code-style aspects or the
annotation-style aspects new in AspectJ 5.</p>
</div>
<div class="paragraph">
<p>The original code-style is a small extension of the Java language
designed to express crosscutting as clearly as possible in ways familiar
to most Java programmers. To use the original code-style aspects,
compile them with the AspectJ compiler or weave pre-compiled binary
aspects using the AspectJ binary (.class) weaver, either at build-time
or at class-load-time. Code-style aspects have excellent IDE support,
allowing you to navigate to and from affected source code.</p>
</div>
<div class="paragraph">
<p>Annotation-style aspects are written (not surprisingly) using
annotations. They use the subset of the AspectJ language that works when
aspects are woven after the code is compiled. The source files are
compiled with Javac, which simply saves the annotations in the .class
files. The resulting .class files must be woven using the AspectJ
weaver, which reads the annotations from the .class file and uses them
to define aspects. Annotation-style aspects have the benefit of being
compilable by Javac, but you can&#8217;t use the full AspectJ language, and
you don&#8217;t enjoy the same level of IDE support for viewing crosscutting
structure.</p>
</div>
<div id="ltw" class="paragraph">
<p><strong>Q:</strong> What&#8217;s new about the load-time weaving support in AspectJ 5?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> While the AspectJ weaver could be used at load-time in previous
releases, the AspectJ 5 release supports much better integration with
the Java 5 VM and the BEA JRocket JVM. It also supports an XML file for
configuration that allows deployers to declare concrete aspects using
only XML. This means aspect developers can write abstract aspects, and
deployers need only configure <code>aop.xml</code> and run using the AspectJ weaver
in Java 5. For example, to run Java 5 VM with load-time weaving,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">java -javaagent:aspectjweaver.jar -classpath &quot;aspects.jar:${CLASSPATH}&quot; ..</code></pre>
</div>
</div>
<div class="paragraph">
<p>To declare a concrete aspect, add a a concrete-aspect XML entity to
<code>META-INF/aop.xml</code>. This example extends a tracing aspect to apply to
every type in the application:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;concrete-aspect</span>
    <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.company.tracing.ConcreteTracing</span><span class="delimiter">&quot;</span></span>
    <span class="attribute-name">extends</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">tracing.AbstractTracing</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
    <span class="tag">&lt;pointcut</span>
        <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">tracingScope</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">expression</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">within(com.company.app..*)</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/concrete-aspect&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>For more information, see the <a href="devguide/index.html">AspectJ
Development Environment Guide</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="Technology">Understanding AspectJ Technology</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Q:</strong> Do I need to know how the compiler or weaver works?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> Writing AspectJ programs only requires understanding the
<a href="progguide/index.html">Programming Guide</a>. However, current
implementations do not control everything in a system, so AspectJ
program semantics may be limited to code the implementation controls.
For our implementation, these limitations are stated in
<a href="progguide/implementation.html">Programming Guide Appendix:
Implementation Notes</a>. Aside from understanding the use and limitations
of the implementation, there is no need to understand the underlying
technology when writing AspectJ programs.</p>
</div>
<div class="paragraph">
<p>The technology that implements AspectJ interests some academic
researchers and some developers who want new features or new ways to
weave. These extensions are not discussed in the documentation. Some are
being developed already, others are on the drawing board (or perhaps
were left off long ago), and still others haven&#8217;t been considered. If
you are interested in a certain extension, check the bug database for
feature requests and the mailing list archives for any past discussions.
Then email the list to see if it&#8217;s been considered. For more
information, see <a href="#Developers">AspectJ Project Development</a>.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> How does the compiler/weaver work? Are there any white papers?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> There are currently no documents describing this process in detail.
You can compile programs and inspect the generated source or bytecode,
or view the source code (see <a href="#Developers">AspectJ Project
Development</a>). We hope to write papers on the bytecode weaving model
used in AspectJ-1.1 if we can find the time. Erik Hilsdale and Jim
Hugunin did draft a paper for AOSD 2004, now available on Jim&#8217;s web
site: <a href="https://hugunin.net/papers.html" class="bare">https://hugunin.net/papers.html</a> Jim summarized advice weaving in
the AspectJ 1.1 implementation in the
<a href="https://dev.eclipse.org/mhonarc/lists/aspectj-dev/msg00519.html">following
mailing-list reply</a>:</p>
</div>
<div class="paragraph">
<p>Each piece of advice in an aspect is associated with a pointcut. This
pointcut is stored in an attribute on the methods corresponding to each
piece of advice. Before weaving, all of these pieces of advice are
gathered into one large list.</p>
</div>
<div class="paragraph">
<p>Each .class file is woven independently. A .class file is woven by the
following steps:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Collect all of the joinpoint shadows in the .class file. For every
dynamic joinpoint in the AspectJ language model, there is a
corresponding static shadow of that joinpoint in the bytecode. For
example, every method call joinpoint has an INVOKE bytecode as its
static shadow. Some joinpoints (such as initialization) have much more
complicated static shadows.</p>
</li>
<li>
<p>Each piece of advice is matched to each static shadow. There are three
results possible from this match.</p>
<div class="ulist">
<ul>
<li>
<p>Never matches, in which case nothing is done to the shadow</p>
</li>
<li>
<p>Always matches, in which case the advice is woven into this joinpoint
shadow</p>
</li>
<li>
<p>Sometimes matches, in which case the advice is woven into the shadow
along with the minimal dynamic tests to determine if any particular
joinpoint in the actual running program matches the advice. The simplest
example of sometimes matches is when the pointcut uses if(test()).</p>
</li>
</ul>
</div>
</li>
<li>
<p>If any advice matched any static shadows in the .class file, then the
transformed .class file is written out, otherwise it is left unchanged.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See <code>BcelClassWeaver</code> and <code>BcelShadow</code> in the <code>org.aspectj.weaver.bcel</code>
package for the two primary classes involved in this process.</p>
</div>
<div class="paragraph">
<p>Note: This explanation ignores the implementations of inter-type
declarations completely. It also ignores performance optimizations such
as fast-match or pipelining that speed up the process.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> How do I get load-time weaving to work in my chosen application
server?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> You have two choices based on how wide you want the weaving to take
effect: application-server wide and application-specific weaving. You
choose between the two by loading aspect artifacts&#8212;&#8203;aspects, associated
types, and aop.xml&#8212;&#8203;through the right classloader. The aop.xml must be
in the META-INF directory on the classpath for the chosen classloader.
In either case, you modify the startup script to specify the
-javaagent:path-to/aspectjweaver.jar option to the Java virtual machine.
Note that it is not essential that all the artifacts be placed in a
single jar.</p>
</div>
<div class="paragraph">
<p>For application-server wide weaving, you make aspect artifacts
accessible to the server&#8217;s classloader. Typically, you achieve such
access by putting these artifacts in the server&#8217;s lib directory. For
example, for Tomcat, you will place the aspect artifacts in the
TOMCAT_HOME/lib directory.</p>
</div>
<div class="paragraph">
<p>For application-specific weaving, you make aspect artifacts accessible
to application classloader by bundling them along with application&#8217;s
classes. For example, for a web application, you will place the aspect
artifacts in the MY_APP/WEB-INF/lib and/or MY_APP/WEB-INF/classes
directory.</p>
</div>
<div class="paragraph">
<p>We recommend that you start with application-specific weaving. Note that
you have an additional option if your application is based on the Spring
framework. If you deploy in one of the supported web servers or
application servers, you can avoid modifications to the startup script.
Please see
<a href="https://static.springframework.org/spring/docs/2.5.x/reference/aop.html#aop-aj-ltw-spring" class="bare">https://static.springframework.org/spring/docs/2.5.x/reference/aop.html#aop-aj-ltw-spring</a>
for more details.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> Does AspectJ use reflection at runtime?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> The only time that reflection is used during run-time is when the
special thisJoinPoint object is used to discover reflective information
about the join point. If you don&#8217;t use thisJoinPoint then no reflection
will be used.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> What about load-time weaving? Can I weave aspects at runtime?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> Since the 1.1 release, AspectJ can weave binary aspects into
classes in bytecode form. Hooked up to a class loader, this can weave
class bytecodes after they are read in, before the class is defined by
the VM. (This means load-time weaving only works were aspects are not
required to compile the pure-java classes. If the aspects are required,
then the Java classes have to be compiled with the aspects using the
AspectJ compiler.) The AspectJ 1.2 release had the
WeavingURLClassLoader, and the 1.2.1 release introduced the aj.bat
script for Java 1.4. The AspectJ 5 release introduces much better
support for load-time weaving, including declaring concrete aspects in
XML files and integrating with Java 5 and BEA JRocket JVM&#8217;s. See
#q:aspectj5ltw[Q:What&#8217;s new about the load-time weaving support in
AspectJ 5?].</p>
</div>
<div class="paragraph">
<p>Some have asked about only weaving particular classes specified at
run-time. Aspects should work across an entire namespace, and problems
will likely result from weaving some classes but not others. Also, it&#8217;s
confusing to specify crosscutting both in the aspect and in the list of
runtime classes; the crosscutting specification should be in the aspect
itself, where it can be processed by tools.</p>
</div>
<div class="paragraph">
<p>And just to state the obvious: do not use bytecode weaving, at load-time
or otherwise, to modify .class files protected by license, without
permission from the licensor.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="Developers">AspectJ Project Development</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Q:</strong> I&#8217;m interested in the code implementing AspectJ.</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> Most people do not need to see the code for AspectJ; they can
download the binary distribution for documentation and tools for writing
AspectJ programs.</p>
</div>
<div class="paragraph">
<p>For people who want to know how the AspectJ technology works, the source
code is the best resource, until we write some proper white papers (see
#q:implementation[Q:Do I need to know how the compiler works?]). To get
and compile the Java source code for the AspectJ distribution, see
<a href="#buildingsource">Q:How do I get and compile the source code for
AspectJ?</a>.</p>
</div>
<div class="paragraph">
<p>Bear in mind when looking at the code that there are many ways to
implement the AspectJ language, and the code inspected might be an
initial version of a new architecture (e.g., bytecode weaving).</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> How can I get involved with developing the AspectJ project?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> For those who want to contribute to the project, here&#8217;s a general
list of ways to do so, in no particular order:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Participate effectively in the mailing lists. The quality of the
mailing lists makes a huge difference in the ability of new and
experienced AspectJ users to write good code. For guidance on effective
participation, see #q:talktousers[Q:How do I communicate with other
AspectJ users?] and #q:writingbugsandemails[Q:How should I write email
queries?]. Also, the time that experienced users take in answering
emails can directly translate to time developers can use (instead) for
fixing bugs or adding features.</p>
</li>
<li>
<p>Write bugs. Good bugs, especially with test cases, are always
appreciated. We especially like proposals for new <code>XLint</code> messages,
since they are sometimes easy to implement and help users learn AspectJ,
and for other implementable features grounded in a compelling use-case.</p>
</li>
<li>
<p>Write test cases for compiler bugs without test cases. Compiler bugs
without test cases are much less likely to be fixed; until they are
rendered in code, they might be user mistakes, and they might duplicate
another bug or actually cover many bugs.</p>
<div class="paragraph">
<p>Find them by searching open compiler bugs and picking out any which do
not have test case attachments or a comment that a test case has been
written. Here is a query for open compiler bugs:
<a href="https://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler&amp;bug_status=UNCONFIRMED&amp;bug_status=NEW&amp;bug_status=ASSIGNED&amp;bug_status=REOPENED" class="bare">https://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler&amp;bug_status=UNCONFIRMED&amp;bug_status=NEW&amp;bug_status=ASSIGNED&amp;bug_status=REOPENED</a></p>
</div>
<div class="paragraph">
<p>For how to write test cases, see #q:harnesstestcases[Q:How should I
submit test cases for bugs?].</p>
</div>
</li>
<li>
<p>Write patches to fix bugs. If you particularly need a bug to be fixed,
or if you&#8217;re interested in learning about the system, then get the
source code and try to fix the bug. Most likely you&#8217;ll want to email
<a href="mailto:aspectj-dev@eclipse.org">aspectj-dev@eclipse.org</a> to declare your intentions and the approach you
propose (based on having looked at the code). Mailing the list gives
those experienced with the code a chance to guide you away from
pitfalls. To submit the patch, attach it to the bug. (When creating
patches, do so on a per-module basis; that means if fixing the bug
involves changes to three modules, submit three patches.)</p>
</li>
<li>
<p>Write patches for other reasons. Often documentation needs to be
fixed, or there may be a small new feature you&#8217;d like to see. You can
just do it and then submit it as a patch to a bug you create. As with
bugs, in some cases you might want to declare your intentions on the
mailing list to avoid wasting time on something that&#8217;s been fixed but
not committed or on an approach that will be fruitless.</p>
</li>
</ul>
</div>
<div id="buildingsource" class="paragraph">
<p><strong>Q:</strong> How do I get and compile the source code for AspectJ?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> The AspectJ source code is available on the <a href="https://github.com/eclipse/org.aspectj">AspectJ GitHub page</a>.
Read-me section <a href="https://github.com/eclipse/org.aspectj#building">Building</a> briefly explains how to compile AspectJ
from scratch.
Read-me section <a href="https://github.com/eclipse/org.aspectj#documentation-for-aspectj-developers">Documentation for AspectJ developers</a>
links to more detailed resources about build options, how to contribute to the project and how to release it.</p>
</div>
<div class="paragraph">
<p>For the latest AspectJ Development Tools (AJDT) for Eclipse release, please visit the
<a href="https://www.eclipse.org/ajdt/downloads/">AJDT Downloads</a> page.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> How do I build AspectJ and integrate it into AJDT?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> <strong>[TODO: outdated, update!]</strong> To build AspectJ, first get the source tree as described in
<a href="#buildingsource">Q:How do I get and compile the source code for
AspectJ?</a>. Once you have a development environment set up, copy the
<code>build/sample-local.properties</code> file to <code>build/local.properties</code> and
within this file point the <code>java14.home</code> and <code>java15.home</code> to the
corresponding places on your machine.</p>
</div>
<div class="paragraph">
<p>To build AspectJ on the command line:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Open a command prompt</p>
</li>
<li>
<p>Navigate to the <code>build</code> directory within your AspectJ workspace (to
find out where your workspace is go to <code>File &gt;
            Switch Workspace</code> within Eclipse).</p>
</li>
<li>
<p>Run <code>ant clean</code> to remove the files from previously built AspectJ
versions.</p>
</li>
<li>
<p>Run <code>ant</code> to build AspectJ. The built files are created in
<code>your_eclipse_installation_directory/aspectj_development_workspace/aj-build</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To import a locally built AspectJ into AJDT first follow the
instructions on <a href="https://www.eclipse.org/ajdt/faq.php#q:develop">How do I
setup an AJDT development environment in Eclipse?</a> for setting up an
AJDT development environment and running the correctness tests. Then:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Create a file <code>aspectjlib.properties</code> within the <code>org.aspectj.ajde</code>
project and add the following two lines</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">aspectj.lib.dir=C:/eclipse/aspectj-workspace/aj-build/dist/tools/lib
aspectj.doc.dir=C:/eclipse/aspectj-workspace/aj-build/dist/ide/eclipse/org.aspectj.ajde.doc/doc</code></pre>
</div>
</div>
<div class="paragraph">
<p>making sure to change the path to correspond to your set up.</p>
</div>
</li>
<li>
<p>Run the <code>build.xml</code> file in <code>org.aspectj.ajde</code> with the <code>plugin jars</code>
target:</p>
<div class="ulist">
<ul>
<li>
<p>Right click on the <code>build.xml</code> file in the <code>org.aspectj.ajde</code> plugin</p>
</li>
<li>
<p>Select <code>Run As &gt; Ant build&#8230;&#8203;</code></p>
</li>
<li>
<p>In the resultant dialog navigate to the <code>Targets</code> tab</p>
</li>
<li>
<p>Ensure <code>plugin jars</code> is the only selected target</p>
</li>
<li>
<p>Click <code>Run</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>Refresh the <code>org.aspectj.ajde, org.aspectj.runtime</code> and
<code>org.aspectj.weaver</code> plugins.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Q:</strong> Where do I find developer documentation on building and testing
AspectJ source code?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> Find the developer documentation in HTML files in the CVS tree,
inside the <code>build</code> and <code>testing</code> modules (i.e., in
<code>org.aspectj/modules/build/&#8230;&#8203;</code>). Most pertinant:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>../build/readme-build-and-test-aspectj.html</code> describes how to build
the AspectJ distribution in Eclipse and in Ant.</p>
</li>
<li>
<p><code>../build/readme-docs-module.html</code> describes the AspectJ documentation
sources and how to build the documentation using Ant.</p>
</li>
<li>
<p><code>../build/readme-tests-module.html</code> describes the all the tests in the
<code>tests</code> module.</p>
</li>
<li>
<p><code>../build/readme-writing-compiler-tests.html</code> describes how to write
compiler tests that can be run by the AspectJ test harness.</p>
</li>
<li>
<p><code>../build/readme-testing-drivers-module.html</code> describes the test
harness used to run the compiler tests in the <code>tests</code> module.</p>
</li>
<li>
<p><code>../build/readme-testing-drivers-module.html</code> describes the test
harness used to run the compiler tests in the <code>testing</code> module.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Q:</strong> How should I submit test cases for bugs?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> You can attach files to a bug after it has been created. The code
of course should replicate the actual behavior described in the bug when
run on the target version. If you have a single source file, you can
attach it directly, describing in the comments the expected result
(e.g., error on line 14, or successful compile/run). The most helpful
form for describing the test scenario and the expected results are the
test definitions described next.</p>
</div>
<div class="paragraph">
<p>For more complex bugs requiring many files, create a zip file of a
directory containing all the files and an XML test definition file. The
XML test definition file contains specifications for how to compile,
recompile, or run the test sources. Complete documentation is available
in the CVS tree at <code>tests/readme-writing-compiler-tests.html</code> but here
is a sample file with some example definitions, preceded by comments
showing the directory layout of the files referred to in the test
definitions.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="doctype">&lt;!DOCTYPE suite SYSTEM &quot;../tests/ajcTestSuite.dtd&quot;&gt;</span>
<span class="tag">&lt;suite&gt;</span>

<span class="comment">&lt;!-- Compile and run
     using the following files:

       {testDefinitions}.xml
       one/
         pack1/
           Main.java
         p2/
           BeforeConstructor.java

    Note the bug number goes in the pr attribute.
    (&quot;pr&quot; stands for &quot;problem report&quot;)
 --&gt;</span>
<span class="tag">&lt;ajc-test</span> <span class="attribute-name">dir</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">one</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">pr</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">234</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">title</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">before constructor call</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
    <span class="tag">&lt;compile</span> <span class="attribute-name">files</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">pack1/Main.java,p2/BeforeConstructor.java</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
    <span class="tag">&lt;run</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">pack1.Main</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/ajc-test&gt;</span>

<span class="comment">&lt;!-- Check that compiler warning was emitted
     using the following files:

       {testDefinitions}.xml
       two/
         UsesDeprecated.java
 --&gt;</span>
<span class="tag">&lt;ajc-test</span> <span class="attribute-name">dir</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">two</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">pr</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">244</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">title</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">deprecated, noImportError</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
    <span class="tag">&lt;compile</span> <span class="attribute-name">options</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">-warn:deprecated,-noImportError</span><span class="delimiter">&quot;</span></span>
          <span class="attribute-name">files</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">UsesDeprecated.java</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;message</span> <span class="attribute-name">kind</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">warning</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">line</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">20</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
    <span class="tag">&lt;/compile&gt;</span>
<span class="tag">&lt;/ajc-test&gt;</span>

<span class="comment">&lt;!-- Cooked example that uses all compiler attributes
     and the following files:
       {testDefinitions}.xml
       testCaseDir/
         jars/
           injar.jar
           required.jar
           requiredAspects.jar
         pack/
           Main.java
         providedClassesDir/
           ClassInDefaultPackage.class
           org/
             foo/
               AnotherRequired.class
  --&gt;</span>
<span class="tag">&lt;ajc-test</span> <span class="attribute-name">dir</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">testCaseDir</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">title</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">attributes test</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
    <span class="tag">&lt;compile</span> <span class="attribute-name">files</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">pack/Main.java,jars/injar.jar</span><span class="delimiter">&quot;</span></span>
           <span class="attribute-name">staging</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span>
           <span class="attribute-name">options</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">-Xlint,-g:none</span><span class="delimiter">&quot;</span></span>
          <span class="attribute-name">argfiles</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">debug.lst,aspects/test.lst</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">aspectpath</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">jars/requiredAspects.jar</span><span class="delimiter">&quot;</span></span>
         <span class="attribute-name">classpath</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">providedClassesDir,jars/required.jar</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
    <span class="tag">&lt;run</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Main</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/ajc-test&gt;</span>

<span class="comment">&lt;!-- Compiler errors, recompile after changing files, and run
     using the following files:

       {testDefinitions}.xml
       three/
         pack/
           IncCompileFix.java
           IncCompileFix.20.java

     Before compiling, IncCompileFix.java is copied to a staging
     directory.  Before recompiling, IncCompileFix.20.java
     replaces it, so the compiler treats file as updated.
  --&gt;</span>
<span class="tag">&lt;ajc-test</span> <span class="attribute-name">dir</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">three</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">pr</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">622</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">title</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">incremental fix</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
    <span class="tag">&lt;compile</span> <span class="attribute-name">staging</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">files</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">pack/IncCompileFix.java</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;message</span> <span class="attribute-name">kind</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">error</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">line</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">20</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;message</span> <span class="attribute-name">kind</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">error</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">line</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">42</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
    <span class="tag">&lt;/compile&gt;</span>
    <span class="tag">&lt;inc-compile</span> <span class="attribute-name">tag</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">20</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
    <span class="tag">&lt;run</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">pack.IncCompileFix</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/ajc-test&gt;</span>

<span class="tag">&lt;/suite&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Q:</strong> I&#8217;d like to run my test case. How do I get the test harness?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> The test harness is not distributed. To build it, get the source
tree as described in <a href="#buildingsource">Q:How do I get and compile the
source code for AspectJ?</a> and then build the <code>build-testing-drivers</code>
target:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">cd build
../lib/ant/bin/ant -f build.xml build-testing-drivers</code></pre>
</div>
</div>
<div class="paragraph">
<p>This produces <code>../aj-build/jars/testing-drivers-all.jar</code> which you can
run as described in <code>tests/readme-tests-module.html</code>.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> BCEL is used by AspectJ but it&#8217;s not actively developed. Will you
change?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> The AspectJ bytecode weaver has used BCEL for bytecode manipulation
since its first release. We have upgraded it extensively, to improve
performance, support Java 5, etc. The BCEL developers have not
incorporated our patches, so we continue to maintain our own version.
Ours has been optimized for the AspectJ weaver and battle-hardened over
years of development and use. At some point in the future, the AspectJ
weaver might be restructured to make it easy to see whether another
bytecode package offers the same stability, functionality, and
performance, but for now we prefer using something that we know works
well.</p>
</div>
<div class="paragraph">
<p>In the AspectJ 5 release, the weaver has been restructured to use
reflection where possible. Otherwise, it continues to use BCEL, but does
not hold BCEL structures in memory after our evaluation completes.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="help">Getting Help</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Q:</strong> How do I find out more about AspectJ?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> Visit the AspectJ project web site: <a href="https://eclipse.org/aspectj" class="bare">https://eclipse.org/aspectj</a>.</p>
</div>
<div id="ajcbugs" class="paragraph">
<p><strong>Q:</strong> How do I submit a bug report?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> You can submit a bug from
<a href="https://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ" class="bare">https://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ</a> . If it seems
to be a bug in the compiler, please attach a small test case (source
code) to reproduce the problem. For more information on writing compiler
test cases, see #q:ajcbugs[Q:How do I write bugs for the AspectJ
compiler?]. If you are unable to submit a test case, consider submitting
traces, ajcore files, and/or .class dump files, as described in the
<a href="pdguide/index.html">AspectJ Problem Diagnosis Guide</a>.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> How do I communicate with other AspectJ users?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> You can reach other AspectJ users by using the aspectj-users
mailing list. You can subscribe to the list or view the list archives
from the AspectJ home page <a href="https://eclipse.org/aspectj" class="bare">https://eclipse.org/aspectj</a> .</p>
</div>
<div id="searchingsite" class="paragraph">
<p><strong>Q:</strong> How can I search the email archives or the web site?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> It is very effective to do a google search of the form,
<a href="https://www.google.com/search?q=site:eclipse.org+cflowbelow" class="bare">https://www.google.com/search?q=site:eclipse.org+cflowbelow</a> , and you can
use the eclipse.org search at <a href="https://www.eclipse.org/search/search.cgi" class="bare">https://www.eclipse.org/search/search.cgi</a> .
You can also check the old archives available for download from the
AspectJ home page <a href="https://eclipse.org/aspectj" class="bare">https://eclipse.org/aspectj</a> .</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> How should I write email queries?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> Here&#8217;s the general form of a good email:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Describe the big picture of what you are trying to do&#8230;&#8203;</p>
</li>
<li>
<p>Describe what you think it takes, in AspectJ terms (concepts, syntax,
and semantics) from the <a href="progguide/index.html">Programming Guide</a>&#8230;&#8203;</p>
</li>
<li>
<p>Show the AspectJ code you are using, what output it produces when run,
and what output you expect&#8230;&#8203;</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The big picture helps others redirect you to other approaches. Using
AspectJ terms helps others correct mistakes in thinking about the
problem (the most common being to confuse join points and pointcuts).
The code is key to clarifying your question and getting a good response.
On the mail list, someone can reply by fixing your code. In bugs, the
developers can reproduce the problem immediately and start analyzing the
fix. The code should not be incomplete; it should run (or fail) as-is,
without additional libraries or source files.</p>
</div>
<div class="paragraph">
<p>For the mail lists, we try to follow the conventions for open-source
discussions that help avoid "the tragedy of the commons." For example
conventions, see <a href="https://jakarta.apache.org/site/mail.html" class="bare">https://jakarta.apache.org/site/mail.html</a> and
<a href="https://www.tuxedo.org/%7Eesr/faqs/smart-questions.html" class="bare">https://www.tuxedo.org/%7Eesr/faqs/smart-questions.html</a> .</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> How do I write bugs for IDE support?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> Bugs appearing in the IDE&#8217;s may apply to the affected IDE or to the
compiler. Compiler stack traces in IDE message windows are prefixed
"Internal Compiler Error" and should be written up as compiler bugs. If
you are unsure, try redoing the compile from the command line.</p>
</div>
<div class="paragraph">
<p>Bug report for the IDE extensions go to their respective projects,
listed in #q:integrateWithDevTools[Q: How well does AspectJ integrate
with existing Java development tools?] (including bug reports for the
AJDE Eclipse support, which you can submit at
<a href="https://bugs.eclipse.org/bugs/enter_bug.cgi?product=AJDT" class="bare">https://bugs.eclipse.org/bugs/enter_bug.cgi?product=AJDT</a> ).</p>
</div>
<div class="paragraph">
<p>One of the benefits of open-source is that you can find and fix the bug
for yourself; when you submit the fix back to us, we can validate the
fix for you and incorporate it into the next release. You can submit a
patch by attaching it to the bug.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> How do I write bugs for the AspectJ compiler?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> The best compiler bug report is a reproducible test case,
standalone code that demonstrates the problem. Sometimes with aspects, a
test case requires several files, if not some way to capture the
behavior. Here&#8217;s how we recommend submitting test cases:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Write the test case so that when the compiler bug is fixed, the test
completes normally without output (e.g., expected compiler errors are
issued, or classes produced run correctly). This usually means writing
one or more source files.</p>
</li>
<li>
<p>In the bug report, briefly summarize the bug. If it is not obvious, be
sure to specify the expected output/behavior (e.g., compiler error on
line 32) and, if the compile should complete, the main class to run.</p>
</li>
<li>
<p>Submit the bugs via the web form
<a href="https://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ" class="bare">https://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ</a> .</p>
</li>
<li>
<p>Attach the test case to the bug. The test case may be a single file or
it may be multiple files in a single zip archive, of the form discussed
in #q:harnesstestcases[Q:How should I submit test cases for bugs?].</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Q:</strong> Can you recommend reading or teaching material for AspectJ?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> The documentation available in the distribution is the best source
for language and usage questions.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> Where can our group get consulting and support?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> The best thing to do is join and email the
<code>aspectj-dev@eclipse.org</code> mailing list.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> What has changed since the last FAQ version?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> Entries changed recently:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>#q:license[Q:How is AspectJ licensed?]</p>
</li>
<li>
<p>#q:productplans[Q:Is it safe to use AspectJ in my product plans??]</p>
</li>
<li>
<p>#q:whitepapers[Q:How does the compiler/weaver work? Are there any
white papers?]</p>
</li>
<li>
<p>#q:bugreports[Q:How do I submit a bug report?]</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="project">About the AspectJ Project</h2>
<div class="sectionbody">
<div id="opensource" class="paragraph">
<p><strong>Q:</strong> What does the fact that AspectJ is an Open Source Project mean to
me?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> Open source protects your interest in a correct, long-lived,
up-to-date, and widely-accepted implementation of AspectJ.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>With the source code, you control your own destiny in perpetuity. You
can continue to use the implementation and update it as necessary to fix
bugs and add things you need.</p>
</li>
<li>
<p>Because the code is available to all, anyone can find and fix bugs.
There is no need to hope for it to be fixed in the next product release.
Those who encounter the bugs are motivated to fix them, and there are
more eyeballs on the code than in closed-source, so the quality tends to
be high. This can be particularly true for the AspectJ community, which
tends to be highly skilled.</p>
</li>
<li>
<p>The same is true of new features or behavior, so the implementation
should be up-to-date. This is important as the field of AOP develops, to
capture the latest solutions.</p>
</li>
<li>
<p>For a programming language which forms the basis of an entire solution
stack, open source facilitates the kind of adoption&#8201;&#8212;&#8201;tool integrations
and significant projects&#8201;&#8212;&#8201;that develop and prove the technology for
wider adoption. This limits delays caused by waiting for the completion
of standards process or promulgation by industry leaders, and also
provides the proofs necessary for such adoption.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Q:</strong> What are your plans to make AspectJ a general feature of Java
supported by Sun and the other key players in the Java Industry?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> Although we are committed to making AspectJ available to a wide
range of users, it is too early to decide on a strategy. Some options
include continuing AspectJ as a stand-alone product, integrating it into
IDEs, or possibly incorporating it into standard Java with Sun&#8217;s
blessing.</p>
</div>
<div class="paragraph">
<p>We currently focus on developing for the 1.1 implementation which
improves AspectJ in key areas: rapid incremental compilation, bytecode
weaving, and IDE integration.</p>
</div>
<div class="paragraph">
<p>Through all of this our goal is to make AspectJ integrate as seamlessly
as possible with the Java programming language. The AspectJ language
design is becoming more integrated, the compiler is becoming faster and
more integrated, the IDE extensions are becoming more integrated. All of
this is designed to help users really use AspectJ and give us feedback
on it.</p>
</div>
<div class="paragraph">
<p>As the system is improved and we work more closely with users, we will
be in good position to explore the best path for AspectJ in the long
term.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> When will AspectJ work from class files? When will it work at
class-loading time?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> Bytecode weaving is in AspectJ 1.1. We believe it works as
described in an email to the users list by Jim Hugugin:</p>
</div>
<div class="paragraph">
<p>The AspectJ language was designed to support weaving at many different
times: compile, load, or even run-time in the JVM. Weaving into
bytecodes at both compile and load-time will definitely be provided in a
future release. This will allow weaving at compile-time into libraries
for which source code is not available. It will also support
aspect-aware class loaders that can perform weaving at load time on
arbitrary classes. One advantage of a language like AspectJ, rather than
an explicit meta-tool like jiapi, is that it separates the specification
of a crosscutting concern from any particular implementation strategy
for weaving.</p>
</div>
<div class="paragraph">
<p>&#8230;&#8203;AspectJ provides a language that can cleanly capture crosscutting
concerns while preserving the static type checking, modularity, and
composability of Java.</p>
</div>
<div class="paragraph">
<p>If you have an application for using aspects and bytecode, please let
the AspectJ team know of your requirements. We expect to have a
demonstration classloader available in the 1.1 release or soon
thereafter.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> What are the differences between the current and previously
released versions of AspectJ?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> The AspectJ team aims to keep the implementation bug-free and
up-to-date with the Java language, to limit AspectJ language changes to
those that are carefully considered, compelling, and
backwards-compatible, and to deliver those language changes only in
significant releases (1.0, 1.1).</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Version</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">AspectJ 1.5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Upgrade to support Java 5 language and much better
load-time weaving. See README-1.5.0.html for more details.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">AspectJ 1.1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A few language changes and clarifications; bytecode
weaving and incremental compilation. See README-1.1.html for more detail.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">AspectJ 1.0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Many language changes, fixes, cleanup and clarifications,
some significant.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">AspectJ 0.8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">More cleanup of the syntax and semantics.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">AspectJ 0.7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Clean up of the semantics, 0.7 beta 4 is the first open
source release.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">AspectJ 0.6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Advice and crosscuts get explicit type signatures which
describe the values that are available to advice at a crosscut.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">AspectJ 0.5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Improved tool support: better Emacs environment support
and <code>ajdoc</code> to parallel <code>javadoc</code>. around advice is added, and the
<code>aspect</code> keyword is removed and replaced by the Java keyword class.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">AspectJ 0.4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Clear separation of crosscuts and crosscut actions makes
it possible to define extensible library aspects.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">AspectJ 0.3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">First all Java implementation, also includes many small
language improvements.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">AspectJ 0.2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">General-purpose support for crosscutting. Users could
program any kind of aspects, not just coordination. This release dropped
COOL.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">AspectJ 0.1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A single domain-specific aspect language, called COOL, for
programming coordination in multi-threaded programs.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>More details for 1.0 and earlier releases are available in changes.html.</p>
</div>
<div class="paragraph">
<p><strong>Q:</strong> What is the AspectJ development schedule?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> Below is a table describing the goals for the major releases. For
information about specific features, search the bug database for <code>RFE</code>'s
("requests for enhancement") by
<a href="https://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;bug_severity=enhancement">selecting
severity of "enhancement"</a>. Like many open-source projects, we don&#8217;t
make or promise schedules, but we do follow a pattern of issuing preview
releases which can give observers an idea of when a particular release
might be available.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 2. The AspectJ Development Schedule</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Version</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Final syntax and semantic changes. Standalone structure browser.
Complete documentation.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Faster incremental compilation, bytecode weaving, and a small
number of language changes.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Faster weaving, -inpath option, better error messages, better
handling of binary input and resources during incremental compilation,
faster runtime</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.5 (AspectJ 5)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Support for Java 1.5, generic aspects, annotations,
etc. Integrates AspectWerkz-style load-time weaving.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Q:</strong> Will AspectJ support Java 5?</p>
</div>
<div class="paragraph">
<p><strong>A:</strong> Yes. Java 5 is supported in AspectJ 5.</p>
</div>
<div class="paragraph">
<p>AspectJ is a registered trademark of Palo Alto Research Center,
Incorporated (PARC), used with permission. Java and all Java-based marks
are trademarks or registered trademarks of Sun Microsystems, Inc. in the
United States and other countries. All other trademarks are the property
of their respective owners.</p>
</div>
</div>
</div>
</div>
</body>
</html>