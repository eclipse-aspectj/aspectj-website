<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.20">
<title>Guide for Developers of the AspectJ Compiler and Weaver</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="./asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="./coderay-asciidoctor.css">
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Guide for Developers of the AspectJ Compiler and Weaver</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_guide_for_developers_of_the_aspectj_compiler_and_weaver">Guide for Developers of the AspectJ Compiler and Weaver</a>
<ul class="sectlevel2">
<li><a href="#_compiler_front_end_org_aspectj_ajdt_core">Compiler front-end (org.aspectj.ajdt.core)</a></li>
<li><a href="#_weaving_back_end_weaver">Weaving back-end (weaver)</a></li>
<li><a href="#_runtime_support_library_runtime">Runtime support library (runtime)</a></li>
<li><a href="#_mappings_from_aspectj_language_to_implementation">Mappings from AspectJ language to implementation</a></li>
</ul>
</li>
<li><a href="#_tutorial_implementing_a_throw_join_point">Tutorial: implementing a throw join point</a>
<ul class="sectlevel2">
<li><a href="#_part_1_adding_the_join_point_and_corresponding_pcd">Part 1: Adding the join point and corresponding pcd</a></li>
<li><a href="#_part_2_getting_the_signature_of_this_new_join_point_right">Part 2: Getting the signature of this new join point right</a></li>
<li><a href="#_part_3_more_serious_testing">Part 3: More serious testing</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_guide_for_developers_of_the_aspectj_compiler_and_weaver">Guide for Developers of the AspectJ Compiler and Weaver</h2>
<div class="sectionbody">
<div class="paragraph">
<p><em>Latest (non-license) content update: 2004-02-20 by jhugunin</em></p>
</div>
<div class="paragraph">
<p>This document is written for developers who want to understand the
implementation of AspectJ. It provides a top-down picture of the
compiler and weaver implementations. This high-level picture should make
it easier to read and understand the source code for AspectJ.</p>
</div>
<div class="paragraph">
<p>The AspectJ compiler/weaver (ajc) is composed of three primary modules.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>org.aspectj.ajdt.core</strong> - this is the compiler front-end and extends
the eclipse Java compiler from <strong>org.eclipse.jdt.core</strong>. Because of the
dependencies on parts of eclipse this generates a large ~6MB jar.</p>
</li>
<li>
<p><strong>weaver</strong> - this provides the bytecode weaving functionality. It has
very few external dependencies to minimize the size required for
deployment of load-time weavers. Currently the build process doesn&#8217;t
produce a separate jar for just the weaver, but that will have to change
for AspectJ-1.2.</p>
</li>
<li>
<p><strong>runtime</strong> - these are the classes that are used by generated code at
runtime and must be redistributed with any system built using AspectJ.
This module has no external dependencies and produces a tiny ~30KB jar.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/overview.png" alt="image"></span></p>
</div>
<div class="paragraph">
<p>The AspectJ compiler accepts both AspectJ bytecode and source code and
produces pure Java bytecode as a result. Internally it has two stages.
The front-end (org.aspectj.ajdt.core) compiles both AspectJ and pure
Java source code into pure Java bytecode annotated with additional
attributes representing any non-java forms such as advice and pointcut
declarations. The back-end of the AspectJ compiler (weaver) implements
the transformations encoded in these attributes to produce woven class
files. The back-end can be run stand-alone to weave pre-compiled aspects
into pre-compiled .jar files. In addition, the back-end exposes a
weaving API which can be used to implement ClassLoaders that will weave
advice into classes dynamically as they are loaded by the virtual
machine.</p>
</div>
<div class="sect2">
<h3 id="_compiler_front_end_org_aspectj_ajdt_core">Compiler front-end (org.aspectj.ajdt.core)</h3>
<div class="paragraph">
<p>The front-end of the AspectJ compiler is implemented as an extension of
the Java compiler from eclipse.org. The source-file portion of the
AspectJ compiler is made complicated by inter-type declarations, declare
parents, declare soft, and privileged aspects. All of these constructs
require changes to the underlying compiler to modify Java’s name-binding
and static checking behavior.</p>
</div>
<div class="paragraph">
<p>As the compiler extends the jdt.core compiler, the package structure of
this module mimics that of the jdt.core module. The design works hard to
minimize the set of changes required to org.eclipse.jdt.core because a
fun 3-way merge is required each time we want to move to a new
underlying version of this code. The ultimate goal is to contribute all
of our changes to jdt.core back into the main development branch some
day.</p>
</div>
<div class="paragraph">
<p>The basic structure of a compile is very simple:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Perform a shallow parse on all source files</p>
</li>
<li>
<p>Pass these compilation units through AjLookupManager to do type
binding and some AspectJ augmentation</p>
</li>
<li>
<p>For each source file do a deep parse, annotation/analysis, and then
code generation</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="_top_level_parse_tree">Top-level parse tree</h4>
<div class="paragraph">
<p>Let&#8217;s trace the following example program through the compiler.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">example.parse.tree</span>;

<span class="keyword">import</span> <span class="include">org.aspectj.lang</span>.*;

<span class="directive">public</span> <span class="type">class</span> <span class="class">Main</span> {
    <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
        <span class="keyword">new</span> Main().doit();
    }

    <span class="directive">private</span> <span class="type">void</span> doit() {
        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">hello</span><span class="delimiter">&quot;</span></span>);
    }
}

aspect A {
    pointcut entries(Main o): execution(<span class="type">void</span> doit()) &amp;&amp; <span class="local-variable">this</span>(o);
    before(Main o): entries(o) {
        o.counter++;
        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">entering: </span><span class="delimiter">&quot;</span></span> + thisJoinPoint);
    }

    <span class="directive">private</span> <span class="type">int</span> Main.counter = <span class="integer">0</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When parsed, this program will produce the following tree.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/top-tree.png" alt="image"></span></p>
</div>
</div>
<div class="sect3">
<h4 id="_pointcutdeclaration_processing">PointcutDeclaration processing</h4>
<div class="paragraph">
<p>Let&#8217;s look more closely at the pointcut declaration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">pointcut entries(Main o): execution(<span class="type">void</span> doit()) &amp;&amp; <span class="local-variable">this</span>(o);</code></pre>
</div>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/pointcut-dec.png" alt="image"></span></p>
</div>
<div class="paragraph">
<p>The pointcut declaration is implemented as a subtype of a method
declaration. The actual pointcut is parsed by the weaver module. This
parsing happens as part of the shallow parse phase. This is because this
information might be needed to implement a declare soft.</p>
</div>
</div>
<div class="sect3">
<h4 id="_advicedeclaration_processing">AdviceDeclaration processing</h4>
<div class="paragraph">
<p>Next we look at the processing for an advice declaration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">before(Main o): entries(o) {
    o.counter++;
    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">entering: </span><span class="delimiter">&quot;</span></span> + thisJoinPoint);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>After parsing, the AdviceDeclaration.postParse method will be called to
make this a valid MethodDeclaration so that the standard eclipse code
for analyzing a method body can be applied to the advice. After
postParse, the selector is filled in and several additional arguments
are added for the special thisJoinPoint forms that could be used in the
body.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/advice-dec.png" alt="image"></span></p>
</div>
<div class="paragraph">
<p>At this point the statements field which will hold the body of the
advice is still null. This field is not filled in until the second stage
of the compiler when full parsing is done on each source file as a
prelude to generating the classfile.</p>
</div>
</div>
<div class="sect3">
<h4 id="_overview_of_the_main_classes_in_org_aspectj_ajdt_core">Overview of the main classes in org.aspectj.ajdt.core</h4>
<div class="paragraph">
<p>The main classes in this module are shown in the following diagram:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/ajdt-uml.png" alt="image"></span></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_weaving_back_end_weaver">Weaving back-end (weaver)</h3>
<div class="paragraph">
<p>This provides all of the weaving functionality. It has very few
dependencies to keep the code as small as possible for deployment in
load-time weavers - only asm, bridge and util which are each very small
modules with no further dependencies. This also depends on a patched
version of the bcel library from apache.org. The patches are only to fix
bcel bugs that can&#8217;t be worked around in any other way.</p>
</div>
<div class="paragraph">
<p>There are only four packages in this system.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>org.aspectj.weaver - general classes that can be used by any weaver
implementation</p>
</li>
<li>
<p>org.aspectj.weaver.patterns - patterns to represent pointcut
designators and related matching constructs</p>
</li>
<li>
<p>org.aspectj.weaver.ast - a very small library to represent simple
expressions without any bcel dependencies</p>
</li>
<li>
<p>org.aspectj.weaver.bcel - the concrete implementation of shadows and
the weaver using the bcel library from apache.org</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The back-end of the AspectJ compiler instruments the code of the system
by inserting calls to the precompiled advice methods. It does this by
considering that certain principled places in bytecode represent
possible join points; these are the “static shadow” of those join
points. For each such static shadow, it checks each piece of advice in
the system and determines if the advice&#8217;s pointcut could match that
static shadow. If it could match, it inserts a call to the advice’s
implementation method guarded by any dynamic testing needed to ensure
the match.</p>
</div>
</div>
<div class="sect2">
<h3 id="_runtime_support_library_runtime">Runtime support library (runtime)</h3>
<div class="paragraph">
<p>This library provides classes that are used by the generated code at
runtime. These are the only classes that must be redistributed with a
system built using AspectJ. Because these classes are redistributed
this library must always be kept as small as possible. It is also
important to worry about binary compatibility when making changes to
this library. There are two packages that are considered public and may
be used by AspectJ programs.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>org.aspectj.lang</p>
</li>
<li>
<p>org.apectj.lang.reflect</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There are also several packages all under the header org.aspectj.runtime
that are considered private to the implementation and may only be used
by code generated by the AspectJ compiler.</p>
</div>
</div>
<div class="sect2">
<h3 id="_mappings_from_aspectj_language_to_implementation">Mappings from AspectJ language to implementation</h3>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-left valign-top">org.aspectj.ajdt.internal.compiler</th>
<th class="tableblock halign-left valign-top">weaver - org.aspectj.weaver.</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">aspect</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ast.AspectDeclaration</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CrosscuttingMembers</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">advice</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ast.AdviceDeclaration</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Advice + bcel.BcelShadowMunger</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">pointcut declaration</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ast.PointcutDeclaration</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ResolvedPointcutDefinition</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">declare error/warning</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ast.DeclareDeclaration</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Checker<br>
patterns.DeclareErrorOrWarning</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">declare soft</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ast.DeclareDeclaration + problem.AjProblemReporter</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Advice (w/ kind = Softener) + patterns.DeclareSoft</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">declare parents</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ast.DeclareDeclaration + lookup.AjLookupEnvironment</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">patterns.DeclareParents + NewParentTypeMunger</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">inter-type decls</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ast.InterType*Declaration + lookup.InterType*Binding
+ lookup.AjLookupEnvironment</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">New*TypeMunger + bcel.BcelTypeMunger</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">if pcd</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ast.IfPseudoToken + ast.IfMethodDeclaration</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">patterns.IfPointcut</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">pcd</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ast.PointcutDesignator</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">patterns.Pointcut hierarchy</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tutorial_implementing_a_throw_join_point">Tutorial: implementing a throw join point</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This tutorial will walk step-by-step through the process of adding a new
join point to AspectJ for the moment when an exception is thrown. In
Java source code, the shadow of this point is a throw statement. In Java
bytecode, the shadow is the athrow instruction.</p>
</div>
<div class="paragraph">
<p>This tutorial is recommended to anyone who wants to get a better feel
for how the implementation of AspectJ really works. Even if you&#8217;re just
working on a bug fix or minor enhancement, the process of working with
the AspectJ implementation will be similar to that described below. The
size of your actual code changes will likely be smaller, but you are
likely to need to be familiar with all of the pieces of the
implementation described below.</p>
</div>
<div class="sect2">
<h3 id="_part_1_adding_the_join_point_and_corresponding_pcd">Part 1: Adding the join point and corresponding pcd</h3>
<div class="paragraph">
<p>The first part of this tutorial will implement the main features of the
throw join point. We will create a new join point shadow corresponding
to the athrow instruction and also create a new pointcut designator
(pcd) for matching it.</p>
</div>
<div class="sect3">
<h4 id="_step_1_synchronize_with_repository_and_run_the_existing_test_suite">Step 1. Synchronize with repository and run the existing test suite</h4>
<div class="paragraph">
<p>Do a Team&#8594;Synchronize With Repository and make sure that your tree is
completely in sync with the existing repository. Make sure to address
any differences before moving on.</p>
</div>
<div class="paragraph">
<p>Run the existing test suite. I currently do this in four steps:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>weaver/testsrc/BcWeaverModuleTests.java</p>
</li>
<li>
<p>org.aspectj.ajdt.core/testsrc/EajcModuleTests.java</p>
</li>
<li>
<p>ajde/testsrc/AjdeModuleTests.java</p>
</li>
<li>
<p>Harness on ajctests.xml&#8201;&#8212;&#8201;at least under 1.4, preferably under both
1.3 and 1.4.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There should be no failures when you run these tests. If there are
failures, resolve them with the AspectJ developers before moving on.</p>
</div>
</div>
<div class="sect3">
<h4 id="_step_2_write_a_proto_test_case">Step 2. Write a proto test case</h4>
<div class="paragraph">
<p>a. Create a new file in tests/design/pcds/Throw.java</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.aspectj.testing.Tester</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">Throws</span> {
    <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
        <span class="keyword">try</span> {
            willThrow();
            Tester.checkFailed(<span class="string"><span class="delimiter">&quot;</span><span class="content">should have thrown exception</span><span class="delimiter">&quot;</span></span>);
        } <span class="keyword">catch</span> (<span class="exception">RuntimeException</span> re) {
            Tester.checkEqual(<span class="string"><span class="delimiter">&quot;</span><span class="content">expected exception</span><span class="delimiter">&quot;</span></span>, re.getMessage());
        }
    }

    <span class="directive">static</span> <span class="type">void</span> willThrow() {
        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">RuntimeException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">expected exception</span><span class="delimiter">&quot;</span></span>);
    }
}

aspect A {
    before(): withincode(<span class="type">void</span> willThrow()) {
        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">about to execute: </span><span class="delimiter">&quot;</span></span> + thisJoinPoint);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>b. Create a temporary test harness file to run just this test in
myTests.xml</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="doctype">&lt;!DOCTYPE suite SYSTEM &quot;../tests/ajcTestSuite.dtd&quot;&gt;</span>
<span class="tag">&lt;suite&gt;</span>
    <span class="tag">&lt;ajc-test</span> <span class="attribute-name">dir</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">design/pcds</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">title</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">simple throw join point</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;compile</span> <span class="attribute-name">files</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Throws.java</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
        <span class="tag">&lt;run</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Throws</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
    <span class="tag">&lt;/ajc-test&gt;</span>
<span class="tag">&lt;/suite&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>c. Run this test using the harness. You should see:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">about to execute: execution(void Throws.willThrow())
about to execute: call(java.lang.RuntimeException(String))
PASS Suite.Spec(c:\aspectj\eclipse\tests) 1 tests (1 passed) 2 seconds</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_step_3_implement_the_new_join_point_shadow_kind">Step 3. Implement the new join point shadow kind</h4>
<div class="paragraph">
<p>Modify runtime/org.aspectj.lang/JoinPoint.java to add a name for the
Throw shadow kind.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">static</span> <span class="predefined-type">String</span> THROW = <span class="string"><span class="delimiter">&quot;</span><span class="content">throw</span><span class="delimiter">&quot;</span></span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Modify weaver/org.aspectj.weaver/Shadow.java to add the Throw shadow
kind. This adds a static typesafe enum for the Throw Kind. The
constructor uses the name from the runtime API to ensure that these
names will always match. The '12' is used for serialization of this kind
to classfiles and is part of the binary API for aspectj. The final
'true' indicates that this joinpoint has its arguments on the stack.
This is because the throw bytecode in Java operates on a single argument
that is a Throwable which must be the top element on the stack. This
argument is removed from the stack by the bytecode.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="directive">final</span> Kind Throw = <span class="keyword">new</span> Kind(JoinPoint.THROW, <span class="integer">12</span>, <span class="predefined-constant">true</span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>We also modify the neverHasTarget method to include the Throw kind
because in Java there is no target for the throwing of an exception.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">boolean</span> neverHasTarget() {
    <span class="keyword">return</span> <span class="local-variable">this</span> == ConstructorCall
        || <span class="local-variable">this</span> == ExceptionHandler
        || <span class="local-variable">this</span> == PreInitialization
        || <span class="local-variable">this</span> == StaticInitialization
        || <span class="local-variable">this</span> == Throw;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the read method on Shadow.Kind, add another case to read in our new
Shadow.Kind.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">case</span> <span class="integer">12</span>: <span class="keyword">return</span> Throw;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_step_4_create_this_new_kind_of_joinpoint_for_the_throw_bytecode">Step 4. Create this new kind of joinpoint for the throw bytecode</h4>
<div class="paragraph">
<p>Modify weaver/org.aspectj.weaver.bcel/BcelClassWeaver.java to recognize
this new joinpoint kind. In the method</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">private</span> <span class="type">void</span> match(
    LazyMethodGen mg,
    InstructionHandle ih,
    BcelShadow enclosingShadow,
    <span class="predefined-type">List</span> shadowAccumulator)
{</code></pre>
</div>
</div>
<div class="paragraph">
<p>Add a test for this instruction, i.e.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">} <span class="keyword">else</span> <span class="keyword">if</span> (i == InstructionConstants.ATHROW) {
    match(BcelShadow.makeThrow(world, mg, ih, enclosingShadow),
          shadowAccumulator);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, modify BcelShadow.java to create this new kind of join point
shadow:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> BcelShadow makeThrow(
        BcelWorld world,
        LazyMethodGen enclosingMethod,
        InstructionHandle throwHandle,
        BcelShadow enclosingShadow)
{
    <span class="directive">final</span> InstructionList body = enclosingMethod.getBody();
    TypeX throwType = TypeX.THROWABLE; <span class="comment">//!!! not as precise as we'd like</span>
    TypeX inType = enclosingMethod.getEnclosingClass().getType();
    BcelShadow s =
        <span class="keyword">new</span> BcelShadow(
            world,
            Throw,
            <span class="predefined-type">Member</span>.makeThrowSignature(inType, throwType),
            enclosingMethod,
            enclosingShadow);
    ShadowRange r = <span class="keyword">new</span> ShadowRange(body);
    r.associateWithShadow(s);
    r.associateWithTargets(
        Range.genStart(body, throwHandle),
        Range.genEnd(body, throwHandle));
    retargetAllBranches(throwHandle, r.getStart());
    <span class="keyword">return</span> s;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally modify weaver/org.aspectj.weaver/Member.java to generate the
needed signature</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="predefined-type">Member</span> makeThrowSignature(TypeX inType, TypeX throwType) {
    <span class="keyword">return</span> <span class="keyword">new</span> <span class="predefined-type">Member</span>(
        HANDLER,
        inType,
        <span class="predefined-type">Modifier</span>.STATIC,
        <span class="string"><span class="delimiter">&quot;</span><span class="content">throw</span><span class="delimiter">&quot;</span></span>,
        <span class="string"><span class="delimiter">&quot;</span><span class="content">(</span><span class="delimiter">&quot;</span></span> + throwType.getSignature() + <span class="string"><span class="delimiter">&quot;</span><span class="content">)V</span><span class="delimiter">&quot;</span></span>);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Run the proto test again and you should see:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">about to execute: execution(void Throws.willThrow())
about to execute: call(java.lang.RuntimeException(String))
about to execute: throw(catch(Throwable))
PASS Suite.Spec(c:\aspectj\eclipse\tests) 1 tests (1 passed) 3 seconds</code></pre>
</div>
</div>
<div class="paragraph">
<p>That last line shows the 'throw(catch(Throwable))' join point. This is a
slightly confusing string form, but it is the first sign of our brand
new join point. The reason for the weird 'catch(Throwable)' part is that
we used Member.HANDLER for the kind of the signature of this join point.
That&#8217;s clearly not correct. We&#8217;ll fix that at the end of the lesson as
part of the clean-up. For now, let&#8217;s go on with the interesting parts.</p>
</div>
</div>
<div class="sect3">
<h4 id="_step_5_extend_our_proto_test_to_use_a_pointcut_designator_for_matching">Step 5. Extend our proto-test to use a pointcut designator for matching</h4>
<div class="paragraph">
<p>Add a second piece of before advice to the test aspect A:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">before(): <span class="keyword">throw</span>(<span class="predefined-type">Throwable</span>) {
    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">about to throw: </span><span class="delimiter">&quot;</span></span> + thisJoinPoint);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When we run the test again we&#8217;ll get a long error message from the
harness. The interesting part of the message is the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">[  0] [error   0]: error can't find referenced pointcut at C:\aspectj\eclipse\tests\design\pcds\Throws.java:23:0</code></pre>
</div>
</div>
<div class="paragraph">
<p>This error is not quite what you might have expected. You might have
hoped for a syntax error saying that there is not 'throw' pointcut
designator defined. Unfortunately, this is a weakness in the syntax of
AspectJ where primitive PCDs and named PCDs have the same syntax, so the
compiler can&#8217;t tell the difference between a misspelled or non-existent
primitive PCD and a named PCD reference that is missing. This also has
some impact on extending the primitive PCDs because it will break
existing programs. In this case, when we add the throw PCD we will break
any existing programs that use throw as the name for a user-defined PCD.
Fortunately because throw is a Java keyword this particular change is
very safe.</p>
</div>
</div>
<div class="sect3">
<h4 id="_step_6_extend_the_pcd_parser_to_handle_this_new_primitive_pcd">Step 6. Extend the PCD parser to handle this new primitive PCD</h4>
<div class="paragraph">
<p>Modify the parseSinglePointcut method in
weaver/org.aspectj.weaver.patterns/PatternParser.java to add one more
else if clause for the throw pcd:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">} <span class="keyword">else</span>  <span class="keyword">if</span> (kind.equals(<span class="string"><span class="delimiter">&quot;</span><span class="content">throw</span><span class="delimiter">&quot;</span></span>)) {
    parseIdentifier(); eat(<span class="string"><span class="delimiter">&quot;</span><span class="content">(</span><span class="delimiter">&quot;</span></span>);
    TypePattern typePat = parseTypePattern();
    eat(<span class="string"><span class="delimiter">&quot;</span><span class="content">)</span><span class="delimiter">&quot;</span></span>);
    <span class="keyword">return</span> <span class="keyword">new</span> KindedPointcut(Shadow.Throw,
        <span class="keyword">new</span> SignaturePattern(<span class="predefined-type">Member</span>.HANDLER, ModifiersPattern.ANY,
            TypePattern.ANY, TypePattern.ANY, NamePattern.ANY,
            <span class="keyword">new</span> TypePatternList(<span class="keyword">new</span> TypePattern<span class="type">[]</span> {typePat}),
            ThrowsPattern.ANY));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Modify the matches method in
weaver/org.aspectj.weaver.patterns/SignaturePattern.java to add:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">if</span> (kind == <span class="predefined-type">Member</span>.HANDLER) {
    <span class="keyword">return</span> parameterTypes.matches(world.resolve(sig.getParameterTypes()),
                                  TypePattern.STATIC).alwaysTrue();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Run the proto test again and you should see:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">about to execute: execution(void Throws.willThrow())
about to execute: call(java.lang.RuntimeException(String))
about to execute: throw(catch(Throwable))
about to throw: throw(catch(Throwable))
PASS Suite.Spec(c:\aspectj\eclipse\tests) 1 tests (1 passed) 1 seconds</code></pre>
</div>
</div>
<div class="paragraph">
<p>Make sure that you see the 'about to throw' printed before moving on.
This shows that the throw PCD is now successfully matching the throw
join point shadow we added earlier.</p>
</div>
</div>
<div class="sect3">
<h4 id="_step_7_check_that_were_properly_providing_the_single_thrown_argument_and_clean_up_the_test">Step 7. Check that we&#8217;re properly providing the single thrown argument (and clean-up the test)</h4>
<div class="paragraph">
<p>Now that we have a valid pcd for this advice, we can simplify our test
case. Modify our test aspect A to be the following. In addition to
removing the overly generic withincode pcd, this change also prints the
actual object that is about to be thrown:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect A {
    before(<span class="predefined-type">Throwable</span> t): <span class="keyword">throw</span>(*) &amp;&amp; args(t) {
        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">about to throw: '</span><span class="delimiter">&quot;</span></span> + t+ <span class="string"><span class="delimiter">&quot;</span><span class="content">' at </span><span class="delimiter">&quot;</span></span> + thisJoinPoint);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When we run the test again we should see the output below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">about to throw: 'java.lang.RuntimeException: expected exception' at throw(catch(Throwable))
PASS Suite.Spec(c:\aspectj\eclipse\tests) 1 tests (1 passed) 1 seconds</code></pre>
</div>
</div>
<div class="paragraph">
<p>Congratulations! You&#8217;ve just implemented the throw join point and PCD.
This code isn&#8217;t yet ready to be checked into any repository. It still
has some rough edges that need to be smoothed. However, you&#8217;ve now added
a new join point to the AspectJ language and a corresponding PCD to
match it. This is a good time to take a break before moving on to part
two.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_part_2_getting_the_signature_of_this_new_join_point_right">Part 2: Getting the signature of this new join point right</h3>
<div class="paragraph">
<p>We know that throw(catch(Throwable)) is not the right thing to be
printing for the signature at this join point. What is the correct
signature? At the beginning of the tutorial, we explained that the
preferred design for the pcd was to have
throw(StaticTypeOfExceptionThrown). In step 4, we set the type of the
exception thrown to be 'Throwable'. Can we set this to be more accurate?
Looking at the source code, it seems easy to identify the static type of
the exception that is thrown:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">RuntimeException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">expected exception</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the source code to a Java program there is a well-defined static type
for the exception that is thrown. This static type is used for various
stages of flow analysis to make sure that checked exceptions are always
correctly handled or declared. The ThrowStatement class in our own
compiler has a special field for exceptionType that stores the static
type of the exception thrown. Unfortunately, this static type is much
harder to recover from the corresponding bytecode. In this case we would
need to do flow analysis to figure out what the static type is for the
object on the top of the stack when the athrow instruction executes.
This analysis can certainly be done. In fact this analysis is a small
part of what every JVM must do to verify the type safety of a loaded
classfile.</p>
</div>
<div class="paragraph">
<p>However, the current AspectJ weaver doesn&#8217;t do any of this analysis.
There are many good reasons to extend it in this direction in order to
optimize the code produced by the weaver. If we were really implementing
this feature, this would be the time for a long discussion on the
aspectj-dev list to decide if this was the right time to extend the
weaver with the code flow analysis needed to support a static type for
the throw join point. For the purposes of this tutorial, we&#8217;re going to
assume that it isn&#8217;t the right time to do this (implementing flow
analysis for bytecodes would add another 50 pages to this tutorial).
Instead we&#8217;re going to change the definition of the throw join point to
state that its argument always has a static type of Throwable. We still
allow dynamic matching in args to select more specific types. In
general, good AspectJ code should use this dynamic matching anyway to
correspond to good OO designs.</p>
</div>
<div class="sect3">
<h4 id="_step_1_change_the_signature_of_the_throw_pcd">Step 1. Change the signature of the throw pcd</h4>
<div class="paragraph">
<p>Since we aren&#8217;t going to recover the static type of the exception
thrown, we need to fix the parser for the throw pcd to remove this
information. We&#8217;ll fix the PatternParser code that we added in step 1.6
to read as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">} <span class="keyword">else</span>  <span class="keyword">if</span> (kind.equals(<span class="string"><span class="delimiter">&quot;</span><span class="content">throw</span><span class="delimiter">&quot;</span></span>)) {
    parseIdentifier(); eat(<span class="string"><span class="delimiter">&quot;</span><span class="content">(</span><span class="delimiter">&quot;</span></span>);
    eat(<span class="string"><span class="delimiter">&quot;</span><span class="content">)</span><span class="delimiter">&quot;</span></span>);
    <span class="keyword">return</span> <span class="keyword">new</span> KindedPointcut(Shadow.Throw,
        <span class="keyword">new</span> SignaturePattern(<span class="predefined-type">Member</span>.THROW, ModifiersPattern.ANY,
            TypePattern.ANY, TypePattern.ANY, NamePattern.ANY,
            TypePatternList.ANY,
            ThrowsPattern.ANY));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that this code also starts to fix the member kind to be
Member.THROW instead of the bogus Member.HANDLER that we were using
before. To make this work we have a set of things to do. First, let&#8217;s
create this new kind in org.aspectj.weaver.Member. Find where the
HANDLER kind is defined there, and add a corresponding throw kind:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="directive">final</span> Kind THROW         = <span class="keyword">new</span> Kind(<span class="string"><span class="delimiter">&quot;</span><span class="content">THROW</span><span class="delimiter">&quot;</span></span>, <span class="integer">8</span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>We also need to fix the serialization kind in
Member.Kind.read(DataInputStream) just above this constant list to add a
case for this new kind:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">case</span> <span class="integer">8</span>: <span class="keyword">return</span> THROW;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Still in this file, we also need to fix Member.makeThrowSignature to use
this new kind:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="predefined-type">Member</span> makeThrowSignature(TypeX inType, TypeX throwType) {
    <span class="keyword">return</span> <span class="keyword">new</span> ResolvedMember(
        THROW,
        inType,
        <span class="predefined-type">Modifier</span>.STATIC,
        <span class="string"><span class="delimiter">&quot;</span><span class="content">throw</span><span class="delimiter">&quot;</span></span>,
        <span class="string"><span class="delimiter">&quot;</span><span class="content">(</span><span class="delimiter">&quot;</span></span> + throwType.getSignature() + <span class="string"><span class="delimiter">&quot;</span><span class="content">)V</span><span class="delimiter">&quot;</span></span>);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you run the test now you&#8217;ll get an error from the parser reminding us
that the throw pcd now doesn&#8217;t accept a type pattern:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">------------  FAIL: simple throw join point()
...
C:\aspectj\eclipse\tests\design\pcds\Throws.java:19:0 Syntax error on token &quot;*&quot;, &quot;)&quot; expected

FAIL Suite.Spec(c:\aspectj\eclipse\tests) 1 tests (1 failed) 1 seconds</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is an easy fix to the test case as we modify our pcd for the new
syntax in the aspect A in our Throws.java test code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">before(<span class="predefined-type">Throwable</span> t): <span class="keyword">throw</span>() &amp;&amp; args(t) {</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now when we run the test case it looks like everything&#8217;s fixed and we&#8217;re
passing:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">PASS Suite.Spec(c:\aspectj\eclipse\tests) 1 tests (1 passed) 2 seconds</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_part_2_make_a_real_test_case">Part 2. Make a real test case</h4>
<div class="paragraph">
<p>The pass result from running our test should worry you. Unlike previous
runs, this test run doesn&#8217;t show the output from our System.out.println
in the before advice. So, it&#8217;s clear this advice is not running. The
problem is that even though the advice is not running, the test case is
passing. We need to make this a real test case to fix this. We&#8217;ll do
that by adding code that notes when the advice runs and then checks for
this event. This code uses the Tester.event and Tester.checkEvent
methods:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.aspectj.testing.Tester</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">Throws</span> {
    <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
        <span class="keyword">try</span> {
            willThrow();
            Tester.checkFailed(<span class="string"><span class="delimiter">&quot;</span><span class="content">should have thrown exception</span><span class="delimiter">&quot;</span></span>);
        } <span class="keyword">catch</span> (<span class="exception">RuntimeException</span> re) {
            Tester.checkEqual(<span class="string"><span class="delimiter">&quot;</span><span class="content">expected exception</span><span class="delimiter">&quot;</span></span>, re.getMessage());
        }
        Tester.checkEvents(<span class="keyword">new</span> <span class="predefined-type">String</span><span class="type">[]</span> { <span class="string"><span class="delimiter">&quot;</span><span class="content">before throw</span><span class="delimiter">&quot;</span></span> });
    }

    <span class="directive">static</span> <span class="type">void</span> willThrow() {
        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">RuntimeException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">expected exception</span><span class="delimiter">&quot;</span></span>);
    }
}

aspect A {
    before(<span class="predefined-type">Throwable</span> t): <span class="keyword">throw</span>() &amp;&amp; args(t) {
        Tester.event(<span class="string"><span class="delimiter">&quot;</span><span class="content">before throw</span><span class="delimiter">&quot;</span></span>);
        <span class="comment">//System.out.println(&quot;about to throw: '&quot; + t+ &quot;' at &quot; + thisJoinPoint);</span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now when we run our test case it will fail. This failure is good because
we&#8217;re not matching the throw join point anymore.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">------------  FAIL: simple throw join point()
...
[ 1] [fail 0]: fail [ expected event &quot;before throw&quot; not found]

FAIL Suite.Spec(c:\aspectj\eclipse\tests) 1 tests (1 failed) 1 seconds</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_step_3_fix_signature_matching_again">Step 3. Fix signature matching again</h4>
<div class="paragraph">
<p>In org.aspectj.weaver.patterns.SignaturePattern.matches, we need to
handle throw signature matching the same way we handle advice signature
matching. Both of these pcds match solely on the kind of join point and
use combinations with other pcds to narrow their matches. So, find the
line for kind == Member.ADVICE and add the same line below it for
Member.THROW.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">if</span> (kind == <span class="predefined-type">Member</span>.ADVICE) <span class="keyword">return</span> <span class="predefined-constant">true</span>;
<span class="keyword">if</span> (kind == <span class="predefined-type">Member</span>.THROW) <span class="keyword">return</span> <span class="predefined-constant">true</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This change will make our test case pass again. Run it to be sure.</p>
</div>
<div class="paragraph">
<p>There&#8217;s an interesting tension between a good automated test and a good
test for development. Our new test case now correctly includes an
automated test to let us know when we are and are not matching the new
throw join point. However, without the println the test doesn&#8217;t feel as
satisfactory to me to run during development. I often like to turn this
kind of printing back on the see what&#8217;s happening. If you uncomment to
System.out.println in the test aspect A and rerun the test, you won&#8217;t be
very happy with the results:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">------------  FAIL: simple throw join point()
...
unimplemented
java.lang.RuntimeException: unimplemented
    at org.aspectj.weaver.Member.getSignatureString(Member.java:596)
...

FAIL Suite.Spec(c:\aspectj\eclipse\tests) 1 tests (1 failed) 1 seconds</code></pre>
</div>
</div>
<div class="paragraph">
<p>It looks like there&#8217;s more work to do to add the new member kind for
Member.THROW. This problem only shows up when we try to print
thisJoinPoint. It&#8217;s showing that we haven&#8217;t updated the reflection API
to understand this new signature kind.</p>
</div>
</div>
<div class="sect3">
<h4 id="_step_4_extend_org_aspectj_lang_reflect_to_understand_throw_signatures">Step 4. Extend org.aspectj.lang.reflect to understand throw signatures</h4>
<div class="paragraph">
<p>We need to add a couple of classes to the reflection API to implement
the throw signature. Because we decided at the beginning of this section
to not include the static type of the exception thrown in the throw
signature, these classes are extremely simple. Nevertheless, we have to
build them. Notice that when we add new source files to the system we
need to include the standard eclipse EPL license header.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">/* *******************************************************************
 * Copyright (c) 2006 Contributors.
 * All rights reserved.
 * This program and the accompanying materials are made available
 * under the terms of the Eclipse Public License v 2.0
 * which accompanies this distribution and is available at
 * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt
 *
 * Contributors:
 *     Jim Hugunin    initial implementation
 * ******************************************************************/</span>

<span class="keyword">package</span> <span class="namespace">org.aspectj.lang.reflect</span>;
<span class="keyword">import</span> <span class="include">org.aspectj.lang.Signature</span>;

<span class="directive">public</span> <span class="type">interface</span> <span class="class">ThrowSignature</span> <span class="directive">extends</span> <span class="predefined-type">Signature</span> { }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">/* *******************************************************************
 * Copyright (c) 2006 Contributors.
 * All rights reserved.
 * This program and the accompanying materials are made available
 * under the terms of the Eclipse Public License v 2.0
 * which accompanies this distribution and is available at
 * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt
 *
 * Contributors:
 *     Jim Hugunin    initial implementation
 * ******************************************************************/</span>

<span class="keyword">package</span> <span class="namespace">org.aspectj.runtime.reflect</span>;
<span class="keyword">import</span> <span class="include">org.aspectj.lang.reflect.ThrowSignature</span>;

<span class="type">class</span> <span class="class">ThrowSignatureImpl</span> <span class="directive">extends</span> SignatureImpl <span class="directive">implements</span> ThrowSignature {

    ThrowSignatureImpl(<span class="predefined-type">Class</span> declaringType) {
        <span class="local-variable">super</span>(<span class="integer">0</span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">throw</span><span class="delimiter">&quot;</span></span>, declaringType);
    }

    ThrowSignatureImpl(<span class="predefined-type">String</span> stringRep) {
        <span class="local-variable">super</span>(stringRep);
    }

    <span class="predefined-type">String</span> toString(StringMaker sm) {
        <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">throw</span><span class="delimiter">&quot;</span></span>;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To finish up our work in the runtime module, we need to extend
org.aspectj.runtime.reflect.Factory to add a factory method for this new
signature kind:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> ThrowSignature makeThrowSig(<span class="predefined-type">String</span> stringRep) {
    ThrowSignatureImpl ret = <span class="keyword">new</span> ThrowSignatureImpl(stringRep);
    ret.setLookupClassLoader(lookupClassLoader);
    <span class="keyword">return</span> ret;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We&#8217;re not done yet. We still need to fix up the
org.aspectj.weaver.Member class to use these new methods and types and
fix the unimplemented exception that started us down this road in the
first place. First let&#8217;s add a method to create a string for the throw
signature. This is a very simple method copied from the other
create*SignatureString methods.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">private</span> <span class="predefined-type">String</span> getThrowSignatureString(World world) {
    <span class="predefined-type">StringBuffer</span> buf = <span class="keyword">new</span> <span class="predefined-type">StringBuffer</span>();
    buf.append(<span class="string"><span class="delimiter">'</span><span class="content">-</span><span class="delimiter">'</span></span>); <span class="comment">// no modifiers</span>
    buf.append(<span class="string"><span class="delimiter">'</span><span class="content">-</span><span class="delimiter">'</span></span>); <span class="comment">// no name</span>
    buf.append(makeString(getDeclaringType()));
    buf.append(<span class="string"><span class="delimiter">'</span><span class="content">-</span><span class="delimiter">'</span></span>);
    <span class="keyword">return</span> buf.toString();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we need to modify three methods to add cases for the new
Member.THROW kind. First, Member.getSignatureMakerName add:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">} <span class="keyword">else</span> <span class="keyword">if</span> (kind == THROW) {
    <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">makeThrowSig</span><span class="delimiter">&quot;</span></span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next, to Member.getSignatureType add:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">} <span class="keyword">else</span> <span class="keyword">if</span> (kind == THROW) {
    <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">org.aspectj.lang.reflect.ThrowSignature</span><span class="delimiter">&quot;</span></span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, to Member.getSignatureString add:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">} <span class="keyword">else</span> <span class="keyword">if</span> (kind == THROW) {
    <span class="keyword">return</span> getThrowSignatureString(world);</code></pre>
</div>
</div>
<div class="paragraph">
<p>With all of these changes in place we should have working code for
thisJoinPoint reflection using our new join point and signature kinds.
Rerun the test to confirm:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">about to throw: 'java.lang.RuntimeException: expected exception' at throw(throw)
PASS Suite.Spec(c:\aspectj\eclipse\tests) 1 tests (1 passed) 1 seconds</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_step_5_extend_the_test_for_automated_coverage_of_reflection">Step 5. Extend the test for automated coverage of reflection</h4>
<div class="paragraph">
<p>Modify the before advice to include at least minimal checks of the new
reflective information:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">before(<span class="predefined-type">Throwable</span> t): <span class="keyword">throw</span>() &amp;&amp; args(t) {
    Tester.event(<span class="string"><span class="delimiter">&quot;</span><span class="content">before throw</span><span class="delimiter">&quot;</span></span>);
    Tester.checkEqual(thisJoinPoint.getSignature().toShortString(), <span class="string"><span class="delimiter">&quot;</span><span class="content">throw</span><span class="delimiter">&quot;</span></span>);
    Tester.checkEqual(t.getMessage(), <span class="string"><span class="delimiter">&quot;</span><span class="content">expected exception</span><span class="delimiter">&quot;</span></span>);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As usual, you should rerun the tests and make sure they pass.</p>
</div>
<div class="paragraph">
<p>With these changes to the reflection code, it looks like we have a
working version of the throw join point and there are no obvious pieces
that we&#8217;ve skipped. Take a break before proceeding to the final phase of
tests.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_part_3_more_serious_testing">Part 3: More serious testing</h3>
<div class="paragraph">
<p>Now it&#8217;s time to get a decent testing story. The test work that we will
do here is probably too little for adding a new join point to the
aspectj language; however, it should at least give you a sense of what&#8217;s
involved.</p>
</div>
<div class="sect3">
<h4 id="_step_1_run_the_test_suite_again">Step 1. Run the test suite again</h4>
<div class="paragraph">
<p>Rerun the tests you ran at the beginning of part 1. Any failures that
occur should be resolved at this point. At the time of writing this
tutorial, I found 31 failures in the BcWeaverModuleTests. These failures
are for all of the test cases that check the exact set of shadows
produces by a given program. These test cases need to be updated based
on the new join point we&#8217;re adding. These particular test cases will
probably be removed from the AspectJ test suite very soon because
they&#8217;ve shown themselves to be very fragile over time and they often
break for changes that are not introducing new bugs. However, you should
be aware of this kind of failure because you may find it in other unit
tests.</p>
</div>
<div class="paragraph">
<p>You should expect to see at least one other test case fail when you run
ajcTests.xml. Here&#8217;s the failure message:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">------------  FAIL: validate (enclosing) join point and source locations()
...
[  1] [fail   0]: fail [ unexpected event &quot;before AllTargetJoinPoints throw(throw)&quot; found]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Most of this message can be ignored. To find out what went wrong you
should look for messages that have "fail" in them. The last line tells
you what happened. There was an unexpected event, "before
AllTargetJoinPoints throw(catch(Throwable))". This is the signature for
one of the new throw join points that we added in part 1. How could an
existing test case match this new join point? The failing test case uses
'within(TargetClass)' to collect information about ALL join points that
are lexically within a given class. Whenever we add a new kind of join
point to the language we will extend the set of points matched by pcds
like within. This means that these changes need to be very prominently
noted in the release notes for any AspectJ release. Since we&#8217;re not
writing documentation in this tutorial, we will move on an fix the test
case.</p>
</div>
</div>
<div class="sect3">
<h4 id="_step_2_fix_the_failing_test_case">Step 2. Fix the failing test case</h4>
<div class="paragraph">
<p>Now we need to fix this failing test case. The first step is to copy the
test specification into our local myTests.xml file. The easiest way to
do this is to copy the title of the failing test from the output buffer,
then open ajcTests.xml and use find to search for this title. Then copy
the xml spec for this one test into myTests.xml. Finally, run
myTests.xml to make sure you got the failing test. You should see the
same failure as before in step 1, but you should see it a lot faster
because we&#8217;re only running 2 tests.</p>
</div>
<div class="paragraph">
<p>To fix the test we need to find the source code. If you look at the test
specification, you can see that the source file is the new directory
with the name NegativeSourceLocation.java. Looking at the bottom of this
file, we see a large list of expected events. These are the join points
that we expect to see. If we look back up in TargetClass, we can see
that the only occurence of throw is just before the handler for
catch(Error) and right after the call to new Error. We should add our
new expected event between these two:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">, &quot;before AllTargetJoinPoints call(java.lang.Error(String))&quot;
, &quot;before AllTargetJoinPoints throw(throw)&quot;  // added for new throw join point
, &quot;before AllTargetJoinPoints handler(catch(Error))&quot;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Run the test suite again to see that this test now passes.</p>
</div>
</div>
<div class="sect3">
<h4 id="_step_3_extend_test_coverage_to_after_advice">Step 3. Extend test coverage to after advice</h4>
<div class="paragraph">
<p>There is a lot we should do now to extend test coverage for this new
kind of join point. For the purpose of this tutorial, we&#8217;re just going
to make sure that the new join point kind is compatible with all 5 kinds
of advice. Let&#8217;s extend our current simple Throws test to check for
before and the three kinds of after advice:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.aspectj.testing.Tester</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">Throws</span> {
    <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
        <span class="keyword">try</span> {
            willThrow(<span class="predefined-constant">true</span>);
            Tester.checkFailed(<span class="string"><span class="delimiter">&quot;</span><span class="content">should have thrown exception</span><span class="delimiter">&quot;</span></span>);
        } <span class="keyword">catch</span> (<span class="exception">RuntimeException</span> re) {
            Tester.checkEqual(<span class="string"><span class="delimiter">&quot;</span><span class="content">expected exception</span><span class="delimiter">&quot;</span></span>, re.getMessage());
        }
        Tester.checkEvents(<span class="keyword">new</span> <span class="predefined-type">String</span><span class="type">[]</span>
            { <span class="string"><span class="delimiter">&quot;</span><span class="content">before throw</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">after throwing throw</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">after throw</span><span class="delimiter">&quot;</span></span> });
    }

    <span class="directive">static</span> <span class="type">void</span> willThrow(<span class="type">boolean</span> shouldThrow) {
        <span class="type">int</span> x;
        <span class="keyword">if</span> (shouldThrow) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">RuntimeException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">expected exception</span><span class="delimiter">&quot;</span></span>);
        <span class="keyword">else</span> x = <span class="integer">42</span>;
        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">x = </span><span class="delimiter">&quot;</span></span> + x);
    }
}

aspect A {
    before(<span class="predefined-type">Throwable</span> t): <span class="keyword">throw</span>() &amp;&amp; args(t) {
        Tester.event(<span class="string"><span class="delimiter">&quot;</span><span class="content">before throw</span><span class="delimiter">&quot;</span></span>);
        Tester.checkEqual(thisJoinPoint.getSignature().toShortString(), <span class="string"><span class="delimiter">&quot;</span><span class="content">throw</span><span class="delimiter">&quot;</span></span>);
        Tester.checkEqual(t.getMessage(), <span class="string"><span class="delimiter">&quot;</span><span class="content">expected exception</span><span class="delimiter">&quot;</span></span>);
    }

    after() returning: <span class="keyword">throw</span>() {
        Tester.checkFailed(<span class="string"><span class="delimiter">&quot;</span><span class="content">shouldn't ever return normally from a throw</span><span class="delimiter">&quot;</span></span>);
    }

    after() throwing(<span class="exception">RuntimeException</span> re): <span class="keyword">throw</span>() {
        Tester.event(<span class="string"><span class="delimiter">&quot;</span><span class="content">after throwing throw</span><span class="delimiter">&quot;</span></span>);
        Tester.checkEqual(re.getMessage(), <span class="string"><span class="delimiter">&quot;</span><span class="content">expected exception</span><span class="delimiter">&quot;</span></span>);
    }

    after(): <span class="keyword">throw</span>() {
        Tester.event(<span class="string"><span class="delimiter">&quot;</span><span class="content">after throw</span><span class="delimiter">&quot;</span></span>);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Run this test to confirm that it still passes. This is a very nice
property of the orthogonality of the implementation of join points and
advice. We never had to do any implementation work to make our new join
point kind work for before and all three kinds of after advice.</p>
</div>
</div>
<div class="sect3">
<h4 id="_step_4_look_at_around_advice_on_throw_join_points">Step 4. Look at around advice on throw join points</h4>
<div class="paragraph">
<p>Let&#8217;s create a new test case to see how this new join point interacts
with around advice.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.aspectj.testing.Tester</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">AroundThrows</span> {
    <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
        <span class="keyword">try</span> {
            willThrow(<span class="predefined-constant">true</span>);
            Tester.checkFailed(<span class="string"><span class="delimiter">&quot;</span><span class="content">should have thrown exception</span><span class="delimiter">&quot;</span></span>);
        } <span class="keyword">catch</span> (<span class="exception">RuntimeException</span> re) {
            Tester.checkEqual(<span class="string"><span class="delimiter">&quot;</span><span class="content">expected exception</span><span class="delimiter">&quot;</span></span>, re.getMessage());
        }
    }

    <span class="directive">static</span> <span class="type">void</span> willThrow(<span class="type">boolean</span> shouldThrow) {
        <span class="type">int</span> x;
        <span class="keyword">if</span> (!shouldThrow) x = <span class="integer">42</span>;
        <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">RuntimeException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">expected exception</span><span class="delimiter">&quot;</span></span>);
        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">x = </span><span class="delimiter">&quot;</span></span> + x);
    }
}

aspect A {
    <span class="type">void</span> around(): <span class="keyword">throw</span>() {
        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">about to throw something</span><span class="delimiter">&quot;</span></span>);
        proceed();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When we run this test case we get a very unpleasant result:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">------------  FAIL: simple throw join point with around()
...
[  1] --- thrown
java.lang.VerifyError: (class: AroundThrows, method: willThrow signature: (Z)V) Accessing value from uninitialized register 1
...
FAIL Suite.Spec(c:\aspectj\eclipse\tests) 3 tests (1 failed, 2 passed) 3 seconds</code></pre>
</div>
</div>
<div class="paragraph">
<p>A VerifyError at runtime is the second worst kind of bug the AspectJ
compiler can produce. The worst is silently behaving incorrectly.</p>
</div>
<div class="paragraph">
<p>Unfortunately, this VerifyError is either impossible or very hard to
fix. Think about what would happen if the around advice body didn&#8217;t call
proceed. In this case the local variable x would in fact be
uninitialized. There is another serious language design question here,
and for a real implementation this would once again be the time to start
a discussion on the aspectj-dev mailing list to reach consensus on the
best design. For the purpose of this tutorial we&#8217;re once again going to
make the language design choice that is easiest to implement and press
on.</p>
</div>
</div>
<div class="sect3">
<h4 id="_step_5_prohibit_around_advice_on_this_new_join_point_kind">Step 5. Prohibit around advice on this new join point kind</h4>
<div class="paragraph">
<p>The easiest solution to implement is to prohibit around advice on throw
join points. There are already a number of these kinds of rules
implemented in the org.aspectj.weaver.Shadow.match(Shadow, World)
method. We can add our new rule at the beginning of the if(kind ==
AdviceKind.Around) block:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">} <span class="keyword">else</span> <span class="keyword">if</span> (kind == AdviceKind.Around) {
     <span class="keyword">if</span> (shadow.getKind() == Shadow.Throw) {
         world.showMessage(IMessage.ERROR,
             <span class="string"><span class="delimiter">&quot;</span><span class="content">around on throw not supported (possibly compiler limitation)</span><span class="delimiter">&quot;</span></span>,
             getSourceLocation(), shadow.getSourceLocation());
         <span class="keyword">return</span> <span class="predefined-constant">false</span>;
     }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now if we rerun our test we&#8217;ll see errors telling us that around is
prohibited on throw join points:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">------------  FAIL: simple throw join point with around()
...
[  0] [error   0]: error at C:\aspectj\eclipse\tests\design\pcds\AroundThrows.java:22 around on throw not supported (possibly compiler limitation)
[  0] [error   1]: error at C:\aspectj\eclipse\tests\design\pcds\AroundThrows.java:16 around on throw not supported (possibly compiler limitation)
...
FAIL Suite.Spec(c:\aspectj\eclipse\tests) 3 tests (1 failed, 2 passed) 3 seconds</code></pre>
</div>
</div>
<div class="paragraph">
<p>To finish this test case up we need to modify the specification to be
looking for these errors as the correct behavior. This will produce the
following specification:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;ajc-test</span> <span class="attribute-name">dir</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">design/pcds</span><span class="delimiter">&quot;</span></span>
  <span class="attribute-name">title</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">simple throw join point with around</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
    <span class="tag">&lt;compile</span> <span class="attribute-name">files</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">AroundThrows.java</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;message</span> <span class="attribute-name">kind</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">error</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">line</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">16</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;message</span> <span class="attribute-name">kind</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">error</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">line</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">22</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
    <span class="tag">&lt;/compile&gt;</span>
<span class="tag">&lt;/ajc-test&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Run myTests.xml one last time to see both tests passing.</p>
</div>
</div>
<div class="sect3">
<h4 id="_step_6_final_preparations_for_a_commit_or_patch">Step 6. Final preparations for a commit or patch</h4>
<div class="paragraph">
<p>You probably want to stop here for the purposes of this tutorial. We&#8217;ve
pointed out several language design decisions that would need to be
resolved before actually adding a throw join point to AspectJ. Some of
those might involve a large amount of additional implementation work. If
this was actually going into the tree, it would also be important to add
several more test cases exploring the space of what can be done with
throw.</p>
</div>
<div class="paragraph">
<p>Assuming those issues were resolved and you are ready to commit this new
feature to the tree there are three steps left to follow:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Move our new test specifications from myTests.xml to the end of
ajcTests.xml</p>
</li>
<li>
<p>Rerun ajcTests.xml and the unit tests to ensure everything&#8217;s okay.</p>
</li>
<li>
<p>Update from the repository to get any changes from other committers
since you started work on this new feature.</p>
</li>
<li>
<p>Rerun ajcTests.xml and the unit tests to make sure nothing broke as a
result of the update.</p>
</li>
<li>
<p>Finally you can commit these changes to the AspectJ tree.</p>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2024-02-01 14:58:10 +0700
</div>
</div>
</body>
</html>