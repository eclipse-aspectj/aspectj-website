<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.20">
<title>AspectJ Porting Notes</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="./asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="./coderay-asciidoctor.css">
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>AspectJ Porting Notes</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#pre-1_2">Porting pre-1.2 code to AspectJ 1.2</a></li>
<li><a href="#pre-1_1">Porting pre-1.1 code to AspectJ 1.1</a></li>
<li><a href="#pre-1_0_4">Porting pre-1.0.4 code</a></li>
<li><a href="#pre-1_0rc1">Porting pre-1.0rc1 code</a></li>
<li><a href="#pre-1_0beta1">Porting pre-1.0beta1 code</a></li>
<li><a href="#pre-1_0alpha1">Porting pre-1.0alpha1 code</a>
<ul class="sectlevel2">
<li><a href="#_1_0a1-pointcuts">Pointcuts</a></li>
<li><a href="#_1_0a1-type-patterns">Type patterns</a></li>
<li><a href="#_1_0a1-advice">Advice</a></li>
<li><a href="#_1_0a1-introduction-and-static">Introduction and static crosscutting</a></li>
<li><a href="#_1_0a1-aspects">Aspects</a></li>
</ul>
</li>
<li><a href="#pre08b3">Porting pre-0.8beta3 code</a>
<ul class="sectlevel2">
<li><a href="#cflowTerminology">Changing cflow terminology</a></li>
<li><a href="#abstractPointcuts">Overriding abstract pointcuts</a></li>
<li><a href="#recursiveAdvice">Limiting recursive advice</a></li>
</ul>
</li>
<li><a href="#pre08b1">Porting pre-0.8beta1 code</a>
<ul class="sectlevel2">
<li><a href="#introSyntax">Rewriting introductions</a></li>
<li><a href="#staticAdvice">Removing static advice</a></li>
<li><a href="#aspect-aspect">Fixing aspect-aspect inheritance</a></li>
<li><a href="#usingPrivateIntroduction">Using private introduction</a></li>
</ul>
</li>
<li><a href="#pre07b11">Porting pre-0.7beta11 code</a>
<ul class="sectlevel2">
<li><a href="#twoArgumentCalls">Removing two-argument calls</a></li>
<li><a href="#adviceInClasses">Removing advice from Class declarations</a></li>
</ul>
</li>
<li><a href="#pre07b10">Porting pre-0.7beta10 code</a>
<ul class="sectlevel2">
<li><a href="#joinPoints">Changing access to thisJoinPoint</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><em>Â© Copyright 1998-2002 Palo Alto Research Center Incorporated,
2003-2004 Contributors. All rights reserved.</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#pre-1_2">Pre-1.2 code</a></p>
</li>
<li>
<p><a href="#pre-1_1">Pre-1.1 code</a></p>
</li>
<li>
<p><a href="#pre-1_0_4">Pre-1.0.4 code</a></p>
</li>
<li>
<p><a href="#pre-1_0rc1">Pre-1.0rc1 code</a></p>
</li>
<li>
<p><a href="#pre-1_0beta1">Pre-1.0beta1 code</a></p>
</li>
<li>
<p><a href="#pre-1_0alpha1">Pre-1.0alpha1 code</a></p>
</li>
<li>
<p><a href="#pre08b3">Pre-0.8beta3 code</a></p>
</li>
<li>
<p><a href="#pre08b1">Pre-0.8beta1 code</a></p>
</li>
<li>
<p><a href="#pre07b11">Pre-0.7beta11 code</a></p>
</li>
<li>
<p><a href="#pre07b10">Pre-0.7beta10 code</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="pre-1_2">Porting pre-1.2 code to AspectJ 1.2</h2>
<div class="sectionbody">
<div class="paragraph">
<p>README-1.2.html contains a discussion of the changes between 1.1 and 1.2.
The key points are:</p>
</div>
<div class="paragraph">
<p><strong>The default AspectJ compiler compliance level is now 1.4</strong> (whereas in
previous releases the default compliance level was 1.3). This has a
number of implications:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>class files generated by the compiler are now JRE v1.2 and upwards
compatible. (At compliance level 1.3, AspectJ generated class files that
were compatible with JRE 1.1 also).</p>
</li>
<li>
<p><code>call</code> pointcuts may match more join points than in the same program
compiled at compliance level 1.3.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The AspectJ compiler can be restored to 1.3 compliance settings by
specifying the "-1.3" option on the command-line.</p>
</div>
<div class="paragraph">
<p>The following example program illustrates the differences in join point
matching with the <code>call</code> pointcut designator between 1.4 and 1.3
compliance levels.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">/*01*/</span> <span class="type">class</span> <span class="class">A</span> {
<span class="comment">/*02*/</span>   <span class="directive">public</span> <span class="type">void</span> doIt() {...};
<span class="comment">/*03*/</span> }
<span class="comment">/*04*/</span>
<span class="comment">/*05*/</span> <span class="type">class</span> <span class="class">B</span> <span class="directive">extends</span> A {
<span class="comment">/*06*/</span>   <span class="directive">public</span> <span class="type">void</span> doThisToo() {...};
<span class="comment">/*07*/</span> }
<span class="comment">/*08*/</span>
<span class="comment">/*09*/</span>
<span class="comment">/*10*/</span> <span class="directive">public</span> <span class="type">class</span> <span class="class">CallsAandB</span> {
<span class="comment">/*11*/</span>
<span class="comment">/*12*/</span>  <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
<span class="comment">/*13*/</span>    B b = <span class="keyword">new</span> B();
<span class="comment">/*14*/</span>    A bInDisguise = <span class="keyword">new</span> B();
<span class="comment">/*15*/</span>
<span class="comment">/*16*/</span>    b.doIt();               <span class="comment">// AspectJ 1.2 matches here</span>
<span class="comment">/*17*/</span>    bInDisguise.doIt();     <span class="comment">// this is never matched</span>
<span class="comment">/*18*/</span>  }
<span class="comment">/*19*/</span>
<span class="comment">/*20*/</span> }
<span class="comment">/*21*/</span>
<span class="comment">/*22*/</span> aspect CallPCDMatchingExample {
<span class="comment">/*23*/</span>
<span class="comment">/*24*/</span>   before() : call(* B.doIt(..)) {
<span class="comment">/*25*/</span>     <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">About to call B.doIt(...)</span><span class="delimiter">&quot;</span></span>);
<span class="comment">/*26*/</span>   }
<span class="comment">/*27*/</span>
<span class="comment">/*28*/</span> }</code></pre>
</div>
</div>
<div class="paragraph">
<p>When this program is compiled with AspectJ 1.2 using the default
compiler options, it will produce one line of output when it is
executed:</p>
</div>
<div class="paragraph">
<p><code>About to call B.doIt(&#8230;&#8203;)</code></p>
</div>
<div class="paragraph">
<p>The same program compiled under AspectJ 1.1 (or using AspectJ 1.2 with
the -1.3 flag specified) does not produce any output when it is run.</p>
</div>
<div class="paragraph">
<p>The reason for the additional call pcd match is that prior to compliance
level 1.4, Java compilers produced bytecodes that call A.doIt() (the
defining type of the method), rather than B.doIt() (the declared type in
the program text). The generated call to A.doIt() is not matched by the
call pcd used in the before advice. At compliance level 1.4, the
bytecodes retain the declared type of the receiver in the program
source, generating a call to B.doIt(), which <em>is</em> matched by the call
pcd.</p>
</div>
<div class="paragraph">
<p>This is a good example of why the recommended style is to use
<code>call(* doIt(..)) &amp;&amp; target(B)</code>, which always matches based on the
actual type of the receiver.</p>
</div>
<div class="paragraph">
<p><strong>New warnings emitted by the compiler for unmatched call pcds.</strong> Because
users have found the static type matching used for a type pattern
specified in a <code>call</code> pcd confusing (as evidenced by the example above),
AspectJ 1.2 has a new Xlint warning which is enable by default. The
compiler will now produce a warning whenever a call pointcut designator
does not match at a join point, and a user may have expected it to.
Compiling the above program using AspectJ 1.2 produces the following
compiler output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">CallsAandB.java:24 warning does not match because declaring type is A, if match desired use target(B) [Xlint:unmatchedSuperTypeInCall]
before() : call(* B.doIt(..)) {
           ^^^^^^^^^^^^^^^

    see also: CallsAandB.java:17


1 warning</code></pre>
</div>
</div>
<div class="paragraph">
<p>The warning is telling us that the call pointcut associated with the
before advice on line 24 of the source file does not match at a join
point where the user may have expected it to. The source location
corresponding to the unmatched join point is indicated by the "see also"
line - in this case line 17 of the source file. At line 17 we find a
call to <code>bInDisguise.doIt()</code>. Since the static type of <code>bInDisguise</code> is
<code>A</code>, this call will never be matched. The warning also tells us a
possible solution if we intended the pointcut to match at this join
point: use <code>call(* doIt(..) &amp;&amp; target(B)</code>.</p>
</div>
<div class="paragraph">
<p>If you find warnings of this kind coming out when you use the AspectJ
1.2 compiler, the recommended fix is to switch to using the <code>target</code>
designator in place of a type pattern in the <code>call</code> pointcut expression.
Note that there is no loss of runtime efficiency here - runtime tests
are only added in the cases where it cannot be determined at compile
time whether the type of the receiver will match the type specified in
the <code>target</code> expression. Note that <code>target</code> cannot be used in <code>declare</code>
statements.</p>
</div>
<div class="paragraph">
<p><strong>Use of non-statically determinable pointcut expressions in declare
statements</strong> has always been forbidden, but prior to 1.2 the AspectJ
compiler did not raise an error if they were used. The AspectJ Language
Semantics appendix states that <code>cflow, cflowbelow, this, target, args</code>
and <code>if</code> pointcut designators cannot be used directly or indirectly
(through a user-defined pointcut) inside of a <code>declare</code> statment. When
moving code from 1.1 to 1.2, additional errors may be raised due to the
stricter policing of this rule. The solution is to recode the declare
statement avoiding pointcut expressions that may require a run-time
test.</p>
</div>
<div class="paragraph">
<p><strong>Interface constructors no longer supported</strong>. Declaring a constructor on
an interface is now (correctly) prohibited, and there will no longer be
a constructor-execution join point for the interface. To initialize a
field declared on an interface, use initialization, e.g.,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">int</span> I.i;
after(I i) returning: initialization(I) &amp;&amp; <span class="local-variable">this</span>(i) { i.i = <span class="integer">2</span>; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>To pick out the constructor-execution for any implementation of I, try</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">execution(I+.new(..))</code></pre>
</div>
</div>
<div class="paragraph">
<p>For more information, see bug
<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=49295">49295</a>.</p>
</div>
<div class="paragraph">
<p><strong>Declaring a static method on an interface</strong> is now (correctly)
prohibited. One workaround is to define a static method on the aspect
instead. For more information, see bug
<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=47754">47754</a>.</p>
</div>
<div class="paragraph">
<p><strong>Watch for problems due to incompatible BCEL versions.</strong> AspectJ 1.2
includes a different version of BCEL than AspectJ 1.1. If you have the
older version of BCEL available earlier on your classpath than the
version included in the 1.2 aspectjtools.jar then you will see errors
like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">C:\work\test\TestAspect.aj error Internal compiler error
java.lang.NoSuchMethodError: org.apache.bcel.generic.InstructionFactory.
createNewArray(Lorg/apache/bcel/generic/Type;S)Lorg/apache/bcel/generic/Instruction;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This typically happens because the old version of BCEL has been included
as a standard extension in your JVM configuration. Ensure you have
removed it from jre/lib/ext under your JDK installation.</p>
</div>
<div class="paragraph">
<p>For more information, see bugs including
<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=60389">60389</a>,
<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=59921">59921</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="pre-1_1">Porting pre-1.1 code to AspectJ 1.1</h2>
<div class="sectionbody">
<div class="paragraph">
<p>README-1.1.html contains a discussion of the language changes from 1.0 to
1.1. The high points:</p>
</div>
<div class="paragraph">
<p>The <code>call(..)</code> pointcut designator is now implemented only at the call
site; by contrast, the AspectJ 1.0 compiler could also implement it on
the callee side. So in 1.0 if you compiled a pointcut using <code>call(..)</code>
but only passed the compiler the code for the target of the call, the
pointcut could be implemented. This is not true for 1.1. To fix this,
use <code>execution(..)</code> in place of <code>call(..)</code>, or include all calling
clients in the compile. (<a href="README-1.1.html#NO_CALLEE_SIDE_CALL">more
info</a>)</p>
</div>
<div class="paragraph">
<p>Type-patterns are no longer permitted for the defining type of
inter-type declarations. Replace the pattern with a type. In many cases,
you can declare members on an interface type, and then declare that the
types picked out by the type-pattern implement have the interface as
their parent. (<a href="README-1.1.html#SINGLE_INTERCLASS_TARGET">more info</a>)</p>
</div>
<div class="paragraph">
<p>Type-patterns are no longer permitted when specifying <code>declare soft</code>.
Replace the pattern with a literal type.</p>
</div>
<div class="paragraph">
<p>Wildcards patterns (<code>foo..*</code>) are no longer permitted for <code>this()</code>,
<code>target()</code>, or <code>args()</code>. Replace the pattern with a literal type or with
a subtype wildcard (<code>Type+</code>).
(<a href="README-1.1.html#INSTANCEOF_ON_WILD">more info</a>)</p>
</div>
<div class="paragraph">
<p>Conflicts will be reported for no-argument constructors generated by
compilers when no constructor is defined for a class. That means the
following code will compile in 1.0 but not in 1.1:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">C</span> {}
aspect A {
   C.new() {}  <span class="comment">// permitted in 1.0; conflict in 1.1</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>One fix is to declare a non-conflicting constructor by adding arguments
(or defining a constructor in the target class); a better fix might be
to do the work of the declared constructor in advice on the
initialization join point for the object.
(<a href="README-1.1.html#DEFAULT_CONSTRUCTOR_CONFLICT">more info</a>)</p>
</div>
<div class="paragraph">
<p>The pointcut designators <code>within()</code> and <code>withincode()</code> will not pick out
code within the lexical extent of method-local and anonymous inner types
(because these are not represented as such in bytecode form). Because
<code>within</code> forms specify staticly-determinable pointcuts, they might be
used in declare error or declare warning statements, which might produce
different results. (<a href="README-1.1.html#WITHIN_MEMBER_TYPES">more info</a>)</p>
</div>
<div class="paragraph">
<p>The compiler will report an error that the form
<code>aspect {name} dominates {list}&#8230;&#8203;</code> is no longer supported. It has been
replaced by a new declare statement:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">declare precedence : {name} {list}...</code></pre>
</div>
</div>
<div class="paragraph">
<p>(<a href="README-1.1.html#ASPECT_PRECEDENCE">more info</a>)</p>
</div>
<div class="paragraph">
<p>The field set join point now has a return type of <code>void</code>. Compiling
programs using around advice on these join points might cause errors
unless the return type of the around advice and the result of any
proceed() call is <code>Object</code> or <code>void</code>.
(<a href="README-1.1.html#VOID_FIELD_SET">more info</a>)</p>
</div>
<div class="paragraph">
<p>The compiler cannot implement after or around advice for the handler PCD
because the end of exception handlers is ambiguous in bytecode. Try to
use before advice. (<a href="README-1.1.html#AFTER_HANDLER">more info</a>)</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="pre-1_0_4">Porting pre-1.0.4 code</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In versions of AspectJ prior to 1.0.4, the compiler was not correctly
implementing the AspectJ-1.0 language design for some uses of after
returning advice.</p>
</div>
<div class="paragraph">
<p>The main change that was made was of after returning advice for
constructor execution join points. Previously, this advice was legal:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">after() returning (Foo f): execution(Foo.new(..)) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, it has always been a part of the 1.0 language design (and of
Java&#8217;s language design) that constructors themselves (as opposed to
constructor calls) do not return the value of the new object. Rather,
<code>this</code> is bound to the new object, and the constructor behaves like a
void method. With that in mind, any code like the above should be
conveted to the form.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">after(Foo f) returning: <span class="local-variable">this</span>(f) &amp;&amp; execution(Foo.new(..)) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>In compilers prior to 1.0.4, the following advice could pick out join
points</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">after() returning (<span class="predefined-type">String</span> s): call(<span class="type">void</span> foo()) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is no longer picked out. This pattern was most commonly used in
highly polymorphic contexts, such as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">after() returning (<span class="predefined-type">String</span> s): call(* foo()) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you want to capture all calls, binding null objects for those that
would otherwise have no value, you must use the <code>Object</code> type.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">after() returning (<span class="predefined-type">Object</span> o): call(* foo()) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Uses of both of these forms are highleted with compiler warnings in the
1.0.4 compiler.</p>
</div>
<hr>
</div>
</div>
<div class="sect1">
<h2 id="pre-1_0rc1">Porting pre-1.0rc1 code</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Aspects can no longer be declared to implement the <code>Serializable</code> or
<code>Cloneable</code> interfaces. If you previously used serializable or cloneable
aspects, you should refactor your code to keep the state you need to
serialize or clone in objects associated with the aspects.</p>
</div>
<hr>
</div>
</div>
<div class="sect1">
<h2 id="pre-1_0beta1">Porting pre-1.0beta1 code</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>static</code> modifier is no longer allowed on pointcut declarations
anywhere. Porting is simple; just remove the static declarations when
you find them.</p>
</div>
<div class="paragraph">
<p>Also, though the <code>returns</code> modifier on pointcuts has not been part of
the language since 1.0alpha1, the compiler still accepted them until
now. If you used this feature, now is the right time to remove the
<code>returns</code> modifier when the compiler complains about it.</p>
</div>
<hr>
</div>
</div>
<div class="sect1">
<h2 id="pre-1_0alpha1">Porting pre-1.0alpha1 code</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The release of AspectJ 1.0alpha1 involved sweeping cleanups of the
language to bring it to 1.0 status.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#_1_0a1-pointcuts">Pointcuts</a></p>
</li>
<li>
<p><a href="#_1_0a1-type-patterns">Type patterns</a></p>
</li>
<li>
<p><a href="#_1_0a1-advice">Advice</a></p>
</li>
<li>
<p><a href="#_1_0a1-introduction-and-static">Introduction and static
crosscutting</a></p>
</li>
<li>
<p><a href="#_1_0a1-aspects">Aspects</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_1_0a1-pointcuts">Pointcuts</h3>
<div class="sect3">
<h4 id="_1_0a1-plural-to-singular">Removing the "s" from pointcuts</h4>
<div class="paragraph">
<p>One of the most pervasive changes in porting code written before
1.0alpha1 is the change in some of the pointcut names from plural to
singular, that is, they lose an "s". In one sense, making this change in
your programs is easy: Just go through and whever you see uses of the
pointcuts <code>calls, executions, gets, sets, handlers, initializations,
staticinitializations</code>.</p>
</div>
<div class="paragraph">
<p>Just take off the final "s", to make one of <code>call, execution, get, set, handler, initialization, staticinitialization</code>.</p>
</div>
<div class="paragraph">
<p>Often, there will be other changes you should make for each of these
pointcuts, but as for the name, just take off the "s".</p>
</div>
<div class="paragraph">
<p>One risk you will have when doing this is creating name conflicts. If,
for example, you named a parameter of a pointcut "set", you should (for
your own sanity&#8201;&#8212;&#8201;the compiler doesn&#8217;t require it) rename it in the
rewritten pointcut.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">pointcut sort(<span class="predefined-type">Collection</span> set): calls(<span class="type">void</span> addAll(set));
<span class="comment">// ==&gt;</span>
pointcut sort(<span class="predefined-type">Collection</span> mySet): call(<span class="type">void</span> addAll(mySet));</code></pre>
</div>
</div>
<div class="paragraph">
<p>While converting to use singular nouns for the primitive pointcuts, you
may also want to remove the "s" from your user-defined pointcuts.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">pointcut publicCalls(): calls(<span class="directive">public</span> * *(..));
<span class="comment">// ==&gt;</span>
pointcut publicCall(): call(<span class="directive">public</span> * *(..));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Of course, your naming conventions are your own, but throughout these
porting notes we will be making these changes in our example ports.</p>
</div>
</div>
<div class="sect3">
<h4 id="_1_0a1-remove-receptions">Removing the receptions pointcut</h4>
<div class="paragraph">
<p>Perhaps the largest semantic change in the 1.0 language is the removal
of receptions join points. They have been merged with call join points
in AspectJ 1.0, so now a call join point doesn&#8217;t represent the
"caller-side" of a call, but the call itself, both caller and receiver.</p>
</div>
<div class="paragraph">
<p>Changing code that used the <code>receptions</code> pointcut should be fairly
straightforward, depending on whether the pointcut exposed state or not.</p>
</div>
<div class="sect4">
<h5 id="_not_exposing_state">Not exposing state</h5>
<div class="paragraph">
<p>Receptions pointcuts that did not expose state can simply be replaced by
the new <code>call</code> and <code>target</code> pointcuts:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">receptions(<span class="type">void</span> Foo.m())
<span class="comment">// ==&gt;</span>
target(Foo) &amp;&amp; call(<span class="type">void</span> m())</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_exposing_state">Exposing state</h5>
<div class="paragraph">
<p>Some receptions pointcuts exposed the receiving object by replacing the
receiving type with a pointcut formal. These PCDs should be rewritten to
use the new <code>target</code> pointcut to expose the receiving object.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">pointcut fooCallees(Foo f): receptions(<span class="type">void</span> f.m());
<span class="comment">// ==&gt;</span>
pointcut fooCallee(Foo f): target(f) &amp;&amp; call(<span class="type">void</span> m());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Like <a href="#_1_0a1-fixing-state-access">other pointcuts</a>, receptions
pointcuts that exposed one or more arguments should be rewritten to use
the <code>args</code> pointcut:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">pointcut intPassers(<span class="type">int</span> i, <span class="type">int</span> j): receptions(<span class="type">void</span> Foo.m(i, j));
<span class="comment">// ==&gt;</span>
pointcut intPasser(<span class="type">int</span> i, <span class="type">int</span> j):
    args(i, j) &amp;&amp; target(Foo) &amp;&amp; call(<span class="type">void</span> m(<span class="type">int</span>, <span class="type">int</span>));</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_constructor_receptions">Constructor receptions</h5>
<div class="paragraph">
<p>There are two issues with constructor receptions in particular.</p>
</div>
<div class="paragraph">
<p>Like <a href="#_1_0a1-constructor-calls">constructor calls</a>, constructor
receptions pointcuts had a dynamic character, in that
<code>receptions(C.new())</code> would capture constructions of not only C classes,
but also of classes that extended C.</p>
</div>
<div class="paragraph">
<p>If you want this behaviour, then you need to use the new subtypes
operator, +, on the type name in question. So,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">receptions(C.new())
<span class="comment">// ==&gt;</span>
call(C+.new())</code></pre>
</div>
</div>
<div class="paragraph">
<p>Also like <a href="#_1_0a1-constructor-calls">constructor calls</a>, constructor
receptions allowed access to the constructed object in the same way as
any other object. Since the only advice possible on constructor
receptions join points was <code>after returning</code> advice, the object was
always guaranteed to be there. But since constructor call join points
allow all kinds of advice it may be that the object isn&#8217;t constructed
yet (say, in before or around advice). This is a benefit, in that it
allows caching constructed objects</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect Singleton {
  <span class="directive">private</span> C theC = <span class="predefined-constant">null</span>;

  C around(): call(C.new(..)) {
    <span class="keyword">if</span> (c == <span class="predefined-constant">null</span>) theC = proceed();
    <span class="keyword">return</span> theC;
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>but it does require some rewriting. The new object can be accessed as
the return value in after returning advice. So,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">after(<span class="predefined-type">Point</span> p) returning (): receptions(p.new(<span class="type">int</span>, <span class="type">int</span>)) { ... }
<span class="comment">// ==&gt;</span>
after() returning (<span class="predefined-type">Point</span> p): call(<span class="predefined-type">Point</span>+.new(<span class="type">int</span>, <span class="type">int</span>)) { ... }</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_1_0a1-fixing-state-access">Fixing state access</h4>
<div class="paragraph">
<p>In previous versions of AspectJ, state such as the currently executing
object or a particular argument of a method call could be accessed from
the signatures of many pointcuts, leading to difficult-to-read forms. In
AspectJ 1.0, all state accesses now use only three pointcuts <code>args, this, target</code>
which pick out argument values, the currently executing object, and the
target object of a method call or field operation, respectively.</p>
</div>
<div class="sect4">
<h5 id="_using_args">Using args</h5>
<div class="paragraph">
<p>Any time you have a pointcut that has a signature where one of the
arguments was a pointcut or advice formal, just replace that formal with
its type and add an <code>args</code> pointcut.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">pointcut intPassers(<span class="type">int</span> i, <span class="type">int</span> j): calls(<span class="type">void</span> Foo.m(i, j));
<span class="comment">// ==&gt;</span>
pointcut intPasser(<span class="type">int</span> i, <span class="type">int</span> j): args(i, j) &amp;&amp; call(<span class="type">void</span> Foo.m(<span class="type">int</span>, <span class="type">int</span>));</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">pointcut stringPassers(<span class="predefined-type">String</span> s): receptions(<span class="type">void</span> Foo.m(s, ..));
<span class="comment">// ==&gt;</span>
pointcut stringPasser(<span class="predefined-type">String</span> s): args(s, ..) &amp;&amp; call(<span class="type">void</span> Foo.m(<span class="predefined-type">String</span>, ..));</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_rewriting_calls">Rewriting calls</h5>
<div class="paragraph">
<p>If a calls pointcut exposed the the receiving object, such as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">pointcut fooCallees(Foo f): calls(<span class="type">void</span> f.m());</code></pre>
</div>
</div>
<div class="paragraph">
<p>then the new version should use the <code>target</code> pointcut to get at that
object</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">pointcut fooCallee(Foo f): target(f) &amp;&amp; call(<span class="type">void</span> Foo.m());</code></pre>
</div>
</div>
<div class="paragraph">
<p>AspectJ&#8217;s calls pointcut previously allowed the new object to be
exposed, even though it may not have been constructed yet. AspectJ 1.0
no longer allows this; you can access the new instance only in after
returning advice, when it is guaranteed that the object was successfully
constructed. So instead of using the <code>target</code> pointcut to expose the
value, you should use the normal <code>after returning</code> mechanism:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">after(<span class="predefined-type">Point</span> p) returning (): calls(p.new(<span class="type">int</span>, <span class="type">int</span>)) { ... }
<span class="comment">// ==&gt;</span>
after() returning (<span class="predefined-type">Point</span> p): call(<span class="predefined-type">Point</span>+.new(<span class="type">int</span>, <span class="type">int</span>)) { ... }</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_rewriting_gets_and_sets">Rewriting gets and sets</h5>
<div class="paragraph">
<p>Exposing the target object of a <code>gets</code> or <code>sets</code> pointcut should be done
the same way it was for <code>calls</code> pointcuts, with the new <code>target</code>
pointcut.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">before(<span class="predefined-type">Frame</span> f): gets(<span class="predefined-type">Color</span> f.color) { ... }
<span class="comment">// ==&gt;</span>
before(<span class="predefined-type">Frame</span> f): target(f) &amp;&amp; get(<span class="predefined-type">Color</span> <span class="predefined-type">Frame</span>.color) { ... }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">before(<span class="predefined-type">Frame</span> f): sets(<span class="predefined-type">Color</span> f.color) { ... }
<span class="comment">// ==&gt;</span>
before(<span class="predefined-type">Frame</span> f): target(f) &amp;&amp; set(<span class="predefined-type">Color</span> <span class="predefined-type">Frame</span>.color) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>In addition, the clumsy syntax for getting the old value of the field
has been eliminated. For before advice, the port is simple; just access
the field yourself in the body. Depending on the rest of your system,
you may need to restrict the advice from the aspect body to eliminiate
the circularity.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect A {
  before(<span class="predefined-type">Frame</span> f, <span class="predefined-type">Color</span> c): gets(<span class="predefined-type">Color</span> f.color)[c] { ... }
}

<span class="comment">// ==&gt;</span>

aspect A {
  before(<span class="predefined-type">Frame</span> f):
    target(f) &amp;&amp; get(<span class="predefined-type">Color</span> <span class="predefined-type">Frame</span>.color) &amp;&amp; !within(A)
  {
    <span class="predefined-type">Color</span> c = f.color;
    <span class="comment">// ...</span>
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The same can be done for <code>around</code> advice. However, the only way to port
after advice that needs the old value is to convert it to around advice.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect A {
  after(<span class="predefined-type">Frame</span> f, <span class="predefined-type">Color</span> c) returning (): gets(<span class="predefined-type">Color</span> f.color)[c] { ... }
}

<span class="comment">// ==&gt;</span>

aspect A {
  <span class="type">void</span> around(<span class="predefined-type">Frame</span> f):
    target(f) &amp;&amp; get(<span class="predefined-type">Color</span> <span class="predefined-type">Frame</span>.color) &amp;&amp; !within(A)
  {
    <span class="predefined-type">Color</span> c = f.color;
    proceed(f);
    <span class="comment">// ...</span>
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When porting <code>sets</code> pointcuts, the new value of a field is still
available, but not the way it was previously. Instead of using the
square bracket syntax, we use an <code>args</code> pointcut. All set join points
are assumed to have exactly one argument, which holds the new value. So,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">after(<span class="predefined-type">Color</span> newColor): sets(<span class="predefined-type">Color</span> <span class="predefined-type">Frame</span>.color)<span class="type">[]</span>[newColor] { ... }
<span class="comment">// ==&gt;</span>
after(<span class="predefined-type">Color</span> newColor): args(newColor) &amp;&amp; set(<span class="predefined-type">Color</span> <span class="predefined-type">Frame</span>.color) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Also, if the field was declared private, in order to get at its old
value the aspect must be declared <code>privileged</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_rewriting_handlers">Rewriting handlers</h5>
<div class="paragraph">
<p>The value of the exception at an exception handler join point is now
accessed through the <code>args</code> pointcut; all exception handler join points
are treated as having exactly one argument, the exception value. So,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">before(NotFoundException e): handlers(e) { ... }
<span class="comment">// ==&gt;</span>
before(NotFoundException e): args(e) &amp;&amp; handler(NotFoundException) { ... }</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_rewriting_within">Rewriting within</h5>
<div class="paragraph">
<p>The <code>within</code> pointcut was not typically used to export context. Though
it was accidentally possible to do so in versions of AspectJ before 1.0,
it often didn&#8217;t do what users expected it to. This loophole has now been
closed, and within can only take type patterns, not pointcut or advice
formals. A use of the <code>this</code> pointcut will capture what previous
implementations did:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">pointcut usesFoo(Foo f): within(f);
<span class="comment">// ==&gt;</span>
pointcut usesFoo(Foo f): <span class="local-variable">this</span>(f) &amp;&amp; within(Foo);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_1_0a1-no-subs-in-sigs">Understanding signatures</h4>
<div class="paragraph">
<p>Now that we have <code>this</code>, <code>target</code>, and <code>args</code> pointcuts, all of our
signatures are composed of just types, names, and wildcards; there are
no more parameters.</p>
</div>
<div class="paragraph">
<p>Also, now that we have the <code>+</code> wildcard to pick out
<a href="#_1_0a1-subtypes-to-plus">subtypes</a>, we can make signature matching
much more uniform.</p>
</div>
<div class="paragraph">
<p>Previously, some signatures matched based on subtypes, some based on
instanceof, and some exactly. Now, we have made all signatures match
exactly.</p>
</div>
<div class="paragraph">
<p>What does this mean for your program? Well, it means that you may have
to add <code>+</code> to some of your signatures, depending on what you meant them
to match.</p>
</div>
<div class="paragraph">
<p>For example, the pointcut</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">calls(<span class="type">void</span> m(<span class="predefined-type">Object</span>))</code></pre>
</div>
</div>
<div class="paragraph">
<p>previously picked out all method calls to a method named m that took one
argument, which was a subtype of Object. Now, however, it will only pick
out method calls to methods that are defined to take exactly the type
Object, which may be a lot fewer join points. If you want the old
behaviour, simply convert to</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">call(<span class="type">void</span> m(<span class="predefined-type">Object</span>+))</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_1_0a1-fixing-instanceof">Removing the instanceof pointcut</h4>
<div class="paragraph">
<p>The intanceof pointcut has been split into two different pointcuts,
<code>this</code> and <code>target</code>.</p>
</div>
<div class="paragraph">
<p>Typically, the instanceof pointcut would only exist in a compound
pointcut, composed (with <code>&amp;&amp;</code>) with another pointcut. If the other
pointcut was a <code>receptions</code> pointcut, then <code>instanceof</code> should be
converted to <code>target</code> (and <code>receptions</code> converted to <code>call</code>). So,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">pointcut stateChanges(<span class="predefined-type">Subject</span> s):
  <span class="keyword">instanceof</span>(s) &amp;&amp; receptions(<span class="type">void</span> <span class="predefined-type">Button</span>.click());

<span class="comment">// ==&gt;</span>

pointcut stateChange(<span class="predefined-type">Subject</span> s):
  target(s) &amp;&amp; call(<span class="type">void</span> <span class="predefined-type">Button</span>.click());</code></pre>
</div>
</div>
<div class="paragraph">
<p>In all other cases, <code>instanceof</code> referred to the currently executing
object, and so should be converted into <code>this</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">before(<span class="predefined-type">Point</span> p): <span class="keyword">instanceof</span>(p) &amp;&amp; executions(* makePolar(..)) { ... }
<span class="comment">// ==&gt;</span>
before(<span class="predefined-type">Point</span> p): <span class="local-variable">this</span>(p) &amp;&amp; execution(* makePolar(..)) { ... }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">pointcut setup(Client c): <span class="keyword">instanceof</span>(c) &amp;&amp; calls(<span class="predefined-type">Remote</span> <span class="predefined-type">Naming</span>.lookup(<span class="predefined-type">String</span>));
<span class="comment">// ==&gt;</span>
pointcut setup(Client c): <span class="local-variable">this</span>(c) &amp;&amp; calls(<span class="predefined-type">Remote</span> <span class="predefined-type">Naming</span>.lookup(<span class="predefined-type">String</span>));</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_1_0a1-initializations">Rewriting the initializations pointcut</h4>
<div class="paragraph">
<p>Object initialization join points are now more complicated, and more
true to Java&#8217;s execution model. Now they bracket all of the
initialization that a class can do, after the return of its super
constructor call (before which no initialization can happen). Previous
versions of AspectJ had object initialization join points that only
included initialization that was made in dynamic initializers and
fields.</p>
</div>
<div class="paragraph">
<p>The old behaviour can be recovered with a simple rewrite.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">initializations(A)
<span class="comment">// ==&gt;</span>
initialization(A.new(..)) &amp;&amp; !execution(A.new(..))</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_1_0a1-constructor-calls">Understanding constructor calls</h4>
<div class="paragraph">
<p>Previously, constructor call join points were matched by subtypes, so
<code>calls(Foo.new())</code> would match both calls to create new <code>Foo</code> objects,
and new <code>SubFoo</code> objects. The new <code>call</code> pointcut designator matches
types exactly, so if you want the old behaviour, you should write
<code>call(Foo+.new())</code>.</p>
</div>
<div class="paragraph">
<p>Similarly, constructor execution join points were matched by subtypes.
So the old <code>executions(Foo.new())</code> is now represented by
<code>execution(Foo+.new())</code>.</p>
</div>
<div class="paragraph">
<p>In both of these cases, think before using the + operator; it may be
that you didn&#8217;t intend subtype matching in the first place.</p>
</div>
</div>
<div class="sect3">
<h4 id="_1_0a1-hasaspect">Removing the hasaspect pointcut</h4>
<div class="paragraph">
<p>The <code>hasaspect</code> pointcut is no longer defined, but you can get the same
behaviour using the new <code>if</code> pointcut.</p>
</div>
<div class="paragraph">
<p>If the aspect whose presense you are checking for was defined
<code>of eachcflow</code>, <code>of eachcflowbelow</code>, or, more unlikely, <code>of eachJVM()</code>,
then the conversion is simple:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">hasaspect(A)
<span class="comment">// ==&gt;</span>
<span class="keyword">if</span>(A.hasAspect())</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the aspect was defined <code>of eachobject</code>, then you will have to expose
the current object in your pointcut or advice parameters:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">pointcut cut(): hasaspect(A) ... ;
<span class="comment">// ==&gt;</span>
pointcut cut(<span class="predefined-type">Object</span> o): <span class="local-variable">this</span>(o) &amp;&amp; <span class="keyword">if</span>(A.hasAspect(o)) ... ;
<span class="comment">// or</span>
pointcut cut(<span class="predefined-type">Object</span> o): target(o) &amp;&amp; <span class="keyword">if</span>(A.hasAspect(o)) ... ;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you were using the <code>hasaspect</code> pointcut to expose the state of the
aspect, then you can get the same state by using <code>A.aspectOf()</code> in the
body of the advice. For example, if the aspect A were defined
<code>of eachcflow</code>, then</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">before(A myA): hasaspect(myA) {
  myA.checkStatus();
}
<span class="comment">// ==&gt;</span>
before(): <span class="keyword">if</span>(A.hasAspect()) {
  A myA = A.aspectOf();
  myA.checkStatus();
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_1_0a1-withinall">Removing the withinall pointcut</h4>
<div class="paragraph">
<p>The withinall poinctut is no longer defined. You can use a combination
of within and the <a href="#_1_0a1-subtypes-to-plus">new subtypes operator</a>,
<code>+</code>, instead. You&#8217;ll save two characters and be using a simpler and more
orthogonal language.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">withinall(Foo)
<span class="comment">// ==&gt;</span>
within(Foo+)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_1_0a1-user-defined-returns">Removing returns modifier from pointcuts</h4>
<div class="paragraph">
<p>The returns keyword is no longer necessary for user-defined pointcuts.
Simply remove it when you find it.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">pointcut publicIntCalls() returns <span class="type">int</span>: calls(<span class="directive">public</span> <span class="type">int</span> *(..));
<span class="comment">// ==&gt;</span>
pointcut publicIntCall(): call(<span class="directive">public</span> <span class="type">int</span> *(..));</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_1_0a1-static-pointcuts">Making some pointcuts static</h4>
<div class="paragraph">
<p>In Java, only static members may be accessed by their declaring type
name, like the static method <code>Math.max()</code> can be accessed.</p>
</div>
<div class="paragraph">
<p>Pointcuts now have that property too. Pointcuts may be declared to be
static, in which case they can be accessed like <code>MyAspect.move()</code>, or
they can be left non-static, in which case they can be overridden by a
subaspect.</p>
</div>
<div class="paragraph">
<p>In addition, while pointcuts can still be defined in classes, only
<code>static</code> pointcuts can be defined in classes.</p>
</div>
<div class="paragraph">
<p>Porting should be straightforward; just make all your pointcuts in
classes <code>static</code>, and make any pointcut with a qualified reference
static.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_1_0a1-type-patterns">Type patterns</h3>
<div class="sect3">
<h4 id="_1_0a1-new-wildcards">Understanding * and .. in type patterns</h4>
<div class="paragraph">
<p>Previous versions of AspectJ treated * and .. too cleverly in type
patterns, placing restrictions based on what is a package and what is a
type, and basing their meanings on the definition of a package
hierarchy.</p>
</div>
<div class="paragraph">
<p>In AspectJ 1.0, both of these wildcards are defined simply, and
textually:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The * wildcard alone matches all types.</p>
</li>
<li>
<p>The * wildcard in a pattern matches zero or more characters, but will
not match "."</p>
</li>
<li>
<p>The .. wildcard matches any sequence of characters that begins and
ends with "."</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>That&#8217;s it.</p>
</div>
<div class="paragraph">
<p>This change won&#8217;t affect most programs, but it will make understanding
programs easier. There is one ugly idiom, however, that this change
disposes of. If your program includes the type pattern <code><strong>..</strong></code>, which
used to match all types, you can replace it with the much simpler *.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">pointcut unaryVoidMethods(): call(<span class="type">void</span> *(*..*));
<span class="comment">// ==&gt;</span>
pointcut unaryVoidMethod(): call(<span class="type">void</span> *(*));</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_1_0a1-subtypes-to-plus">Fixing subtypes in introduction</h4>
<div class="paragraph">
<p>The new + operator is used to normalize the many places you want to use
subtypes of some types.</p>
</div>
<div class="paragraph">
<p>In introduction forms, you will need to replace <code>subtypes(TypePattern)</code>
type patterns with the new subtype operator, . In the case where you
wrote `subtypes(Foo)`, i.e., the subtypes of a single type, simply
replace this with `Foo<code>. Otherwise, use the + operator as appropriate
in `TypePattern</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">void</span> (subtypes(Target0 || Target1)).accept(Visitor v) {
  v.visit(<span class="local-variable">this</span>);
}
<span class="comment">// ==&gt;</span>
<span class="directive">public</span> <span class="type">void</span> (Target0+ || Target1+).accept(Visitor v) {
  v.visit(<span class="local-variable">this</span>);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_1_0a1-advice">Advice</h3>
<div class="sect3">
<h4 id="_1_0a1-around-returns">Moving the return type of around</h4>
<div class="paragraph">
<p>The returns keyword is no longer used for around advice. Instead, the
return type is declared as it is for methods. So,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">around(<span class="predefined-type">Point</span> p) returns <span class="type">void</span>: setters(p) { ... }
<span class="comment">// ==&gt;</span>
<span class="type">void</span> around(<span class="predefined-type">Point</span> p): setter(p) { ... }</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_1_0a1-around-throws">Adding a throws clause to around</h4>
<div class="paragraph">
<p>Around advice must now declare the checked exceptions it throws with a
<code>throws</code> clause, much like a method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">char</span> around(<span class="type">char</span> c) <span class="directive">throws</span> java.io.CharConversionException: converter(c) {
  <span class="type">char</span> result;
  <span class="keyword">try</span> { result = proceed(); }
  <span class="keyword">catch</span> (<span class="exception">Exception</span> e) {
    <span class="keyword">throw</span> <span class="keyword">new</span> java.io.CharConversionException();
  }
  <span class="keyword">if</span> (result == <span class="integer">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> java.io.CharConversionException();
  <span class="keyword">return</span> result;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_1_0a1-advice-precedence">Understanding advice precedence</h4>
<div class="paragraph">
<p>In previous versions of AspectJ, advice precedence within an aspect was
simple: if a piece of advice appeared before another piece, it was more
precedent. This made perfect sense for <code>before</code> and <code>around</code> advice, but
was the cause of confusion (even among the AspectJ designers, more than
once) for <code>after</code> advice, as it seemed backward.</p>
</div>
<div class="paragraph">
<p>In addition, advice was ordered by kind, in that around advice always
surrounded before and after advice.</p>
</div>
<div class="paragraph">
<p>AspectJ 1.0 has changed this; precedence for <code>after</code> advice is inverted,
and advice is no longer ordered by kind.</p>
</div>
<div class="paragraph">
<p>This won&#8217;t matter to you unless you write pieces of advice in the same
aspect that apply to the same join point.</p>
</div>
<div class="paragraph">
<p>If you do, here&#8217;s what to think about: If you&#8217;re looking at two pieces
of advice and want to know which has precedence, if either is <code>after</code>
advice, then the second one has precedence. Otherwise, the first does.</p>
</div>
<div class="paragraph">
<p>This allows interesting advice interaction. In the following advice, for
example, the <code>after throwing</code> advice will catch the exception thrown by
the <code>before</code> advice</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect A {
  before(): call(<span class="type">void</span> main(..)) {
    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">RuntimeException</span>();
  }
  after() throwing(<span class="exception">RuntimeException</span> e): call(<span class="type">void</span> main(..)) {
    <span class="predefined-type">System</span>.err.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">caught you!</span><span class="delimiter">&quot;</span></span>);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>But reversing the order will give the <code>before</code> advice more precedence,
making its exception uncatchable by the <code>after throwing</code> advice</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect A {
  after() throwing(<span class="exception">RuntimeException</span> e): call(<span class="type">void</span> main(..)) {
    <span class="predefined-type">System</span>.err.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">missed you!</span><span class="delimiter">&quot;</span></span>);
  }
  before(): call(<span class="type">void</span> main(..)) {
    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">RuntimeException</span>();
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Advice in <em>different</em> aspects is ordered by the normal aspect precedence
rules of subtyping and the <code>dominates</code> modifier.</p>
</div>
</div>
<div class="sect3">
<h4 id="_1_0a1-after-returning">Fixing after returning</h4>
<div class="paragraph">
<p>If you use after returning advice and do not need to expose the return
value, you no longer need to write an empty set of parentheses to
indicate that fact. So,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">after(Formals) returning (): Pointcut { ... }
<span class="comment">// ==&gt;</span>
after(Formals) returning: Pointcut { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The same syntax is now available for after throwing advice, in case you
do not care what <code>Throwable</code> is thrown.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">after(Formals) throwing: Pointcut { ... }</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_1_0a1-this-static-join-point">Renaming thisStaticJoinPoint</h4>
<div class="paragraph">
<p><code>thisStaticJoinPoint</code> has been renamed <code>thisJoinPointStaticPart</code>, to
reflect that it is now exactly the static part of <code>thisJoinPoint</code>: It
will return the same object as <code>thisJoinPoint.getStaticPart()</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_1_0a1-this-join-point">Converting access to thisJoinPoint</h4>
<div class="paragraph">
<p>The <code>JoinPoint</code> object hierarchy has been folded into a single class,
<code>org.aspectj.lang.JoinPoint</code>. A common pattern in logging, for example,
was</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">before() executions(* myMethod()) {
  ExecutionJoinPoint jp = (ExecutionJoinPoint)thisJoinPoint;
  CodeSignature jp = (CodeSignature)jp.getSignature();
  <span class="predefined-type">System</span>.err.println(jp.getParameters());
  <span class="predefined-type">System</span>.err.println(jp.getParameterNames());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>While there is still a rich hierarchy for signatures, there is only one
<code>JoinPoint</code> type, so this can be rewritten as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">before() executions(* myMethod()) {
  JoinPoint jp = thisJoinPoint;
  CodeSignature jp = (CodeSignature)jp.getSignature();
  <span class="predefined-type">System</span>.err.println(jp.getArgs());
  <span class="predefined-type">System</span>.err.println(jp.getParameterNames());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Some of the method names of <code>JoinPoint</code> have been reorganized, as well.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_1_0a1-introduction-and-static">Introduction and static crosscutting</h3>
<div class="sect3">
<h4 id="_1_0a1-plus-implements-extends">Removing +implements and +extends</h4>
<div class="paragraph">
<p>The keywords <code>+implements</code> and <code>+extends</code> no longer exist. Instead,
AspectJ uses the <code>declare</code> form for exactly the same functionality.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">Point</span> +<span class="directive">implements</span> <span class="predefined-type">Serializable</span>;
<span class="comment">// ==&gt;</span>
declare parents: <span class="predefined-type">Point</span> <span class="directive">implements</span> <span class="predefined-type">Serializable</span>;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">MyButton +<span class="directive">extends</span> ButtonAdaptor;
<span class="comment">// ==&gt;</span>
declare parents: MyButton <span class="directive">extends</span> ButtonAdaptor;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_1_0a1-now-use-soft">Using declare soft</h4>
<div class="paragraph">
<p>Around advice advice no longer effects the static exception checking of
Java. This means that the following code previously compiled:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">C</span> {
  <span class="type">void</span> noExceptionDeclared() {
    exceptionDeclared();
  }
  <span class="type">void</span> exceptionDeclared() <span class="directive">throws</span> <span class="exception">IOException</span> {}
}

aspect A {
  around(): call(<span class="type">void</span> C.exceptionDeclared()) {
    <span class="keyword">try</span> { proceed(); }
    <span class="keyword">catch</span> (<span class="exception">IOException</span> e) {}
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>even though the class <code>C</code> is not compilable on its own (because
<code>noExceptionDeclared</code> actually throws an <code>Exception</code>).</p>
</div>
<div class="paragraph">
<p>AspectJ now firmly places everything that affects the type system of
Java, including the declared-exception checking system, into the space
of introduction and declare. So, in order to state that the call to
<code>exceptionDeclared()</code> will not, actually, throw an exception, we now
"soften" that exception, that is, take it out of the space of declared
exceptions.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">declare soft: ExceptionType: Pointcut;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The pointcuts allowed here are limited; you cannot use pointcuts that
would require runtime information. But picking out method calls is just
fine. So in order to make the above example work, one new declaration is
needed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">declare soft: <span class="exception">IOException</span>:
  call(<span class="type">void</span> C.exceptionDeclared()) &amp;&amp;
  withincode(<span class="type">void</span> noExceptionDeclared());</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_1_0a1-aspects">Aspects</h3>
<div class="paragraph">
<p>The syntax of "of each" modifiers has changed. For <code>of eachcflow</code> and
<code>of eachcflowbelow</code>, you can simply replace "of each" with "per". So,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect A of eachcflow(...) { ... }
<span class="comment">// ==&gt;</span>
aspect A percflow(...) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you have any aspects defined <code>of eachJVM()</code>, then you should either
remove that declaration entirely (because this is the default
behaviour), or replace the <code>of eachJVM()</code> declaration with an
<code>issingleton</code> declaration.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect of eachJVM() { ... }
<span class="comment">// ==&gt;</span>
aspect A { ... }
<span class="comment">// or</span>
aspect A issingleton { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>of eachobject(Pointcut)</code> modifier has been split into two different
forms, <code>of perthis(Pointcut)</code> and <code>of pertarget(Pointcut)</code>. Which one
you replace with depends on the <code>Pointcut</code> you use.</p>
</div>
<div class="paragraph">
<p>If you use a pointcut that picked out reception join points, then use
<code>pertarget</code>, and rewrite the pointcut to pick out call join points. So</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect Shadow
  of eachobject(
    receptions(<span class="type">void</span> <span class="predefined-type">Point</span>.setX(<span class="type">int</span>)) ||
    receptions(<span class="type">void</span> <span class="predefined-type">Point</span>.setY(<span class="type">int</span>))
  )
{
  <span class="comment">// ...</span>
}

<span class="comment">// ==&gt;</span>

aspect Shadow
  pertarget(
    call(<span class="type">void</span> <span class="predefined-type">Point</span>.setX(<span class="type">int</span>)) ||
    call(<span class="type">void</span> <span class="predefined-type">Point</span>.setY(<span class="type">int</span>))
  )
{
  <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Otherwise, in most cases, use <code>perthis</code>. When you convert, remember the
meaning of each of these modifiers. <code>perthis(Pointcut)</code> indicates that
an instance of the aspect should be associated with every object that is
<code>this</code> at each of the join points picked out by <code>Pointcut</code>, while
<code>pertarget(Pointcut)</code> associates with every object that is the target
object at such join points.</p>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="pre08b3">Porting pre-0.8beta3 code</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="#cflowTerminology">Changing cflow terminology</a></p>
</li>
<li>
<p><a href="#abstractPointcuts">Overriding abstract pointcuts</a></p>
</li>
<li>
<p><a href="#recursiveAdvice">Limiting recursive advice</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following changes are only required when porting code written prior
to the 0.8beta3 release of AspectJ.</p>
</div>
<div class="sect2">
<h3 id="cflowTerminology">Changing cflow terminology</h3>
<div class="paragraph">
<p>Changing pre-0.8beta3 code that uses AspectJ&#8217;s control-flow-based
features only requires rewriting occurrences of <code>eachcflowroot</code>,
<code>cflow</code>, and <code>cflowtop</code>. No editing of other aspect code is necessary.</p>
</div>
<div class="sect3">
<h4 id="_eachcflowroot">eachcflowroot</h4>
<div class="paragraph">
<p>The aspect modifier &#8220;of eachcflowroot(Pointcut)&#8221; should now be written
more as &#8220;percflow(Pointcut)&#8221;.</p>
</div>
</div>
<div class="sect3">
<h4 id="_cflow">cflow</h4>
<div class="paragraph">
<p>In previous versions of AspectJ, the pointcut <code>cflow(Pointcut)</code> picked
out all join points in the cflow below the join points of <code>Pointcut</code>.
That is, it did not include the join points of <code>Pointcut</code>, only the join
points in their control flow.</p>
</div>
<div class="paragraph">
<p>As of version 0.8beta3, <code>cflowbelow(Pointcut)</code> has that behavior.
<code>cflow(Pointcut)</code> includes the join points of <code>Pointcut</code>.</p>
</div>
<div class="paragraph">
<p>In many cases, you may not care whether the points of <code>Pointcut</code> are
included or not, and so can safely leave <code>cflow(Pointcut)</code> pointcut
designators alone. However, if you use the idiom</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Pointcut &amp;&amp; ! cflow(Pointcut)</code></pre>
</div>
</div>
<div class="paragraph">
<p>to capture the non-recursive entries to a particular pointcut, you will
definitely want to rewrite that as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Pointcut &amp;&amp; ! cflowbelow(Pointcut)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_cflowtop">cflowtop</h4>
<div class="paragraph">
<p>The primitive pointcut designator <code>cflowtop(Pointcut)</code> has been removed
from the language, as it is expressible with <code>cflow</code> or <code>cflowbelow</code>.
All uses of <code>cflowtop(Pointcut)</code> can be rewritten as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">cflowbelow(Pointcut &amp;&amp; ! cflowbelow(Pointcut))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Though in most cases the following is sufficient</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">cflow(Pointcut &amp;&amp; ! cflowbelow(Pointcut))</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="abstractPointcuts">Overriding abstract pointcuts</h3>
<div class="paragraph">
<p>In previous versions of AspectJ, a concrete aspect would implicitly
override all of its abstract pointcuts with an empty pointcut. AspectJ
0.8beta3 enforces the restriction that a concrete aspect may not have
any abstract pointcuts. Thus the following extension:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">abstract</span> aspect A {
  <span class="directive">abstract</span> pointcut pc();
}

aspect B {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>will no longer compile.</p>
</div>
<div class="paragraph">
<p>Adding the new empty pointcut designator</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">pointcut Id();</code></pre>
</div>
</div>
<div class="paragraph">
<p>in the declaration of the concrete aspect fixes this problem.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">abstract</span> aspect A {
  <span class="directive">abstract</span> pointcut pc();
}

aspect B {
  pointcut pc();
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="recursiveAdvice">Limiting recursive advice</h3>
<div class="paragraph">
<p>Previously, the compiler silently refrained from applying a piece of
advice to join points within its own advice body. So, for example, in</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">C</span> {
  <span class="directive">static</span> <span class="type">int</span> i;
}

aspect A {
  before(): gets(<span class="type">int</span> C.i) {
    <span class="predefined-type">System</span>.err.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">C.i was </span><span class="delimiter">&quot;</span></span> + C.i)
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The advice would trace all references of the static field <code>C.i</code> except
those in the body of the before.</p>
</div>
<div class="paragraph">
<p>The compiler has now removed this special case, and so running the above
example will now cause a <code>StackOverflowException</code> to be thrown.</p>
</div>
<div class="paragraph">
<p>Most cases of this error can be fixed by correctly specifying the
desired pointcut: In the above example, the intention is clearly not to
trace <em>all</em> references of <code>C.i</code>, just those outside the aspect.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">C</span> {
  <span class="directive">static</span> <span class="type">int</span> i;
}

aspect A {
  before(): get(<span class="type">int</span> C.i) &amp;&amp; ! within(A) {
    <span class="predefined-type">System</span>.err.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">C.i was </span><span class="delimiter">&quot;</span></span> + C.i)
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In a very few cases, you may want the advice to be applicable to other
code in the aspect, but not in the particular piece of advice. In such
cases, you can pull the body of the advice into a method and restrict
away from that method (and away from calls to that method):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">C</span> {
  <span class="directive">static</span> <span class="type">int</span> i;
}

aspect A {
  <span class="directive">public</span> <span class="directive">static</span> <span class="type">int</span> getCi() {
    <span class="keyword">return</span> C.i;                          <span class="comment">// will be traced</span>
  }

  before(): get(<span class="type">int</span> C.i) &amp;&amp;
    ! withincode(<span class="type">void</span> A.traceCi()) &amp;&amp;
    ! call(<span class="type">void</span> A.traceCi())
  {
    traceCi();
  }

  <span class="directive">private</span> <span class="type">void</span> traceCi() {
    <span class="predefined-type">System</span>.err.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">C.i was </span><span class="delimiter">&quot;</span></span> + C.i) <span class="comment">// will not be traced</span>
  }
}</code></pre>
</div>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="pre08b1">Porting pre-0.8beta1 code</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="#introSyntax">Rewriting introductions</a></p>
</li>
<li>
<p><a href="#staticAdvice">Removing static advice</a></p>
</li>
<li>
<p><a href="#aspect-aspect">Fixing aspect-aspect inheritance</a></p>
</li>
<li>
<p><a href="#usingPrivateIntroduction">Using private introduction</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following changes are only required when porting code written prior
to the 0.8beta1 release of AspectJ.</p>
</div>
<div class="sect2">
<h3 id="introSyntax">Rewriting introductions</h3>
<div class="sect3">
<h4 id="_syntax">Syntax</h4>
<div class="paragraph">
<p>The syntax of introduction has changed. Porting most programs should
require some simple editing. Anywhere you have an introduction block</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">introduction GTN {
  <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>simply move the <code>GTN</code> down into the introduction declarations and remove
the block.</p>
</div>
<div class="paragraph">
<p>For method introduction, place the <code>GTN</code> in front of the method name,
For field introduction, place the <code>GTN</code> in front of the field name, and
for constructor introduction, place the <code>GTN</code> in front of the <code>new</code>
identifier.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">introduction Foo {
  <span class="directive">public</span> <span class="type">void</span> doStuff() { <span class="local-variable">this</span>.doStuffLater(); }
  <span class="directive">public</span> <span class="type">int</span> calorieCount = <span class="integer">3</span>;
  <span class="directive">public</span> <span class="keyword">new</span>(<span class="type">int</span> x) { <span class="local-variable">super</span>(); calorieCount = x; }
}

<span class="comment">// ==&gt;</span>

<span class="directive">public</span> <span class="type">void</span> Foo.doStuff() { <span class="local-variable">this</span>.doStuffLater(); }
<span class="directive">public</span> <span class="type">int</span> Foo.calorieCount= <span class="integer">3</span>;
<span class="directive">public</span> Foo.new(<span class="type">int</span> x) { <span class="local-variable">super</span>(); calorieCount = x; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>For implements and extends introduction, move the <code>GTN</code> in front of the
new identifiers <code>implements</code> or <code>extends</code>, and place that in a
<code>declare parents</code> form.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">introduction Foo {
  <span class="directive">implements</span> <span class="predefined-type">Comparable</span>;
  <span class="directive">extends</span> Goo;
}

<span class="comment">// ==&gt;</span>

declare parents: Foo <span class="directive">implements</span> <span class="predefined-type">Comparable</span>;
declare parents: Foo <span class="directive">extends</span> Goo;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In all cases, if the <code>GTN</code> is just a type name, it can be moved down on
its own. However, if the <code>GTN</code> uses any of <code>&amp;&amp;</code>, <code>||</code>, and <code>!</code>, it must
be parenthesized.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">introduction subtypes(Foo) &amp;&amp; !Goo {
  <span class="type">int</span> x;
}

<span class="comment">// ==&gt;</span>

<span class="type">int</span> (Foo+ &amp;&amp; !Goo).x;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_access">Access</h4>
<div class="paragraph">
<p>If you had an introduction that was referring to private or protected
members of the target class, this will no longer work. You will either
need to modify your code to avoid this accessibility issue, or you will
need to use the <code>privileged</code> modifier on the aspect that contains the
introduction.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">Counter</span> {
  <span class="directive">private</span> <span class="type">int</span> count = <span class="integer">2</span>;
}

aspect ExposeCountersPrivates {
  introduction Counter {
    <span class="directive">public</span> <span class="type">int</span> getCount() { <span class="keyword">return</span> count; }
  }
}

<span class="comment">// ==&gt;</span>

<span class="comment">// in 0.8, only privileged aspects can expose a class's privates</span>
privileged aspect ExposeCountersPrivates {
  <span class="directive">public</span> <span class="type">int</span> Counter.getCount() { <span class="keyword">return</span> count; }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you have introduced private or package-protected members, you will
probably have to re-write some code. Most previous uses of introducing
privates can be improved by using private introduction instead.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">C</span> {}

aspect AddCounter {
  introduction C {
    <span class="directive">private</span> <span class="type">int</span> count;
    <span class="directive">public</span> <span class="type">int</span> getCount() { <span class="keyword">return</span> count; }
  }
}

<span class="comment">// ==&gt;</span>

aspect AddCounter {
  <span class="directive">private</span> <span class="type">int</span> Counter.count;
  <span class="directive">public</span> <span class="type">int</span> Counter.getCount() { <span class="keyword">return</span> count; }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There is one case that we know of where the inability to perform the
introduction of private members makes 0.7 code difficult to port to 0.8.
If you were using the introduction of a <code>private void writeObject(..)</code>
or a <code>private void readObject(..)</code> method to interact with Java&#8217;s
serialization API, you will need to come up with an alternative design.
Using some combination of <code>Externalizable</code>, <code>writeReplace(..)</code> and/or
<code>readResolve(..)</code> methods should allow you to port your code. If you
find this isn&#8217;t the case, we&#8217;d like to hear about it.</p>
</div>
<div class="paragraph">
<p>If you were introducing either a protected member or a package-private
member onto a class in order to override a protected member that was
inherited from a superclass, you will have to make this introduction
public.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="staticAdvice">Removing static advice</h3>
<div class="paragraph">
<p>Static advice has been removed from the language. Now, every piece of
advice is non-static, meaning that it will run in the context of an
aspect instance.</p>
</div>
<div class="paragraph">
<p>If you have an aspect that only contains static advice, has no "of"
clause or is declared "of eachJVM()", and is not extended by another
aspect, simply remove the keyword "static" from all pieces of advice,
and make sure the aspect is not defined with the "abstract" modifier.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect Tracing {
  <span class="directive">static</span> before(): executions(* *(..)) {
    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Got Here! </span><span class="delimiter">&quot;</span></span> + thisJoinPoint);
  }
}

<span class="comment">// ==&gt;</span>

aspect Tracing {
  before(): execution(* *(..)) {
    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Got Here! </span><span class="delimiter">&quot;</span></span> + thisJoinPoint);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Otherwise, if you have an aspect contains both static and non-static
advice, is extended, or is "of eachObject(&#8230;&#8203;)" or "of
eachcflowroot(&#8230;&#8203;)", you should group your static advice together and
put it in a new aspect, possibly even an inner aspect.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect ComplexTracing of eachobject(cflow(executions(<span class="type">void</span> Main.main(..)))) {
  <span class="directive">static</span> before(): executions(* *(..)) {
    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Got Here! </span><span class="delimiter">&quot;</span></span> + thisJoinPoint);
  }
  <span class="directive">static</span> after(): executions(* *(..)) {
    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Returned! </span><span class="delimiter">&quot;</span></span> + thisJoinPoint);
  }

  <span class="comment">// some other dynamic advice, fields, etc</span>
}

<span class="comment">// ==&gt;</span>

aspect ComplexTracing of eachobject(cflow(executions(<span class="type">void</span> Main.main(..)))) {
  <span class="directive">static</span> aspect AlwaysTracing {
    before(): execution(* *(..)) {
      <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Got Here! </span><span class="delimiter">&quot;</span></span> + thisJoinPoint);
    }
    after(): execution(* *(..)) {
      <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Returned! </span><span class="delimiter">&quot;</span></span> + thisJoinPoint);
    }
  }

  <span class="comment">// some other dynamic advice, fields, etc</span>
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aspect-aspect">Fixing aspect-aspect inheritance</h3>
<div class="paragraph">
<p>Aspects can now only extend abstract aspects. This restriction may cause
some redesign of aspect hierarchies. You will probably find that for the
majority of your code the most serious change this requires is to add an
explicit <code>abstract</code> modifier to a super-aspect that was already
implicitly abstract.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect BaseTracing {
  <span class="directive">abstract</span> pointcut traced();
  before(): traced() {
    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Got Here! </span><span class="delimiter">&quot;</span></span> + thisJoinPoint);
  }
}

<span class="comment">// ==&gt;</span>

<span class="comment">// make this abstract aspect explicitly abstract</span>
<span class="directive">abstract</span> aspect BaseTracing {
  <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This change has also affected the <code>getAspect</code> static method. Now,
<code>getAspect</code> is only defined on non-abstract aspects. Previously, you
could call <code>getAspect</code> on an abstract superaspect and (sometimes) get an
instance of a subaspect back.</p>
</div>
<div class="paragraph">
<p>This pattern was used in the Spacewar example in the AspectJ
distribution. We had the class hierarchy</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">SpaceObject (abstract)
  |- Ship
  |- Bullet
  |- EnergyPellet</code></pre>
</div>
</div>
<div class="paragraph">
<p>And the aspect hierarchy</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">SpaceObjectDA (abstract)
  |- ShipDA of eachobject(instanceof(Ship))
  |- BulletDA of eachobject(instanceof(Ship))
  |- EnergyPacketDA of eachobject(instanceof(Ship))</code></pre>
</div>
</div>
<div class="paragraph">
<p>And we would call <code>SpaceObjectDA.getAspect(SpaceObject)</code> to access the
aspect associated with a ship, bullet, or energy pellet. This pattern
depended on the <code>SpaceObjectDA</code> aspect hierarchy exactly mirroring the
<code>SpaceObject</code> hierarchy, and being maintained that way.</p>
</div>
<div class="paragraph">
<p>A better way to implement this kind of design aspect is to use private
introduction, a new feature of AspectJ.</p>
</div>
</div>
<div class="sect2">
<h3 id="usingPrivateIntroduction">Using private introduction</h3>
<div class="paragraph">
<p>A common pattern for AspectJ programs that need to associate some state
with every object of a particular type has been to use aspects that are
defined <code>of eachobject(instanceof(&#8230;&#8203;))</code>. A prime example of this was
the <code>BoundPoint</code> aspect of the bean example: which needed to associate
each point with a <code>PropertyChangeSupport</code> object.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect BoundPoint of eachobject(<span class="keyword">instanceof</span>(<span class="predefined-type">Point</span>)) {

  java.beans.PropertyChangeSupport support = <span class="predefined-constant">null</span>;

  after() returning(<span class="predefined-type">Point</span> p): receptions(p.new(..)){
    support = <span class="keyword">new</span> <span class="predefined-type">PropertyChangeSupport</span>(myPoint);
  }

  around(<span class="predefined-type">Point</span> p) returns <span class="type">void</span>: receptions(<span class="type">void</span> p.set*(*)) {
    <span class="comment">// code that uses support</span>
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the new version of AspectJ, a better way of accomplishing many of
these state association is to use privately introduced fields. Instead
of creating an aspect instance for every <code>Point</code> object, store the
<code>PropertyChagneSupport</code> object in the <code>Point</code> objects themselves.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect BoundPoint {
  <span class="directive">private</span> <span class="predefined-type">PropertyChangeSupport</span> <span class="predefined-type">Point</span>.support = <span class="keyword">new</span> <span class="predefined-type">PropertyChangeSupport</span>(<span class="local-variable">this</span>);

  <span class="type">void</span> around(<span class="predefined-type">Point</span> p): setters(p) {
    <span class="comment">// code that uses p.support</span>
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Just as in the past, the PropertyChangeSupport object is not accessable
to anyone but the aspect, but now less mechanism is needed.</p>
</div>
<div class="paragraph">
<p>There are times when changing aspects that are defined
<code>of eachobject(instanceof(&#8230;&#8203;))</code> may not be reasonable. If the aspect
instance is stored or passed to other methods, then having a real
<code>of eachobject(instanceof(&#8230;&#8203;))</code>, now written <code>perthis(this(&#8230;&#8203;))</code>,
association may capture the crosscutting concern best.</p>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="pre07b11">Porting pre-0.7beta11 code</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="#twoArgumentCalls">Removing two-argument calls</a></p>
</li>
<li>
<p><a href="#adviceInClasses">Removing advice from Class declarations</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following changes are only required when porting code written prior
to the 0.7beta11 release of AspectJ.</p>
</div>
<div class="sect2">
<h3 id="twoArgumentCalls">Removing two-argument calls</h3>
<div class="paragraph">
<p>In AspectJ 0.7beta11, the two-argument <code>calls</code> primitive pointcut
designator was deprecated. Removing these designators will require
different cases depending on what the original pointcut did.</p>
</div>
<div class="sect3">
<h4 id="_calls_to_static_methods">Calls to static methods</h4>
<div class="paragraph">
<p>For pointcuts denoting calls to particular static methods, such as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">calls(<span class="predefined-type">String</span>, <span class="directive">static</span> <span class="predefined-type">String</span> valueOf(<span class="type">int</span>)) <span class="comment">// deprecated</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>the transformation is easy. Simply make the desired signature explicit.
Instead of catching all calls to any static method that happens to have
the signature <code>String valueOf(int)</code>, catch calls to that exact method
defined in the String class.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">call(<span class="directive">static</span> <span class="predefined-type">String</span> <span class="predefined-type">String</span>.valueOf(<span class="type">int</span>))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Pointcuts denoting calls to classes of static methods can also be
rewritten with these rules. For example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">calls(my.package.*, <span class="directive">static</span> * get*(..)) <span class="comment">// deprecated</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>should now be written</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">call(<span class="directive">static</span> * my.package.*.get*(..))</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_calls_to_non_static_methods">Calls to non-static methods</h4>
<div class="paragraph">
<p>Many pointcuts denoting calls to non-static methods can be fixed the
same way that those pointcuts denoting calls to static methods are
fixed. So,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">calls(<span class="predefined-type">Thread</span>, <span class="type">int</span> getPriority()) <span class="comment">// deprecated</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>which denotes all calls to nullary int methods named <code>getPriority</code> when
the called object is an instance of the <code>Thread</code> type, can almost always
be rewritten</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">call(<span class="type">int</span> <span class="predefined-type">Thread</span>.getPriority())</code></pre>
</div>
</div>
<div class="paragraph">
<p>which denotes all calls to the nullary int <code>Thread.getPriority()</code>
method.</p>
</div>
<div class="paragraph">
<p>Expanding the signature picks out slightly different join points than
the original two-argument form. This won&#8217;t matter for most programs, but
in some cases the differences may be noticable. In particular, the
expanded-signature form only picks out those calls where the called
object is statically typed to <code>Thread</code> when its <code>int getPriority()</code>
method is called. If you want to capture calls to the
<code>int Thread.getPriority()</code> method, regardless of how the called object
is statically typed, you shoud use the different translation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">call(<span class="type">int</span> getPriority()) &amp;&amp; target(<span class="predefined-type">Thread</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will capture all call join points of methods with signature
<code>int Thread.getPriority()</code>.</p>
</div>
<div class="paragraph">
<p>It will also denote any join points if the Thread type does not define
(possibly abstractly) some <code>int getPriority()</code> method, though.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="adviceInClasses">Removing advice from Class declarations</h3>
<div class="paragraph">
<p>The simplest way to remove an advice declaration from a class is to
simply define the advice declaration in an inner aspect. So, instead of</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">C</span> {
  <span class="directive">static</span> before(): executions(C.new()) { <span class="comment">/*...*/</span> } <span class="comment">// deprecated</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>write</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">C</span> {
  <span class="directive">static</span> aspect ConstructionProtocol {
    <span class="directive">static</span> before(): executions(C.new()) { <span class="comment">/*...*/</span> }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If your advice doesn&#8217;t refer to any inner classes or interfaces of C,
you can move the inner aspect out of the class entirely.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">C</span> { <span class="comment">/*...*/</span> }

aspect ConstructionProtocol {
  <span class="directive">static</span> before(): execution(C.new()) { <span class="comment">/*...*/</span> }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Your code will be clearer if you consider the purpose of each piece of
advice when you make this change. It may be that some of the advice
naturally belongs to another aspect, perhaps already existing. Or it may
be that some pieces of advice in a class are associated to one concern
and some to another; in which case more than aspect would be
appropriate.</p>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="pre07b10">Porting pre-0.7beta10 code</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="#joinPoints">Changing access to thisJoinPoint</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following changes are only required when porting code written prior
to the 0.7beta10 release of AspectJ.</p>
</div>
<div class="sect2">
<h3 id="joinPoints">Changing access to thisJoinPoint</h3>
<div class="paragraph">
<p>In AspectJ 0.7beta10, access to the reflective object <code>thisJoinPoint</code>
substantially changed. The two parts of this change were the elimination
of the <code>runNext()</code> static method, and the use of an interface hierarchy
represent the join point object.</p>
</div>
<div class="sect3">
<h4 id="proceed"><code>thisJoinPoint.runNext()</code> to <code>proceed()</code></h4>
<div class="paragraph">
<p>The elimination of the <code>runNext()</code> static method requires almost no
porting work. An automatic replacement of the string</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">thisJoinPoint.runNext</code></pre>
</div>
</div>
<div class="paragraph">
<p>with the string</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">proceed</code></pre>
</div>
</div>
<div class="paragraph">
<p>will do the job. However, if any around advice used the identifier
<code>proceed</code> as a formal parameter or local variable, it must be renamed,
and if any aspect used it as a field, then references to the field in
around advice should be made explicit (prefixing the reference with the
aspect name or <code>this</code>, depending on whether the field is static or
not).</p>
</div>
</div>
<div class="sect3">
<h4 id="thisJoinPoint">Using <code>thisJoinPoint</code></h4>
<div class="paragraph">
<p>While access to reflective information through <code>thisJoinPoint</code> is more
powerful and regular through its interface hierarchy, the previous uses
must be rewritten. Changing your code will likely require manual
editing, but in doing so your code should get simpler and cleaner.</p>
</div>
<div class="paragraph">
<p>Many existing uses of the fields on join points can be re-written to use
one of:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>thisJoinPoint.toString()</code></p>
</li>
<li>
<p><code>thisJoinPoint.toShortString()</code></p>
</li>
<li>
<p><code>thisJoinPoint.toLongString()</code></p>
</li>
<li>
<p><code>thisJoinPoint.getSignature().toString()</code></p>
</li>
<li>
<p><code>thisJoinPoint.getSignature().toShortString()</code></p>
</li>
<li>
<p><code>thisJoinPoint.getSignature().toLongString()</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>System.out.println(thisJoinPoint.className + "." + thisJoinPoint.methodName)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>can be replaced with</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>System.out.println(thisJoinPoint)</code> or</p>
</li>
<li>
<p><code>System.out.println(thisJoinPoint.getSignature().toShortString())</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>with comparable behavior.</p>
</div>
<div class="paragraph">
<p>Accesses to the parameters field of join points should be changed as
follows. A field access like:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>thisJoinPoint.parameters</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>must be changed to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>thisJoinPoint.getArgs()</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Accesses to the methodName and className fields of join points that are
not suitable for replacement with a toString method, should be changed
as follows. Field accesses like:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>thisJoinPoint.className</code></p>
</li>
<li>
<p><code>thisJoinPoint.methodName</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>must be changed to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>thisJoinPoint.getSignature().getDeclaringType().getName()</code></p>
</li>
<li>
<p><code>thisJoinPoint.getSignature().getName()</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Accessses to the parameterNames and parameterTypes fields of join
points, that are not suitable for conversion to one of the toString()
methods should be changed as follows. Field access like:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>thisJoinPoint.parameterNames</code></p>
</li>
<li>
<p><code>thisJoinPoint.parameterTypes</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>must be changed to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>CodeSignature)thisJoinPoint.getSignature(.getParameterNames()</code></p>
</li>
<li>
<p><code>CodeSignature)thisJoinPoint.getSignature(.getParameterTypes()</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
</body>
</html>