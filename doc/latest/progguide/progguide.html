<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.20">
<title>The AspectJTM Programming Guide</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="./asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="./coderay-asciidoctor.css">
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>The AspectJ<sup>TM</sup> Programming Guide</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_preface">Preface</a></li>
<li><a href="#starting">Getting Started with AspectJ</a>
<ul class="sectlevel2">
<li><a href="#starting-intro">Introduction</a></li>
<li><a href="#starting-aspectj">Introduction to AspectJ</a></li>
<li><a href="#starting-development">Development Aspects</a></li>
<li><a href="#starting-production">Production Aspects</a></li>
<li><a href="#starting-conclusion">Conclusion</a></li>
</ul>
</li>
<li><a href="#language">The AspectJ Language</a>
<ul class="sectlevel2">
<li><a href="#language-intro">Introduction</a></li>
<li><a href="#language-anatomy">The Anatomy of an Aspect</a></li>
<li><a href="#language-joinPoints">Join Points and Pointcuts</a></li>
<li><a href="#language-advice">Advice</a></li>
<li><a href="#language-interType">Inter-type declarations</a></li>
<li><a href="#language-thisJoinPoint"><code>thisJoinPoint</code></a></li>
</ul>
</li>
<li><a href="#examples">Examples</a>
<ul class="sectlevel2">
<li><a href="#examples-intro">Introduction</a></li>
<li><a href="#examples-howto">Obtaining, Compiling and Running the Examples</a></li>
<li><a href="#examples-basic">Basic Techniques</a></li>
<li><a href="#examples-development">Development Aspects</a></li>
<li><a href="#examples-production">Production Aspects</a></li>
<li><a href="#examples-reusable">Reusable Aspects</a></li>
</ul>
</li>
<li><a href="#_idioms">Idioms</a>
<ul class="sectlevel2">
<li><a href="#idioms-intro">Introduction</a></li>
</ul>
</li>
<li><a href="#_pitfalls">Pitfalls</a>
<ul class="sectlevel2">
<li><a href="#pitfalls-intro">Introduction</a></li>
<li><a href="#pitfalls-infiniteLoops">Infinite loops</a></li>
</ul>
</li>
<li><a href="#quick">AspectJ Quick Reference</a>
<ul class="sectlevel2">
<li><a href="#quick-pointcuts">Pointcuts</a></li>
<li><a href="#quick-typePatterns">Type Patterns</a></li>
<li><a href="#quick-advice">Advice</a></li>
<li><a href="#quick-interType">Inter-type member declarations</a></li>
<li><a href="#quick-other">Other declarations</a></li>
<li><a href="#quick-aspectAssociations">Aspects</a></li>
</ul>
</li>
<li><a href="#semantics">Language Semantics</a>
<ul class="sectlevel2">
<li><a href="#semantics-intro">Introduction</a></li>
<li><a href="#semantics-joinPoints">Join Points</a></li>
<li><a href="#semantics-pointcuts">Pointcuts</a></li>
<li><a href="#semantics-advice">Advice</a></li>
<li><a href="#semantics-declare">Static crosscutting</a></li>
<li><a href="#semantics-aspects">Aspects</a></li>
</ul>
</li>
<li><a href="#implementation">Implementation Notes</a>
<ul class="sectlevel2">
<li><a href="#_compiler_notes">Compiler Notes</a></li>
<li><a href="#_bytecode_notes">Bytecode Notes</a></li>
<li><a href="#_annotation_style_notes">Annotation-style Notes</a></li>
<li><a href="#_summary_of_implementation_requirements">Summary of implementation requirements</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><em>by the AspectJ Team</em></p>
</div>
<div class="paragraph">
<p><em>Copyright (c) 1998-2001 Xerox Corporation, 2002 Palo Alto Research Center, Incorporated, 2003-2005 Contributors.
All rights reserved.</em></p>
</div>
<div class="paragraph">
<p>This programming guide describes the AspectJ language. A companion guide describes the tools which are part of the
AspectJ development environment.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If you are completely new to AspectJ, please read the <a href="#starting">getting started</a> chapter for a
broad overview of AspectJ programming.</p>
</li>
<li>
<p>If you are already familiar with AspectJ, but want a deeper understanding, you can learn more about the
<a href="#language">AspectJ language</a> and look at the examples in the chapter.</p>
</li>
<li>
<p>If you want a more formal definition of AspectJ, please refer to the <a href="#semantics">language semantics</a>
section.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_preface">Preface</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This programming guide does three things. It</p>
</div>
<div class="ulist">
<ul>
<li>
<p>introduces the AspectJ language</p>
</li>
<li>
<p>defines each of AspectJ&#8217;s constructs and their semantics, and</p>
</li>
<li>
<p>provides examples of their use.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>It includes appendices that give a reference to the syntax of AspectJ, a
more formal description of AspectJ&#8217;s semantics, and a description of
notes about the AspectJ implementation.</p>
</div>
<div class="paragraph">
<p>The first section, <a href="#">Getting Started with AspectJ</a>, provides a gentle overview of
writing AspectJ programs. It also shows how one can introduce AspectJ
into an existing development effort in stages, reducing the associated
risk. You should read this section if this is your first exposure to
AspectJ and you want to get a sense of what AspectJ is all about.</p>
</div>
<div class="paragraph">
<p>The second section, <a href="#">The AspectJ Language</a>, covers the features of the
language in more detail, using code snippets as examples. All the basics
of the language is covered, and after reading this section, you should
be able to use the language correctly.</p>
</div>
<div class="paragraph">
<p>The next section, <a href="#">Examples</a>, comprises a set of complete
programs that not only show the features being used, but also try to
illustrate recommended practice. You should read this section after you
are familiar with the elements of AspectJ.</p>
</div>
<div class="paragraph">
<p>Finally, there are two short chapters, one on <a href="#">Idioms</a> and one
on <a href="#">Pitfalls</a>.</p>
</div>
<div class="paragraph">
<p>The back matter contains several appendices that cover an
<a href="#">AspectJ Quick Reference</a>, a more in depth coverage of
its <a href="#">Language Semantics</a>, and a description of the latitude enjoyed by
its <a href="#">Implementation Notes</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="starting">Getting Started with AspectJ</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="starting-intro">Introduction</h3>
<div class="paragraph">
<p>Many software developers are attracted to the idea of aspect-oriented
programming (AOP) but unsure about how to begin using the technology.
They recognize the concept of crosscutting concerns, and know that they
have had problems with the implementation of such concerns in the past.
But there are many questions about how to adopt AOP into the development
process. Common questions include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Can I use aspects in my existing code?</p>
</li>
<li>
<p>What kinds of benefits can I expect to get from using aspects?</p>
</li>
<li>
<p>How do I find aspects in my programs?</p>
</li>
<li>
<p>How steep is the learning curve for AOP?</p>
</li>
<li>
<p>What are the risks of using this new technology?</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This chapter addresses these questions in the context of AspectJ: a
general-purpose aspect-oriented extension to Java. A series of abridged
examples illustrate the kinds of aspects programmers may want to
implement using AspectJ and the benefits associated with doing so.
Readers who would like to understand the examples in more detail, or who
want to learn how to program examples like these, can find more complete
examples and supporting material linked from the
<a href="https://www.eclipse.org/aspectj/">AspectJ web site</a>.</p>
</div>
<div class="paragraph">
<p>A significant risk in adopting any new technology is going too far too
fast. Concern about this risk causes many organizations to be
conservative about adopting new technology. To address this issue, the
examples in this chapter are grouped into three broad categories, with
aspects that are easier to adopt into existing development projects
coming earlier in this chapter. The next section,
<a href="#starting-aspectj">Introduction to AspectJ</a>, we present the core of
AspectJ&#8217;s features, and in <a href="#starting-development">Development
Aspects</a>, we present aspects that facilitate tasks such as debugging,
testing and performance tuning of applications. And, in the section
following, <a href="#starting-production">Production Aspects</a>, we present
aspects that implement crosscutting functionality common in Java
applications. We will defer discussing a third category of aspects,
reusable aspects, until <a href="#language">The AspectJ Language</a>.</p>
</div>
<div class="paragraph">
<p>These categories are informal, and this ordering is not the only way to
adopt AspectJ. Some developers may want to use a production aspect right
away. But our experience with current AspectJ users suggests that this
is one ordering that allows developers to get experience with (and
benefit from) AOP technology quickly, while also minimizing risk.</p>
</div>
</div>
<div class="sect2">
<h3 id="starting-aspectj">Introduction to AspectJ</h3>
<div class="paragraph">
<p>This section presents a brief introduction to the features of AspectJ
used later in this chapter. These features are at the core of the
language, but this is by no means a complete overview of AspectJ.</p>
</div>
<div class="paragraph">
<p>The features are presented using a simple figure editor system. A
<code>Figure</code> consists of a number of <code>FigureElements</code>, which can be either
<code>Point</code>s or <code>Line</code>s. The <code>Figure</code> class provides factory services. There
is also a <code>Display</code>. Most example programs later in this chapter are
based on this system as well.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/figureUML.png" alt="UML for the <code>FigureEditor</code> example"></span></p>
</div>
<div class="paragraph">
<p>The motivation for AspectJ (and likewise for aspect-oriented
programming) is the realization that there are issues or concerns that
are not well captured by traditional programming methodologies. Consider
the problem of enforcing a security policy in some application. By its
nature, security cuts across many of the natural units of modularity of
the application. Moreover, the security policy must be uniformly applied
to any additions as the application evolves. And the security policy
that is being applied might itself evolve. Capturing concerns like a
security policy in a disciplined way is difficult and error-prone in a
traditional programming language.</p>
</div>
<div class="paragraph">
<p>Concerns like security cut across the natural units of modularity. For
object-oriented programming languages, the natural unit of modularity is
the class. But in object-oriented programming languages, crosscutting
concerns are not easily turned into classes precisely because they cut
across classes, and so these aren&#8217;t reusable, they can&#8217;t be refined or
inherited, they are spread through out the program in an undisciplined
way, in short, they are difficult to work with.</p>
</div>
<div class="paragraph">
<p>Aspect-oriented programming is a way of modularizing crosscutting
concerns much like object-oriented programming is a way of modularizing
common concerns. AspectJ is an implementation of aspect-oriented
programming for Java.</p>
</div>
<div class="paragraph">
<p>AspectJ adds to Java just one new concept, a join point&#8201;&#8212;&#8201;and that&#8217;s
really just a name for an existing Java concept. It adds to Java only a
few new constructs: pointcuts, advice, inter-type declarations and
aspects. Pointcuts and advice dynamically affect program flow,
inter-type declarations statically affects a program&#8217;s class hierarchy,
and aspects encapsulate these new constructs.</p>
</div>
<div class="paragraph">
<p>A <em>join point</em> is a well-defined point in the program flow. A <em>pointcut</em>
picks out certain join points and values at those points. A piece of
<em>advice</em> is code that is executed when a join point is reached. These
are the dynamic parts of AspectJ.</p>
</div>
<div class="paragraph">
<p>AspectJ also has different kinds of <em>inter-type declarations</em> that allow
the programmer to modify a program&#8217;s static structure, namely, the
members of its classes and the relationship between classes.</p>
</div>
<div class="paragraph">
<p>AspectJ&#8217;s <em>aspect</em> are the unit of modularity for crosscutting concerns.
They behave somewhat like Java classes, but may also include pointcuts,
advice and inter-type declarations.</p>
</div>
<div class="paragraph">
<p>In the sections immediately following, we are first going to look at
join points and how they compose into pointcuts. Then we will look at
advice, the code which is run when a pointcut is reached. We will see
how to combine pointcuts and advice into aspects, AspectJ&#8217;s reusable,
inheritable unit of modularity. Lastly, we will look at how to use
inter-type declarations to deal with crosscutting concerns of a
program&#8217;s class structure.</p>
</div>
<div class="sect3">
<h4 id="_the_dynamic_join_point_model">The Dynamic Join Point Model</h4>
<div class="paragraph">
<p>A critical element in the design of any aspect-oriented language is the
join point model. The join point model provides the common frame of
reference that makes it possible to define the dynamic structure of
crosscutting concerns. This chapter describes AspectJ&#8217;s dynamic join
points, in which join points are certain well-defined points in the
execution of the program.</p>
</div>
<div class="paragraph">
<p>AspectJ provides for many kinds of join points, but this chapter
discusses only one of them: method call join points. A method call join
point encompasses the actions of an object receiving a method call. It
includes all the actions that comprise a method call, starting after all
arguments are evaluated up to and including return (either normally or
by throwing an exception).</p>
</div>
<div class="paragraph">
<p>Each method call at runtime is a different join point, even if it comes
from the same call expression in the program. Many other join points may
run while a method call join point is executing&#8201;&#8212;&#8201;all the join points
that happen while executing the method body, and in those methods called
from the body. We say that these join points execute in the <em>dynamic
context</em> of the original call join point.</p>
</div>
</div>
<div class="sect3">
<h4 id="pointcuts-starting">Pointcuts</h4>
<div class="paragraph">
<p>In AspectJ, <em>pointcuts</em> pick out certain join points in the program
flow. For example, the pointcut</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">call(<span class="type">void</span> <span class="predefined-type">Point</span>.setX(<span class="type">int</span>))</code></pre>
</div>
</div>
<div class="paragraph">
<p>picks out each join point that is a call to a method that has the
signature <code>void Point.setX(int)</code> - that is, <code>Point</code>'s void <code>setX</code> method
with a single <code>int</code> parameter.</p>
</div>
<div class="paragraph">
<p>A pointcut can be built out of other pointcuts with and, or, and not
(spelled <code>&amp;&amp;</code>, <code>||</code>, and <code>!</code>). For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">call(<span class="type">void</span> <span class="predefined-type">Point</span>.setX(<span class="type">int</span>)) ||
call(<span class="type">void</span> <span class="predefined-type">Point</span>.setY(<span class="type">int</span>))</code></pre>
</div>
</div>
<div class="paragraph">
<p>picks out each join point that is either a call to <code>setX</code> or a call to
<code>setY</code>.</p>
</div>
<div class="paragraph">
<p>Pointcuts can identify join points from many different types - in other
words, they can crosscut types. For example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">call(<span class="type">void</span> FigureElement.setXY(<span class="type">int</span>,<span class="type">int</span>)) ||
call(<span class="type">void</span> <span class="predefined-type">Point</span>.setX(<span class="type">int</span>))              ||
call(<span class="type">void</span> <span class="predefined-type">Point</span>.setY(<span class="type">int</span>))              ||
call(<span class="type">void</span> <span class="predefined-type">Line</span>.setP1(<span class="predefined-type">Point</span>))            ||
call(<span class="type">void</span> <span class="predefined-type">Line</span>.setP2(<span class="predefined-type">Point</span>));</code></pre>
</div>
</div>
<div class="paragraph">
<p>picks out each join point that is a call to one of five methods (the
first of which is an interface method, by the way).</p>
</div>
<div class="paragraph">
<p>In our example system, this pointcut captures all the join points when a
<code>FigureElement</code> moves. While this is a useful way to specify this
crosscutting concern, it is a bit of a mouthful. So AspectJ allows
programmers to define their own named pointcuts with the <code>pointcut</code>
form. So the following declares a new, named pointcut:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">pointcut move():
  call(<span class="type">void</span> FigureElement.setXY(<span class="type">int</span>,<span class="type">int</span>)) ||
  call(<span class="type">void</span> <span class="predefined-type">Point</span>.setX(<span class="type">int</span>))              ||
  call(<span class="type">void</span> <span class="predefined-type">Point</span>.setY(<span class="type">int</span>))              ||
  call(<span class="type">void</span> <span class="predefined-type">Line</span>.setP1(<span class="predefined-type">Point</span>))            ||
  call(<span class="type">void</span> <span class="predefined-type">Line</span>.setP2(<span class="predefined-type">Point</span>));</code></pre>
</div>
</div>
<div class="paragraph">
<p>and whenever this definition is visible, the programmer can simply use
<code>move()</code> to capture this complicated pointcut.</p>
</div>
<div class="paragraph">
<p>The previous pointcuts are all based on explicit enumeration of a set of
method signatures. We sometimes call this <em>name-based</em> crosscutting.
AspectJ also provides mechanisms that enable specifying a pointcut in
terms of properties of methods other than their exact name. We call this
<em>property-based</em> crosscutting. The simplest of these involve using
wildcards in certain fields of the method signature. For example, the
pointcut</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">call(<span class="type">void</span> Figure.make*(..))</code></pre>
</div>
</div>
<div class="paragraph">
<p>picks out each join point that&#8217;s a call to a void method defined on
<code>Figure</code> whose the name begins with &#8220;make&#8221; regardless of the method&#8217;s
parameters. In our system, this picks out calls to the factory methods
<code>makePoint</code> and <code>makeLine</code>. The pointcut</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">call(<span class="directive">public</span> * Figure.* (..))</code></pre>
</div>
</div>
<div class="paragraph">
<p>picks out each call to <code>Figure</code>'s public methods.</p>
</div>
<div class="paragraph">
<p>But wildcards aren&#8217;t the only properties AspectJ supports. Another
pointcut, <code>cflow</code>, identifies join points based on whether they occur in
the dynamic context of other join points. So</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">cflow(move())</code></pre>
</div>
</div>
<div class="paragraph">
<p>picks out each join point that occurs in the dynamic context of the join
points picked out by <code>move()</code>, our named pointcut defined above. So this
picks out each join points that occurrs between when a move method is
called and when it returns (either normally or by throwing an
exception).</p>
</div>
</div>
<div class="sect3">
<h4 id="advice-starting">Advice</h4>
<div class="paragraph">
<p>So pointcuts pick out join points. But they don&#8217;t <em>do</em> anything apart
from picking out join points. To actually implement crosscutting
behavior, we use advice. Advice brings together a pointcut (to pick out
join points) and a body of code (to run at each of those join points).</p>
</div>
<div class="paragraph">
<p>AspectJ has several different kinds of advice. <em>Before advice</em> runs as a
join point is reached, before the program proceeds with the join point.
For example, before advice on a method call join point runs before the
actual method starts running, just after the arguments to the method
call are evaluated.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">before(): move() {
  <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">about to move</span><span class="delimiter">&quot;</span></span>);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>After advice</em> on a particular join point runs after the program
proceeds with that join point. For example, after advice on a method
call join point runs after the method body has run, just before before
control is returned to the caller. Because Java programs can leave a
join point 'normally' or by throwing an exception, there are three kinds
of after advice: <code>after returning</code>, <code>after
        throwing</code>, and plain <code>after</code> (which runs after returning <em>or</em>
throwing, like Java&#8217;s <code>finally</code>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">after() returning: move() {
  <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">just successfully moved</span><span class="delimiter">&quot;</span></span>);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Around advice</em> on a join point runs as the join point is reached, and
has explicit control over whether the program proceeds with the join
point. Around advice is not discussed in this section.</p>
</div>
<div class="sect4">
<h5 id="_exposing_context_in_pointcuts">Exposing Context in Pointcuts</h5>
<div class="paragraph">
<p>Pointcuts not only pick out join points, they can also expose part of
the execution context at their join points. Values exposed by a pointcut
can be used in the body of advice declarations.</p>
</div>
<div class="paragraph">
<p>An advice declaration has a parameter list (like a method) that gives
names to all the pieces of context that it uses. For example, the after
advice</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">after(FigureElement fe, <span class="type">int</span> x, <span class="type">int</span> y) returning:
  <span class="comment">// SomePointcut...</span>
{
  <span class="comment">// SomeBody</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>uses three pieces of exposed context, a <code>FigureElement</code> named fe, and
two <code>int</code>s named x and y.</p>
</div>
<div class="paragraph">
<p>The body of the advice uses the names just like method parameters, so</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">after(FigureElement fe, <span class="type">int</span> x, <span class="type">int</span> y) returning:
  <span class="comment">// SomePointcut...</span>
{
  <span class="predefined-type">System</span>.out.println(fe + <span class="string"><span class="delimiter">&quot;</span><span class="content"> moved to (</span><span class="delimiter">&quot;</span></span> + x + <span class="string"><span class="delimiter">&quot;</span><span class="content">, </span><span class="delimiter">&quot;</span></span> + y + <span class="string"><span class="delimiter">&quot;</span><span class="content">)</span><span class="delimiter">&quot;</span></span>);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The advice&#8217;s pointcut publishes the values for the advice&#8217;s arguments.
The three primitive pointcuts <code>this</code>, <code>target</code> and <code>args</code> are used to
publish these values. So now we can write the complete piece of advice:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">after(FigureElement fe, <span class="type">int</span> x, <span class="type">int</span> y) returning:
  call(<span class="type">void</span> FigureElement.setXY(<span class="type">int</span>, <span class="type">int</span>))
  &amp;&amp; target(fe)
  &amp;&amp; args(x, y)
{
  <span class="predefined-type">System</span>.out.println(fe + <span class="string"><span class="delimiter">&quot;</span><span class="content"> moved to (</span><span class="delimiter">&quot;</span></span> + x + <span class="string"><span class="delimiter">&quot;</span><span class="content">, </span><span class="delimiter">&quot;</span></span> + y + <span class="string"><span class="delimiter">&quot;</span><span class="content">)</span><span class="delimiter">&quot;</span></span>);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The pointcut exposes three values from calls to <code>setXY</code>: the target
<code>FigureElement</code>&#8201;&#8212;&#8201;which it publishes as <code>fe</code>, so it becomes the first
argument to the after advice&#8201;&#8212;&#8201;and the two int arguments&#8201;&#8212;&#8201;which it
publishes as <code>x</code> and <code>y</code>, so they become the second and third argument
to the after advice.</p>
</div>
<div class="paragraph">
<p>So the advice prints the figure element that was moved and its new <code>x</code>
and <code>y</code> coordinates after each <code>setXY</code> method call.</p>
</div>
<div class="paragraph">
<p>A named pointcut may have parameters like a piece of advice. When the
named pointcut is used (by advice, or in another named pointcut), it
publishes its context by name just like the <code>this</code>, <code>target</code> and <code>args</code>
pointcut. So another way to write the above advice is</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">pointcut setXY(FigureElement fe, <span class="type">int</span> x, <span class="type">int</span> y):
  call(<span class="type">void</span> FigureElement.setXY(<span class="type">int</span>, <span class="type">int</span>))
  &amp;&amp; target(fe)
  &amp;&amp; args(x, y);

after(FigureElement fe, <span class="type">int</span> x, <span class="type">int</span> y) returning: setXY(fe, x, y) {
  <span class="predefined-type">System</span>.out.println(fe + <span class="string"><span class="delimiter">&quot;</span><span class="content"> moved to (</span><span class="delimiter">&quot;</span></span> + x + <span class="string"><span class="delimiter">&quot;</span><span class="content">, </span><span class="delimiter">&quot;</span></span> + y + <span class="string"><span class="delimiter">&quot;</span><span class="content">).</span><span class="delimiter">&quot;</span></span>);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_inter_type_declarations">Inter-type declarations</h4>
<div class="paragraph">
<p>Inter-type declarations in AspectJ are declarations that cut across
classes and their hierarchies. They may declare members that cut across
multiple classes, or change the inheritance relationship between
classes. Unlike advice, which operates primarily dynamically,
introduction operates statically, at compile-time.</p>
</div>
<div class="paragraph">
<p>Consider the problem of expressing a capability shared by some existing
classes that are already part of a class hierarchy, i.e. they already
extend a class. In Java, one creates an interface that captures this new
capability, and then adds to <em>each affected class</em> a method that
implements this interface.</p>
</div>
<div class="paragraph">
<p>AspectJ can express the concern in one place, by using inter-type
declarations. The aspect declares the methods and fields that are
necessary to implement the new capability, and associates the methods
and fields to the existing classes.</p>
</div>
<div class="paragraph">
<p>Suppose we want to have <code>Screen</code> objects observe changes to <code>Point</code>
objects, where <code>Point</code> is an existing class. We can implement this by
writing an aspect declaring that the class Point <code>Point</code> has an instance
field, <code>observers</code>, that keeps track of the <code>Screen</code> objects that are
observing <code>Point</code>s.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect PointObserving {
  <span class="directive">private</span> <span class="predefined-type">Vector</span> <span class="predefined-type">Point</span>.observers = <span class="keyword">new</span> <span class="predefined-type">Vector</span>();
  <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>observers</code> field is private, so only <code>PointObserving</code> can see it.
So observers are added or removed with the static methods <code>addObserver</code>
and <code>removeObserver</code> on the aspect.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect PointObserving {
  <span class="directive">private</span> <span class="predefined-type">Vector</span> <span class="predefined-type">Point</span>.observers = <span class="keyword">new</span> <span class="predefined-type">Vector</span>();

  <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> addObserver(<span class="predefined-type">Point</span> p, Screen s) {
    p.observers.add(s);
  }
  <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> removeObserver(<span class="predefined-type">Point</span> p, Screen s) {
    p.observers.remove(s);
  }
  <span class="comment">//...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Along with this, we can define a pointcut <code>changes</code> that defines what we
want to observe, and the after advice defines what we want to do when we
observe a change.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect PointObserving {
  <span class="directive">private</span> <span class="predefined-type">Vector</span> <span class="predefined-type">Point</span>.observers = <span class="keyword">new</span> <span class="predefined-type">Vector</span>();

  <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> addObserver(<span class="predefined-type">Point</span> p, Screen s) {
    p.observers.add(s);
  }
  <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> removeObserver(<span class="predefined-type">Point</span> p, Screen s) {
    p.observers.remove(s);
  }

  pointcut changes(<span class="predefined-type">Point</span> p): target(p) &amp;&amp; call(<span class="type">void</span> <span class="predefined-type">Point</span>.set*(<span class="type">int</span>));

  after(<span class="predefined-type">Point</span> p): changes(p) {
    <span class="predefined-type">Iterator</span> iter = p.observers.iterator();
    <span class="keyword">while</span> ( iter.hasNext() ) {
      updateObserver(p, (Screen)iter.next());
    }
  }

  <span class="directive">static</span> <span class="type">void</span> updateObserver(<span class="predefined-type">Point</span> p, Screen s) {
    s.display(p);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that neither <code>Screen</code>'s nor <code>Point</code>'s code has to be modified, and
that all the changes needed to support this new capability are local to
this aspect.</p>
</div>
</div>
<div class="sect3">
<h4 id="_aspects">Aspects</h4>
<div class="paragraph">
<p>Aspects wrap up pointcuts, advice, and inter-type declarations in a a
modular unit of crosscutting implementation. It is defined very much
like a class, and can have methods, fields, and initializers in addition
to the crosscutting members. Because only aspects may include these
crosscutting members, the declaration of these effects is localized.</p>
</div>
<div class="paragraph">
<p>Like classes, aspects may be instantiated, but AspectJ controls how that
instantiation happens&#8201;&#8212;&#8201;so you can&#8217;t use Java&#8217;s <code>new</code> form to build new
aspect instances. By default, each aspect is a singleton, so one aspect
instance is created. This means that advice may use non-static fields of
the aspect, if it needs to keep state around:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect Logging {
  <span class="predefined-type">OutputStream</span> logStream = <span class="predefined-type">System</span>.err;

  before(): move() {
    logStream.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">about to move</span><span class="delimiter">&quot;</span></span>);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Aspects may also have more complicated rules for instantiation, but
these will be described in a later chapter.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="starting-development">Development Aspects</h3>
<div class="paragraph">
<p>The next two sections present the use of aspects in increasingly
sophisticated ways. Development aspects are easily removed from
production builds. Production aspects are intended to be used in both
development and in production, but tend to affect only a few classes.</p>
</div>
<div class="paragraph">
<p>This section presents examples of aspects that can be used during
development of Java applications. These aspects facilitate debugging,
testing and performance tuning work. The aspects define behavior that
ranges from simple tracing, to profiling, to testing of internal
consistency within the application. Using AspectJ makes it possible to
cleanly modularize this kind of functionality, thereby making it
possible to easily enable and disable the functionality when desired.</p>
</div>
<div class="sect3">
<h4 id="_tracing">Tracing</h4>
<div class="paragraph">
<p>This first example shows how to increase the visibility of the internal
workings of a program. It is a simple tracing aspect that prints a
message at specified method calls. In our figure editor example, one
such aspect might simply trace whenever points are drawn.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect SimpleTracing {
  pointcut tracedCall():
    call(<span class="type">void</span> FigureElement.draw(GraphicsContext));

  before(): tracedCall() {
    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Entering: </span><span class="delimiter">&quot;</span></span> + thisJoinPoint);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This code makes use of the <code>thisJoinPoint</code> special variable. Within all
advice bodies this variable is bound to an object that describes the
current join point. The effect of this code is to print a line like the
following every time a figure element receives a <code>draw</code> method call:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">Entering: call(void FigureElement.draw(GraphicsContext))</code></pre>
</div>
</div>
<div class="paragraph">
<p>To understand the benefit of coding this with AspectJ consider changing
the set of method calls that are traced. With AspectJ, this just
requires editing the definition of the <code>tracedCalls</code> pointcut and
recompiling. The individual methods that are traced do not need to be
edited.</p>
</div>
<div class="paragraph">
<p>When debugging, programmers often invest considerable effort in figuring
out a good set of trace points to use when looking for a particular kind
of problem. When debugging is complete or appears to be complete it is
frustrating to have to lose that investment by deleting trace statements
from the code. The alternative of just commenting them out makes the
code look bad, and can cause trace statements for one kind of debugging
to get confused with trace statements for another kind of debugging.</p>
</div>
<div class="paragraph">
<p>With AspectJ it is easy to both preserve the work of designing a good
set of trace points and disable the tracing when it isn&#8217;t being used.
This is done by writing an aspect specifically for that tracing mode,
and removing that aspect from the compilation when it is not needed.</p>
</div>
<div class="paragraph">
<p>This ability to concisely implement and reuse debugging configurations
that have proven useful in the past is a direct result of AspectJ
modularizing a crosscutting design element the set of methods that are
appropriate to trace when looking for a given kind of information.</p>
</div>
</div>
<div class="sect3">
<h4 id="_profiling_and_logging">Profiling and Logging</h4>
<div class="paragraph">
<p>Our second example shows you how to do some very specific profiling.
Although many sophisticated profiling tools are available, and these can
gather a variety of information and display the results in useful ways,
you may sometimes want to profile or log some very specific behavior. In
these cases, it is often possible to write a simple aspect similar to
the ones above to do the job.</p>
</div>
<div class="paragraph">
<p>For example, the following aspect counts the number of calls to the
<code>rotate</code> method on a <code>Line</code> and the number of calls to the <code>set*</code>
methods of a <code>Point</code> that happen within the control flow of those calls
to <code>rotate</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect SetsInRotateCounting {
  <span class="type">int</span> rotateCount = <span class="integer">0</span>;
  <span class="type">int</span> setCount = <span class="integer">0</span>;

  before(): call(<span class="type">void</span> <span class="predefined-type">Line</span>.rotate(<span class="type">double</span>)) {
    rotateCount++;
  }

  before():
    call(<span class="type">void</span> <span class="predefined-type">Point</span>.set*(<span class="type">int</span>)) &amp;&amp;
    cflow(call(<span class="type">void</span> <span class="predefined-type">Line</span>.rotate(<span class="type">double</span>)))
  {
    setCount++;
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In effect, this aspect allows the programmer to ask very specific
questions like</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>How many times is the <code>rotate</code> method defined on <code>Line</code> objects called?</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>and</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>How many times are methods defined on <code>Point</code> objects whose name begins with
<code>"set"</code> called in fulfilling those <code>rotate</code> calls?</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Such questions may be difficult to express using standard profiling or
logging tools.</p>
</div>
</div>
<div class="sect3">
<h4 id="pre-and-post-conditions">Pre- and Post-Conditions</h4>
<div class="paragraph">
<p>Many programmers use the "Design by Contract" style popularized by
Bertand Meyer in Object-Oriented Software Construction, 2/e. In this
style of programming, explicit pre-conditions test that callers of a
method call it properly and explicit post-conditions test that methods
properly do the work they are supposed to.</p>
</div>
<div class="paragraph">
<p>AspectJ makes it possible to implement pre- and post-condition testing
in modular form. For example, this code</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect PointBoundsChecking {

  pointcut setX(<span class="type">int</span> x):
    (call(<span class="type">void</span> FigureElement.setXY(<span class="type">int</span>, <span class="type">int</span>)) &amp;&amp; args(x, *))
    || (call(<span class="type">void</span> <span class="predefined-type">Point</span>.setX(<span class="type">int</span>)) &amp;&amp; args(x));

  pointcut setY(<span class="type">int</span> y):
    (call(<span class="type">void</span> FigureElement.setXY(<span class="type">int</span>, <span class="type">int</span>)) &amp;&amp; args(*, y))
    || (call(<span class="type">void</span> <span class="predefined-type">Point</span>.setY(<span class="type">int</span>)) &amp;&amp; args(y));

  before(<span class="type">int</span> x): setX(x) {
    <span class="keyword">if</span> ( x &lt; MIN_X || x &gt; MAX_X )
      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalArgumentException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">x is out of bounds.</span><span class="delimiter">&quot;</span></span>);
  }

  before(<span class="type">int</span> y): setY(y) {
    <span class="keyword">if</span> ( y &lt; MIN_Y || y &gt; MAX_Y )
      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalArgumentException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">y is out of bounds.</span><span class="delimiter">&quot;</span></span>);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>implements the bounds checking aspect of pre-condition testing for
operations that move points. Notice that the <code>setX</code> pointcut refers to
all the operations that can set a Point&#8217;s <code>x</code> coordinate; this includes
the <code>setX</code> method, as well as half of the <code>setXY</code> method. In this sense
the <code>setX</code> pointcut can be seen as involving very fine-grained
crosscutting - it names the the <code>setX</code> method and half of the <code>setXY</code>
method.</p>
</div>
<div class="paragraph">
<p>Even though pre- and post-condition testing aspects can often be used
only during testing, in some cases developers may wish to include them
in the production build as well. Again, because AspectJ makes it
possible to modularize these crosscutting concerns cleanly, it gives
developers good control over this decision.</p>
</div>
</div>
<div class="sect3">
<h4 id="_contract_enforcement">Contract Enforcement</h4>
<div class="paragraph">
<p>The property-based crosscutting mechanisms can be very useful in
defining more sophisticated contract enforcement. One very powerful use
of these mechanisms is to identify method calls that, in a correct
program, should not exist. For example, the following aspect enforces
the constraint that only the well-known factory methods can add an
element to the registry of figure elements. Enforcing this constraint
ensures that no figure element is added to the registry more than once.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect RegistrationProtection {

  pointcut register(): call(<span class="type">void</span> <span class="predefined-type">Registry</span>.register(FigureElement));
  pointcut canRegister(): withincode(<span class="directive">static</span> * FigureElement.make*(..));

  before(): register() &amp;&amp; !canRegister() {
    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalAccessException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Illegal call </span><span class="delimiter">&quot;</span></span> + thisJoinPoint);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This aspect uses the withincode primitive pointcut to denote all join
points that occur within the body of the factory methods on
<code>FigureElement</code> (the methods with names that begin with &#8220;make&#8221;). This
is a property-based pointcut because it identifies join points based not
on their signature, but rather on the property that they occur
specifically within the code of another method. The before advice
declaration effectively says signal an error for any calls to register
that are not within the factory methods.</p>
</div>
<div class="paragraph">
<p>This advice throws a runtime exception at certain join points, but
AspectJ can do better. Using the <code>declare error</code> form, we can have the
<em>compiler</em> signal the error.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect RegistrationProtection {

  pointcut register(): call(<span class="type">void</span> <span class="predefined-type">Registry</span>.register(FigureElement));
  pointcut canRegister(): withincode(<span class="directive">static</span> * FigureElement.make*(..));

  declare error: register() &amp;&amp; !canRegister(): <span class="string"><span class="delimiter">&quot;</span><span class="content">Illegal call</span><span class="delimiter">&quot;</span></span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When using this aspect, it is impossible for the compiler to compile
programs with these illegal calls. This early detection is not always
possible. In this case, since we depend only on static information (the
<code>withincode</code> pointcut picks out join points totally based on their code,
and the <code>call</code> pointcut here picks out join points statically). Other
enforcement, such as the precondition enforcement, above, does require
dynamic information such as the runtime value of parameters.</p>
</div>
</div>
<div class="sect3">
<h4 id="_configuration_management">Configuration Management</h4>
<div class="paragraph">
<p>Configuration management for aspects can be handled using a variety of
make-file like techniques. To work with optional aspects, the programmer
can simply define their make files to either include the aspect in the
call to the AspectJ compiler or not, as desired.</p>
</div>
<div class="paragraph">
<p>Developers who want to be certain that no aspects are included in the
production build can do so by configuring their make files so that they
use a traditional Java compiler for production builds. To make it easy
to write such make files, the AspectJ compiler has a command-line
interface that is consistent with ordinary Java compilers.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="starting-production">Production Aspects</h3>
<div class="paragraph">
<p>This section presents examples of aspects that are inherently intended
to be included in the production builds of an application. Production
aspects tend to add functionality to an application rather than merely
adding more visibility of the internals of a program. Again, we begin
with name-based aspects and follow with property-based aspects.
Name-based production aspects tend to affect only a small number of
methods. For this reason, they are a good next step for projects
adopting AspectJ. But even though they tend to be small and simple, they
can often have a significant effect in terms of making the program
easier to understand and maintain.</p>
</div>
<div class="sect3">
<h4 id="_change_monitoring">Change Monitoring</h4>
<div class="paragraph">
<p>The first example production aspect shows how one might implement some
simple functionality where it is problematic to try and do it
explicitly. It supports the code that refreshes the display. The role of
the aspect is to maintain a dirty bit indicating whether or not an
object has moved since the last time the display was refreshed.</p>
</div>
<div class="paragraph">
<p>Implementing this functionality as an aspect is straightforward. The
<code>testAndClear</code> method is called by the display code to find out whether
a figure element has moved recently. This method returns the current
state of the dirty flag and resets it to false. The pointcut <code>move</code>
captures all the method calls that can move a figure element. The after
advice on <code>move</code> sets the dirty flag whenever an object moves.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect MoveTracking {
  <span class="directive">private</span> <span class="directive">static</span> <span class="type">boolean</span> dirty = <span class="predefined-constant">false</span>;

  <span class="directive">public</span> <span class="directive">static</span> <span class="type">boolean</span> testAndClear() {
    <span class="type">boolean</span> result = dirty;
    dirty = <span class="predefined-constant">false</span>;
    <span class="keyword">return</span> result;
  }

  pointcut move():
    call(<span class="type">void</span> FigureElement.setXY(<span class="type">int</span>, <span class="type">int</span>)) ||
    call(<span class="type">void</span> <span class="predefined-type">Line</span>.setP1(<span class="predefined-type">Point</span>))             ||
    call(<span class="type">void</span> <span class="predefined-type">Line</span>.setP2(<span class="predefined-type">Point</span>))             ||
    call(<span class="type">void</span> <span class="predefined-type">Point</span>.setX(<span class="type">int</span>))               ||
    call(<span class="type">void</span> <span class="predefined-type">Point</span>.setY(<span class="type">int</span>));

  after() returning: move() {
    dirty = <span class="predefined-constant">true</span>;
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Even this simple example serves to illustrate some of the important
benefits of using AspectJ in production code. Consider implementing this
functionality with ordinary Java: there would likely be a helper class
that contained the <code>dirty</code> flag, the <code>testAndClear</code> method, as well as a
<code>setFlag</code> method. Each of the methods that could move a figure element
would include a call to the <code>setFlag</code> method. Those calls, or rather the
concept that those calls should happen at each move operation, are the
crosscutting concern in this case.</p>
</div>
<div class="paragraph">
<p>The AspectJ implementation has several advantages over the standard
implementation:</p>
</div>
<div class="paragraph">
<p><em>The structure of the crosscutting concern is captured explicitly.</em> The
moves pointcut clearly states all the methods involved, so the
programmer reading the code sees not just individual calls to <code>setFlag</code>,
but instead sees the real structure of the code. The IDE support
included with AspectJ automatically reminds the programmer that this
aspect advises each of the methods involved. The IDE support also
provides commands to jump to the advice from the method and vice-versa.</p>
</div>
<div class="paragraph">
<p><em>Evolution is easier.</em> If, for example, the aspect needs to be revised
to record not just that some figure element moved, but rather to record
exactly which figure elements moved, the change would be entirely local
to the aspect. The pointcut would be updated to expose the object being
moved, and the advice would be updated to record that object. The paper
An Overview of AspectJ (available linked off of the AspectJ web site&#8201;&#8212;&#8201;<a href="https://eclipse.org/aspectj" class="bare">https://eclipse.org/aspectj</a>), presented at ECOOP 2001, presents a
detailed discussion of various ways this aspect could be expected to
evolve.</p>
</div>
<div class="paragraph">
<p><em>The functionality is easy to plug in and out.</em> Just as with development
aspects, production aspects may need to be removed from the system,
either because the functionality is no longer needed at all, or because
it is not needed in certain configurations of a system. Because the
functionality is modularized in a single aspect this is easy to do.</p>
</div>
<div class="paragraph">
<p><em>The implementation is more stable.</em> If, for example, the programmer
adds a subclass of <code>Line</code> that overrides the existing methods, this
advice in this aspect will still apply. In the ordinary Java
implementation the programmer would have to remember to add the call to
<code>setFlag</code> in the new overriding method. This benefit is often even more
compelling for property-based aspects (see the section
<a href="#starting-production-consistentBehavior">Providing Consistent
Behavior</a>).</p>
</div>
</div>
<div class="sect3">
<h4 id="_context_passing">Context Passing</h4>
<div class="paragraph">
<p>The crosscutting structure of context passing can be a significant
source of complexity in Java programs. Consider implementing
functionality that would allow a client of the figure editor (a program
client rather than a human) to set the color of any figure elements that
are created. Typically this requires passing a color, or a color
factory, from the client, down through the calls that lead to the figure
element factory. All programmers are familiar with the inconvenience of
adding a first argument to a number of methods just to pass this kind of
context information.</p>
</div>
<div class="paragraph">
<p>Using AspectJ, this kind of context passing can be implemented in a
modular way. The following code adds after advice that runs only when
the factory methods of <code>Figure</code> are called in the control flow of a
method on a <code>ColorControllingClient</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect ColorControl {
  pointcut CCClientCflow(ColorControllingClient client):
    cflow(call(* * (..)) &amp;&amp; target(client));

  pointcut make(): call(FigureElement Figure.make*(..));

  after (ColorControllingClient c) returning (FigureElement fe):
    make() &amp;&amp; CCClientCflow(c)
  {
    fe.setColor(c.colorFor(fe));
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This aspect affects only a small number of methods, but note that the
non-AOP implementation of this functionality might require editing many
more methods, specifically, all the methods in the control flow from the
client to the factory. This is a benefit common to many property-based
aspects while the aspect is short and affects only a modest number of
benefits, the complexity the aspect saves is potentially much larger.</p>
</div>
</div>
<div class="sect3">
<h4 id="starting-production-consistentBehavior">Providing Consistent Behavior</h4>
<div class="paragraph">
<p>This example shows how a property-based aspect can be used to provide
consistent handling of functionality across a large set of operations.
This aspect ensures that all public methods of the <code>com.bigboxco</code>
package log any Errors they throw to their caller (in Java, an Error is
like an Exception, but it indicates that something really bad and
usually unrecoverable has happened). The <code>publicMethodCall</code> pointcut
captures the public method calls of the package, and the after advice
runs whenever one of those calls throws an Error. The advice logs that
Error and then the throw resumes.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect PublicErrorLogging {
  Log log = <span class="keyword">new</span> Log();

  pointcut publicMethodCall():
    call(<span class="directive">public</span> * com.bigboxco.*.*(..));

  after() throwing (<span class="exception">Error</span> e): publicMethodCall() {
    log.write(e);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In some cases this aspect can log an exception twice. This happens if
code inside the <code>com.bigboxco</code> package itself calls a public method of
the package. In that case this code will log the error at both the
outermost call into the <code>com.bigboxco</code> package and the re-entrant call.
The <code>cflow</code> primitive pointcut can be used in a nice way to exclude
these re-entrant calls:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">after() throwing (<span class="exception">Error</span> e):
  publicMethodCall() &amp;&amp; !cflow(publicMethodCall())
{
  log.write(e);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following aspect is taken from work on the AspectJ compiler. The
aspect advises about 35 methods in the <code>JavaParser</code> class. The
individual methods handle each of the different kinds of elements that
must be parsed. They have names like <code>parseMethodDec</code>, <code>parseThrows</code>,
and <code>parseExpr</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect ContextFilling {
  pointcut parse(JavaParser jp):
    call(* JavaParser.parse*(..))
    &amp;&amp; target(jp)
    &amp;&amp; !call(Stmt parseVarDec(<span class="type">boolean</span>)); <span class="comment">// var decs  are tricky</span>

  around(JavaParser jp) returns ASTObject: parse(jp) {
    Token beginToken = jp.peekToken();
    ASTObject ret = proceed(jp);
    <span class="keyword">if</span> (ret != <span class="predefined-constant">null</span>) jp.addContext(ret, beginToken);
      <span class="keyword">return</span> ret;
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This example exhibits a property found in many aspects with large
property-based pointcuts. In addition to a general property based
pattern <code>call(* JavaParser.parse*(..))</code> it includes an exception to the
pattern <code>!call(Stmt parseVarDec(boolean))</code>. The exclusion of <code>parseVarDec</code> happens
because the parsing of variable declarations in Java is too complex to
fit with the clean pattern of the other <code>parse*</code> methods. Even with the
explicit exclusion this aspect is a clear expression of a clean
crosscutting modularity. Namely that all <code>parse*</code> methods that return
<code>ASTObjects</code>, except for <code>parseVarDec</code> share a common behavior for
establishing the parse context of their result.</p>
</div>
<div class="paragraph">
<p>The process of writing an aspect with a large property-based pointcut,
and of developing the appropriate exceptions can clarify the structure
of the system. This is especially true, as in this case, when
refactoring existing code to use aspects. When we first looked at the
code for this aspect, we were able to use the IDE support provided in
AJDE for JBuilder to see what methods the aspect was advising compared
to our manual coding. We quickly discovered that there were a dozen
places where the aspect advice was in effect but we had not manually
inserted the required functionality. Two of these were bugs in our prior
non-AOP implementation of the parser. The other ten were needless
performance optimizations. So, here, refactoring the code to express the
crosscutting structure of the aspect explicitly made the code more
concise and eliminated latent bugs.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="starting-conclusion">Conclusion</h3>
<div class="paragraph">
<p>AspectJ is a simple and practical aspect-oriented extension to Java.
With just a few new constructs, AspectJ provides support for modular
implementation of a range of crosscutting concerns.</p>
</div>
<div class="paragraph">
<p>Adoption of AspectJ into an existing Java development project can be a
straightforward and incremental task. One path is to begin by using only
development aspects, going on to using production aspects and then
reusable aspects after building up experience with AspectJ. Adoption can
follow other paths as well. For example, some developers will benefit
from using production aspects right away. Others may be able to write
clean reusable aspects almost right away.</p>
</div>
<div class="paragraph">
<p>AspectJ enables both name-based and property based crosscutting. Aspects
that use name-based crosscutting tend to affect a small number of other
classes. But despite their small scale, they can often eliminate
significant complexity compared to an ordinary Java implementation.
Aspects that use property-based crosscutting can have small or large
scale.</p>
</div>
<div class="paragraph">
<p>Using AspectJ results in clean well-modularized implementations of
crosscutting concerns. When written as an AspectJ aspect the structure
of a crosscutting concern is explicit and easy to understand. Aspects
are also highly modular, making it possible to develop plug-and-play
implementations of crosscutting functionality.</p>
</div>
<div class="paragraph">
<p>AspectJ provides more functionality than was covered by this short
introduction. The next chapter, <a href="#language">The AspectJ Language</a>, covers in detail
more of the features of the AspectJ language. The following chapter,
<a href="#examples">Examples</a>, then presents some carefully chosen examples that
show you how AspectJ might be used. We recommend that you read the next
two chapters carefully before deciding to adopt AspectJ into a project.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="language">The AspectJ Language</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="language-intro">Introduction</h3>
<div class="paragraph">
<p>The previous chapter, <a href="#starting">Getting Started with AspectJ</a>, was a brief overview of the
AspectJ language. You should read this chapter to understand AspectJ&#8217;s
syntax and semantics. It covers the same material as the previous
chapter, but more completely and in much more detail.</p>
</div>
<div class="paragraph">
<p>We will start out by looking at an example aspect that we&#8217;ll build out
of a pointcut, an introduction, and two pieces of advice. This example
aspect will gives us something concrete to talk about.</p>
</div>
</div>
<div class="sect2">
<h3 id="language-anatomy">The Anatomy of an Aspect</h3>
<div class="paragraph">
<p>This lesson explains the parts of AspectJ&#8217;s aspects. By reading this
lesson you will have an overview of what&#8217;s in an aspect and you will be
exposed to the new terminology introduced by AspectJ.</p>
</div>
<div class="sect3">
<h4 id="_an_example_aspect">An Example Aspect</h4>
<div class="paragraph">
<p>Here&#8217;s an example of an aspect definition in AspectJ:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">/*01*/</span> aspect FaultHandler {
<span class="comment">/*02*/</span>
<span class="comment">/*03*/</span>   <span class="directive">private</span> <span class="type">boolean</span> Server.disabled = <span class="predefined-constant">false</span>;
<span class="comment">/*04*/</span>
<span class="comment">/*05*/</span>   <span class="directive">private</span> <span class="type">void</span> reportFault() {
<span class="comment">/*06*/</span>     <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Failure! Please fix it.</span><span class="delimiter">&quot;</span></span>);
<span class="comment">/*07*/</span>   }
<span class="comment">/*08*/</span>
<span class="comment">/*09*/</span>   <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> fixServer(Server s) {
<span class="comment">/*10*/</span>     s.disabled = <span class="predefined-constant">false</span>;
<span class="comment">/*11*/</span>   }
<span class="comment">/*12*/</span>
<span class="comment">/*13*/</span>   pointcut services(Server s): target(s) &amp;&amp; call(<span class="directive">public</span> * *(..));
<span class="comment">/*14*/</span>
<span class="comment">/*15*/</span>   before(Server s): services(s) {
<span class="comment">/*16*/</span>     <span class="keyword">if</span> (s.disabled) <span class="keyword">throw</span> <span class="keyword">new</span> DisabledException();
<span class="comment">/*17*/</span>   }
<span class="comment">/*18*/</span>
<span class="comment">/*19*/</span>   after(Server s) throwing (FaultException e): services(s) {
<span class="comment">/*20*/</span>     s.disabled = <span class="predefined-constant">true</span>;
<span class="comment">/*21*/</span>     reportFault();
<span class="comment">/*22*/</span>   }
<span class="comment">/*23*/</span> }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>FaultHandler</code> consists of one inter-type field on <code>Server</code> (line
03), two methods (lines 05-07 and 09-11), one pointcut definition (line
13), and two pieces of advice (lines 15-17 and 19-22).</p>
</div>
<div class="paragraph">
<p>This covers the basics of what aspects can contain. In general, aspects
consist of an association of other program entities, ordinary variables
and methods, pointcut definitions, inter-type declarations, and advice,
where advice may be before, after or around advice. The remainder of
this lesson focuses on those crosscut-related constructs.</p>
</div>
</div>
<div class="sect3">
<h4 id="_pointcuts">Pointcuts</h4>
<div class="paragraph">
<p>AspectJ&#8217;s pointcut definitions give names to pointcuts. Pointcuts
themselves pick out join points, i.e. interesting points in the
execution of a program. These join points can be method or constructor
invocations and executions, the handling of exceptions, field
assignments and accesses, etc. Take, for example, the pointcut
definition in line 13:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">pointcut services(Server s): target(s) &amp;&amp; call(<span class="directive">public</span> * *(..))</code></pre>
</div>
</div>
<div class="paragraph">
<p>This pointcut, named <code>services</code>, picks out those points in the execution
of the program when <code>Server</code> objects have their public methods called.
It also allows anyone using the <code>services</code> pointcut to access the
<code>Server</code> object whose method is being called.</p>
</div>
<div class="paragraph">
<p>The idea behind this pointcut in the <code>FaultHandler</code> aspect is that
fault-handling-related behavior must be triggered on the calls to public
methods. For example, the server may be unable to proceed with the
request because of some fault. The calls of those methods are,
therefore, interesting events for this aspect, in the sense that certain
fault-related things will happen when these events occur.</p>
</div>
<div class="paragraph">
<p>Part of the context in which the events occur is exposed by the formal
parameters of the pointcut. In this case, that consists of objects of
type <code>Server</code>. That formal parameter is then being used on the right
hand side of the declaration in order to identify which events the
pointcut refers to. In this case, a pointcut picking out join points
where a Server is the target of some operation (target(s)) is being
composed (<code>&amp;&amp;</code>, meaning and) with a pointcut picking out call join
points (<code>call(..)</code>). The calls are identified by signatures that can
include wild cards. In this case, there are wild cards in the return
type position (first <code>*</code>), in the name position (second <code>*</code>) and in the
argument list position <code>(..)</code>; the only concrete information is given by
the qualifier <code>public</code>.</p>
</div>
<div class="paragraph">
<p>Pointcuts pick out arbitrarily large numbers of join points of a
program. But they pick out only a small number of <em>kinds</em> of join
points. Those kinds of join points correspond to some of the most
important concepts in Java. Here is an incomplete list: method call,
method execution, exception handling, instantiation, constructor
execution, and field access. Each kind of join point can be picked out
by its own specialized pointcut that you will learn about in other parts
of this guide.</p>
</div>
</div>
<div class="sect3">
<h4 id="_advice">Advice</h4>
<div class="paragraph">
<p>A piece of advice brings together a pointcut and a body of code to
define aspect implementation that runs at join points picked out by the
pointcut. For example, the advice in lines 15-17 specifies that the
following piece of code</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">{
  <span class="keyword">if</span> (s.disabled) <span class="keyword">throw</span> <span class="keyword">new</span> DisabledException();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>is executed when instances of the <code>Server</code> class have their public
methods called, as specified by the pointcut <code>services</code>. More
specifically, it runs when those calls are made, just before the
corresponding methods are executed.</p>
</div>
<div class="paragraph">
<p>The advice in lines 19-22 defines another piece of implementation that
is executed on the same pointcut:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">{
  s.disabled = <span class="predefined-constant">true</span>;
  reportFault();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>But this second method executes after those operations throw exception
of type <code>FaultException</code>.</p>
</div>
<div class="paragraph">
<p>There are two other variations of after advice: upon successful return
and upon return, either successful or with an exception. There is also a
third kind of advice called around. You will see those in other parts of
this guide.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="language-joinPoints">Join Points and Pointcuts</h3>
<div class="paragraph">
<p>Consider the following Java class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">Point</span> {
  <span class="directive">private</span> <span class="type">int</span> x, y;

  <span class="predefined-type">Point</span>(<span class="type">int</span> x, <span class="type">int</span> y) { <span class="local-variable">this</span>.x = x; <span class="local-variable">this</span>.y = y; }

  <span class="type">void</span> setX(<span class="type">int</span> x) { <span class="local-variable">this</span>.x = x; }
  <span class="type">void</span> setY(<span class="type">int</span> y) { <span class="local-variable">this</span>.y = y; }

  <span class="type">int</span> getX() { <span class="keyword">return</span> x; }
  <span class="type">int</span> getY() { <span class="keyword">return</span> y; }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In order to get an intuitive understanding of AspectJ&#8217;s join points and
pointcuts, let&#8217;s go back to some of the basic principles of Java.
Consider the following a method declaration in class Point:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">void</span> setX(<span class="type">int</span> x) { <span class="local-variable">this</span>.x = x; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This piece of program says that when method named <code>setX</code> with an <code>int</code>
argument called on an object of type <code>Point</code>, then the method body
<code>{ this.x = x; }</code> is executed. Similarly, the constructor of the class
states that when an object of type <code>Point</code> is instantiated through a
constructor with two <code>int</code> arguments, then the constructor body
<code>{ this.x = x; this.y = y; }</code> is executed.</p>
</div>
<div class="paragraph">
<p>One pattern that emerges from these descriptions is</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>When something happens, then something gets executed.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>In object-oriented programs, there are several kinds of "things that
happen" that are determined by the language. We call these the join
points of Java. Join points consist of things like method calls, method
executions, object instantiations, constructor executions, field
references and handler executions. (See the <a href="#quick">AspectJ Quick Reference</a> for a
complete listing.)</p>
</div>
<div class="paragraph">
<p>Pointcuts pick out these join points. For example, the pointcut</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">pointcut setter():
  target(<span class="predefined-type">Point</span>) &amp;&amp;
  (call(<span class="type">void</span> setX(<span class="type">int</span>)) || call(<span class="type">void</span> setY(<span class="type">int</span>)));</code></pre>
</div>
</div>
<div class="paragraph">
<p>picks out each call to <code>setX(int)</code> or <code>setY(int)</code> when called on an
instance of <code>Point</code>. Here&#8217;s another example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">pointcut ioHandler(): within(MyClass) &amp;&amp; handler(<span class="exception">IOException</span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>This pointcut picks out each the join point when exceptions of type
<code>IOException</code> are handled inside the code defined by class <code>MyClass</code>.</p>
</div>
<div class="paragraph">
<p>Pointcut definitions consist of a left-hand side and a right-hand side,
separated by a colon. The left-hand side consists of the pointcut name
and the pointcut parameters (i.e. the data available when the events
happen). The right-hand side consists of the pointcut itself.</p>
</div>
<div class="sect3">
<h4 id="_some_example_pointcuts">Some Example Pointcuts</h4>
<div class="paragraph">
<p>Here are examples of pointcuts picking out</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">when a particular method body executes</dt>
<dd>
<p><code>execution(void Point.setX(int))</code></p>
</dd>
<dt class="hdlist1">when a method is called</dt>
<dd>
<p><code>call(void Point.setX(int))</code></p>
</dd>
<dt class="hdlist1">when an exception handler executes</dt>
<dd>
<p>  <code>handler(ArrayOutOfBoundsException)</code>
when the object currently executing (i.e. <code>this</code>) is of type</p>
</dd>
<dt class="hdlist1"><code>SomeType</code></dt>
<dd>
<p><code>this(SomeType)</code></p>
</dd>
<dt class="hdlist1">when the target object is of type <code>SomeType</code></dt>
<dd>
<p><code>target(SomeType)</code></p>
</dd>
<dt class="hdlist1">when the executing code belongs to class <code>MyClass</code></dt>
<dd>
<p>  <code>within(MyClass)</code>
when the join point is in the control flow of a call to a <code>Test</code>'s</p>
</dd>
<dt class="hdlist1">no-argument <code>main</code> method</dt>
<dd>
<p><code>cflow(call(void Test.main()))</code></p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Pointcuts compose through the operations <code>OR</code> (<code>||</code>), <code>ANT</code> (<code>&amp;&amp;</code>)
and <code>NOT</code> (<code>!</code>).</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It is possible to use wildcards. So</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>execution(* *(..))</code></p>
</li>
<li>
<p><code>call(* set(..))</code></p>
<div class="paragraph">
<p>means (1) the execution of any method regardless of return or parameter
types, and (2) the call to any method named <code>set</code> regardless of return
or parameter types&#8201;&#8212;&#8201;in case of overloading there may be more than one
such <code>set</code> method; this pointcut picks out calls to all of them.</p>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>You can select elements based on types. For example,</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>execution(int *())</code></p>
</li>
<li>
<p><code>call(* setY(long))</code></p>
</li>
<li>
<p><code>call(* Point.setY(int))</code></p>
</li>
<li>
<p><code>call(*.new(int, int))</code></p>
<div class="paragraph">
<p>means (1) the execution of any method with no parameters that returns an
<code>int</code>, (2) the call to any <code>setY</code> method that takes a <code>long</code> as an
argument, regardless of return type or declaring type, (3) the call to
any of <code>Point</code>'s <code>setY</code> methods that take an <code>int</code> as an argument,
regardless of return type, and (4) the call to any classes' constructor,
so long as it takes exactly two <code>int</code>s as arguments.</p>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>You can compose pointcuts. For example,</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>target(Point) &amp;&amp; call(int *())</code></p>
</li>
<li>
<p><code>call(* *(..)) &amp;&amp; (within(Line) || within(Point))</code></p>
</li>
<li>
<p><code>within(<strong>) &amp;&amp; execution(</strong>.new(int))</code></p>
</li>
<li>
<p><code>!this(Point) &amp;&amp; call(int *(..))</code></p>
<div class="paragraph">
<p>means (1) any call to an <code>int</code> method with no arguments on an instance
of <code>Point</code>, regardless of its name, (2) any call to any method where the
call is made from the code in <code>Point</code>'s or <code>Line</code>'s type declaration,
(3) the execution of any constructor taking exactly one <code>int</code> argument,
regardless of where the call is made from, and (4) any method call to an
<code>int</code> method when the executing object is any type except <code>Point</code>.</p>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>You can select methods and constructors based on their modifiers and
on negations of modifiers. For example, you can say:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>call(public * *(..))</code></p>
</li>
<li>
<p><code>execution(!static * *(..))</code></p>
</li>
<li>
<p><code>execution(public !static * *(..))</code></p>
<div class="paragraph">
<p>which means (1) any call to a public method, (2) any execution of a
non-static method, and (3) any execution of a public, non-static method.</p>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>Pointcuts can also deal with interfaces. For example, given the
interface</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">interface</span> <span class="class">MyInterface</span> { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>the pointcut <code>call(* MyInterface.*(..))</code> picks out any call to a method
in <code>MyInterface</code>'s signature&#8201;&#8212;&#8201;that is, any method defined by
<code>MyInterface</code> or inherited by one of its a supertypes.</p>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="call-vs-execution">call vs. execution</h4>
<div class="paragraph">
<p>When methods and constructors run, there are two interesting times
associated with them. That is when they are called, and when they
actually execute.</p>
</div>
<div class="paragraph">
<p>AspectJ exposes these times as call and execution join points,
respectively, and allows them to be picked out specifically by <code>call</code>
and <code>execution</code> pointcuts.</p>
</div>
<div class="paragraph">
<p>So what&#8217;s the difference between these join points? Well, there are a
number of differences:</p>
</div>
<div class="paragraph">
<p>Firstly, the lexical pointcut declarations <code>within</code> and <code>withincode</code>
match differently. At a call join point, the enclosing code is that of
the call site. This means that <code>call(void m()) &amp;&amp; withincode(void m())</code>
will only capture directly recursive
calls, for example. At an execution join point, however, the program is
already executing the method, so the enclosing code is the method
itself: <code>execution(void m()) &amp;&amp; withincode(void m())</code> is the same as
<code>execution(void m())</code>.</p>
</div>
<div class="paragraph">
<p>Secondly, the call join point does not capture super calls to non-static
methods. This is because such super calls are different in Java, since
they don&#8217;t behave via dynamic dispatch like other calls to non-static
methods.</p>
</div>
<div class="paragraph">
<p>The rule of thumb is that if you want to pick a join point that runs
when an actual piece of code runs (as is often the case for tracing),
use <code>execution</code>, but if you want to pick one that runs when a particular
<em>signature</em> is called (as is often the case for production aspects), use
<code>call</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_pointcut_composition">Pointcut composition</h4>
<div class="paragraph">
<p>Pointcuts are put together with the operators and (spelled <code>&amp;&amp;</code>), or
(spelled <code>||</code>), and not (spelled <code>!</code>). This allows the creation of very
powerful pointcuts from the simple building blocks of primitive
pointcuts. This composition can be somewhat confusing when used with
primitive pointcuts like <code>cflow</code> and <code>cflowbelow</code>. Here&#8217;s an example:</p>
</div>
<div class="paragraph">
<p><code>cflow(P)</code> picks out each join point in the control flow of the join
points picked out by <code>P</code>. So, pictorially:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">P ---------------------
  \
   \  cflow of P
    \</code></pre>
</div>
</div>
<div class="paragraph">
<p>What does <code>cflow(P) &amp;&amp; cflow(Q)</code> pick out? Well, it picks out each join point that is
in both the control flow of <code>P</code> and in the control flow of <code>Q</code>. So&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">        P ---------------------
          \
           \  cflow of P
            \
             \
              \
Q -------------\-------
  \             \
   \  cflow of Q \ cflow(P) &amp;&amp; cflow(Q)
    \             \</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that <code>P</code> and <code>Q</code> might not have any join points in common&#8230;&#8203; but
their control flows might have join points in common.</p>
</div>
<div class="paragraph">
<p>But what does <code>cflow(P &amp;&amp; Q)</code> mean? Well, it means the control flow of those join
points that are both picked out by <code>P</code> and picked out by <code>Q</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">P &amp;&amp; Q -------------------
       \
        \ cflow of (P &amp;&amp; Q)
         \</code></pre>
</div>
</div>
<div class="paragraph">
<p>and if there are <em>no</em> join points that are both picked by <code>P</code> and picked
out by <code>Q</code>, then there&#8217;s no chance that there are any join points in the
control flow of <code>(P &amp;&amp; Q)</code>.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s some code that expresses this.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Test</span> {
  <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
    foo();
  }
  <span class="directive">static</span> <span class="type">void</span> foo() {
    goo();
  }
  <span class="directive">static</span> <span class="type">void</span> goo() {
    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">hi</span><span class="delimiter">&quot;</span></span>);
  }
}

aspect A  {
  pointcut fooPC(): execution(<span class="type">void</span> Test.foo());
  pointcut gooPC(): execution(<span class="type">void</span> Test.goo());
  pointcut printPC(): call(<span class="type">void</span> java.io.PrintStream.println(<span class="predefined-type">String</span>));

  before(): cflow(fooPC()) &amp;&amp; cflow(gooPC()) &amp;&amp; printPC() &amp;&amp; !within(A) {
    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">should occur</span><span class="delimiter">&quot;</span></span>);
  }

  before(): cflow(fooPC() &amp;&amp; gooPC()) &amp;&amp; printPC() &amp;&amp; !within(A) {
    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">should not occur</span><span class="delimiter">&quot;</span></span>);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>!within(A)</code> pointcut above is required to avoid the <code>printPC</code>
pointcut applying to the <code>System.out.println</code> call in the advice body.
If this was not present a recursive call would result as the pointcut
would apply to its own advice. (See <a href="#pitfalls-infiniteLoops">Infinite loops</a>
for more details.)</p>
</div>
</div>
<div class="sect3">
<h4 id="_pointcut_parameters">Pointcut Parameters</h4>
<div class="paragraph">
<p>Consider again the first pointcut definition in this chapter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">pointcut setter():
  target(<span class="predefined-type">Point</span>) &amp;&amp;
  (call(<span class="type">void</span> setX(<span class="type">int</span>)) || call(<span class="type">void</span> setY(<span class="type">int</span>)));</code></pre>
</div>
</div>
<div class="paragraph">
<p>As we&#8217;ve seen, this pointcut picks out each call to <code>setX(int)</code> or
<code>setY(int)</code> methods where the target is an instance of <code>Point</code>. The
pointcut is given the name <code>setter</code> and no parameters on the left-hand
side. An empty parameter list means that none of the context from the
join points is published from this pointcut. But consider another
version of version of this pointcut definition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">pointcut setter(<span class="predefined-type">Point</span> p):
  target(p) &amp;&amp;
  (call(<span class="type">void</span> setX(<span class="type">int</span>)) || call(<span class="type">void</span> setY(<span class="type">int</span>)));</code></pre>
</div>
</div>
<div class="paragraph">
<p>This version picks out exactly the same join points. But in this
version, the pointcut has one parameter of type <code>Point</code>. This means that
any advice that uses this pointcut has access to a <code>Point</code> from each
join point picked out by the pointcut. Inside the pointcut definition
this <code>Point</code> is named <code>p</code> is available, and according to the right-hand
side of the definition, that <code>Point p</code> comes from the <code>target</code> of each
matched join point.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s another example that illustrates the flexible mechanism for
defining pointcut parameters:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">pointcut testEquality(<span class="predefined-type">Point</span> p):
  target(<span class="predefined-type">Point</span>) &amp;&amp;
  args(p) &amp;&amp;
  call(<span class="type">boolean</span> equals(<span class="predefined-type">Object</span>));</code></pre>
</div>
</div>
<div class="paragraph">
<p>This pointcut also has a parameter of type <code>Point</code>. Similar to the
<code>setter</code> pointcut, this means that anyone using this pointcut has
access to a <code>Point</code> from each join point. But in this case, looking at
the right-hand side we find that the object named in the parameters is
not the target <code>Point</code> object that receives the call; it&#8217;s the argument
(also of type <code>Point</code>) passed to the <code>equals</code> method when some other
<code>Point</code> is the target. If we wanted access to both <code>Point</code>s, then the
pointcut definition that would expose target <code>Point p1</code> and argument
<code>Point p2</code> would be</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">pointcut testEquality(<span class="predefined-type">Point</span> p1, <span class="predefined-type">Point</span> p2):
  target(p1) &amp;&amp;
  args(p2) &amp;&amp;
  call(<span class="type">boolean</span> equals(<span class="predefined-type">Object</span>));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s look at another variation of the <code>setter</code> pointcut:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">pointcut setter(<span class="predefined-type">Point</span> p, <span class="type">int</span> newval):
  target(p) &amp;&amp;
  args(newval) &amp;&amp;
  (call(<span class="type">void</span> setX(<span class="type">int</span>)) || call(<span class="type">void</span> setY(<span class="type">int</span>)));</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case, a <code>Point</code> object and an <code>int</code> value are exposed by the
named pointcut. Looking at the the right-hand side of the definition, we
find that the <code>Point</code> object is the target object, and the <code>int</code> value
is the called method&#8217;s argument.</p>
</div>
<div class="paragraph">
<p>The use of pointcut parameters is relatively flexible. The most
important rule is that all the pointcut parameters must be bound at
every join point picked out by the pointcut. So, for example, the
following pointcut definition will result in a compilation error:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">pointcut badPointcut(<span class="predefined-type">Point</span> p1, <span class="predefined-type">Point</span> p2):
  (target(p1) &amp;&amp; call(<span class="type">void</span> setX(<span class="type">int</span>))) ||
  (target(p2) &amp;&amp; call(<span class="type">void</span> setY(<span class="type">int</span>)));</code></pre>
</div>
</div>
<div class="paragraph">
<p>because <code>p1</code> is only bound when calling <code>setX</code>, and <code>p2</code> is only bound
when calling <code>setY</code>, but the pointcut picks out all of these join points
and tries to bind both <code>p1</code> and <code>p2</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="example">Example: <code>HandleLiveness</code></h4>
<div class="paragraph">
<p>The example below consists of two object classes (plus an exception
class) and one aspect. Handle objects delegate their public, non-static
operations to their <code>Partner</code> objects. The aspect <code>HandleLiveness</code>
ensures that, before the delegations, the partner exists and is alive,
or else it throws an exception.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">Handle</span> {
  Partner partner = <span class="keyword">new</span> Partner();

  <span class="directive">public</span> <span class="type">void</span> foo() { partner.foo(); }
  <span class="directive">public</span> <span class="type">void</span> bar(<span class="type">int</span> x) { partner.bar(x); }

  <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
    Handle h1 = <span class="keyword">new</span> Handle();
    h1.foo();
    h1.bar(<span class="integer">2</span>);
  }
}

<span class="type">class</span> <span class="class">Partner</span> {
  <span class="type">boolean</span> isAlive() { <span class="keyword">return</span> <span class="predefined-constant">true</span>; }
  <span class="type">void</span> foo() { <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">foo</span><span class="delimiter">&quot;</span></span>); }
  <span class="type">void</span> bar(<span class="type">int</span> x) { <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">bar </span><span class="delimiter">&quot;</span></span> + x); }
}

aspect HandleLiveness {
  before(Handle handle): target(handle) &amp;&amp; call(<span class="directive">public</span> * *(..)) {
    <span class="keyword">if</span> ( handle.partner == <span class="predefined-constant">null</span>  || !handle.partner.isAlive() ) {
      <span class="keyword">throw</span> <span class="keyword">new</span> DeadPartnerException();
    }
  }
}

<span class="type">class</span> <span class="class">DeadPartnerException</span> <span class="directive">extends</span> <span class="exception">RuntimeException</span> {}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pointcut-best-practice">Writing good pointcuts</h4>
<div class="paragraph">
<p>During compilation, AspectJ processes pointcuts in order to try and
optimize matching performance. Examining code and determining if each
join point matches (statically or dynamically) a given pointcut is a
costly process. (A dynamic match means the match cannot be fully
determined from static analysis and a test will be placed in the code to
determine if there is an actual match when the code is running). On
first encountering a pointcut declaration, AspectJ will rewrite it into
an optimal form for the matching process. What does this mean? Basically
pointcuts are rewritten in DNF (Disjunctive Normal Form) and the
components of the pointcut are sorted such that those components that
are cheaper to evaluate are checked first. This means users do not have
to worry about understanding the performance of various pointcut
designators and may supply them in any order in their pointcut
declarations.</p>
</div>
<div class="paragraph">
<p>However, AspectJ can only work with what it is told, and for optimal
performance of matching the user should think about what they are trying
to achieve and narrow the search space for matches as much as they can
in the definition. Basically there are three kinds of pointcut
designator: kinded, scoping and context:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Kinded designators are those which select a particular kind of join
point. For example: <code>execution, get, set, call, handler</code></p>
</li>
<li>
<p>Scoping designators are those which select a group of join points of
interest (of probably many kinds). For example: <code>within, withincode</code></p>
</li>
<li>
<p>Contextual designators are those that match (and optionally bind)
based on context. For example: <code>this, target, @annotation</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A well written pointcut should try and include at least the first two
types (kinded and scoping), whilst the contextual designators may be
included if wishing to match based on join point context, or bind that
context for use in the advice. Supplying either just a kinded designator
or just a contextual designator will work but could affect weaving
performance (time and memory used) due to all the extra processing and
analysis. Scoping designators are very fast to match, they can very
quickly dismiss groups of join points that should not be further
processed - that is why a good pointcut should always include one if
possible.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="language-advice">Advice</h3>
<div class="paragraph">
<p>Advice defines pieces of aspect implementation that execute at
well-defined points in the execution of the program. Those points can be
given either by named pointcuts (like the ones you&#8217;ve seen above) or by
anonymous pointcuts. Here is an example of an advice on a named
pointcut:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">pointcut setter(<span class="predefined-type">Point</span> p1, <span class="type">int</span> newval):
  target(p1) &amp;&amp; args(newval)
  (call(<span class="type">void</span> setX(<span class="type">int</span>) || call(<span class="type">void</span> setY(<span class="type">int</span>)));

before(<span class="predefined-type">Point</span> p1, <span class="type">int</span> newval): setter(p1, newval) {
  <span class="predefined-type">System</span>.out.println(
    <span class="string"><span class="delimiter">&quot;</span><span class="content">About to set something in </span><span class="delimiter">&quot;</span></span> + p1 +
    <span class="string"><span class="delimiter">&quot;</span><span class="content"> to the new value </span><span class="delimiter">&quot;</span></span> + newval
  );
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And here is exactly the same example, but using an anonymous pointcut:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">before(<span class="predefined-type">Point</span> p1, <span class="type">int</span> newval):
  target(p1) &amp;&amp; args(newval)
  (call(<span class="type">void</span> setX(<span class="type">int</span>)) || call(<span class="type">void</span> setY(<span class="type">int</span>)))
{
  <span class="predefined-type">System</span>.out.println(
    <span class="string"><span class="delimiter">&quot;</span><span class="content">About to set something in </span><span class="delimiter">&quot;</span></span> + p1 +
    <span class="string"><span class="delimiter">&quot;</span><span class="content"> to the new value </span><span class="delimiter">&quot;</span></span> + newval
  );
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here are examples of the different advice:</p>
</div>
<div class="paragraph">
<p>This before advice runs just before the join points picked out by the
(anonymous) pointcut:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">before(<span class="predefined-type">Point</span> p, <span class="type">int</span> x): target(p) &amp;&amp; args(x) &amp;&amp; call(<span class="type">void</span> setX(<span class="type">int</span>)) {
  <span class="keyword">if</span> (!p.assertX(x)) <span class="keyword">return</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This after advice runs just after each join point picked out by the
(anonymous) pointcut, regardless of whether it returns normally or
throws an exception:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">after(<span class="predefined-type">Point</span> p, <span class="type">int</span> x):
  target(p) &amp;&amp; args(x) &amp;&amp; call(<span class="type">void</span> setX(<span class="type">int</span>))
{
  <span class="keyword">if</span> (!p.assertX(x)) <span class="keyword">throw</span> <span class="keyword">new</span> PostConditionViolation();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This after returning advice runs just after each join point picked out
by the (anonymous) pointcut, but only if it returns normally. The return
value can be accessed, and is named <code>x</code> here. After the advice runs, the
return value is returned:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">after(<span class="predefined-type">Point</span> p) returning(<span class="type">int</span> x):
  target(p) &amp;&amp; call(<span class="type">int</span> getX())
{
  <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Returning int value </span><span class="delimiter">&quot;</span></span> + x + <span class="string"><span class="delimiter">&quot;</span><span class="content"> for p = </span><span class="delimiter">&quot;</span></span> + p);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This after throwing advice runs just after each join point picked out by
the (anonymous) pointcut, but only when it throws an exception of type
<code>Exception</code>. Here the exception value can be accessed with the name <code>e</code>.
The advice re-raises the exception after it&#8217;s done:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">after() throwing(<span class="exception">Exception</span> e):
  target(<span class="predefined-type">Point</span>) &amp;&amp; call(<span class="type">void</span> setX(<span class="type">int</span>))
{
    <span class="predefined-type">System</span>.out.println(e);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This around advice traps the execution of the join point; it runs
<em>instead</em> of the join point. The original action associated with the
join point can be invoked through the special <code>proceed</code> call:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">void</span> around(<span class="predefined-type">Point</span> p, <span class="type">int</span> x):
  target(p)
  &amp;&amp; args(x)
  &amp;&amp; call(<span class="type">void</span> setX(<span class="type">int</span>))
{
  <span class="keyword">if</span> (p.assertX(x)) proceed(p, x);
  p.releaseResources();
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="language-interType">Inter-type declarations</h3>
<div class="paragraph">
<p>Aspects can declare members (fields, methods, and constructors) that are
owned by other types. These are called inter-type members. Aspects can
also declare that other types implement new interfaces or extend a new
class. Here are examples of some such inter-type declarations:</p>
</div>
<div class="paragraph">
<p>This declares that each <code>Server</code> has a <code>boolean</code> field named <code>disabled</code>,
initialized to <code>false</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">private</span> <span class="type">boolean</span> Server.disabled = <span class="predefined-constant">false</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is declared <code>private</code>, which means that it is private <em>to the
aspect</em>: only code in the aspect can see the field. And even if <code>Server</code>
has another private field named <code>disabled</code> (declared in <code>Server</code> or in
another aspect) there won&#8217;t be a name collision, since no reference to
<code>disabled</code> will be ambiguous.</p>
</div>
<div class="paragraph">
<p>This declares that each <code>Point</code> has an <code>int</code> method named <code>getX</code> with no
arguments that returns whatever <code>this.x</code> is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">int</span> <span class="predefined-type">Point</span>.getX() { <span class="keyword">return</span> <span class="local-variable">this</span>.x; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inside the body, <code>this</code> is the <code>Point</code> object currently executing.
Because the method is publically declared any code can call it, but if
there is some other <code>Point.getX()</code> declared there will be a compile-time
conflict.</p>
</div>
<div class="paragraph">
<p>This publically declares a two-argument constructor for <code>Point</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="predefined-type">Point</span>.new(<span class="type">int</span> x, <span class="type">int</span> y) { <span class="local-variable">this</span>.x = x; <span class="local-variable">this</span>.y = y; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This publicly declares that each <code>Point</code> has an <code>int</code> field named <code>x</code>,
initialized to zero:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">int</span> <span class="predefined-type">Point</span>.x = <span class="integer">0</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Because this is publically declared, it is an error if <code>Point</code> already
has a field named <code>x</code> (defined by <code>Point</code> or by another aspect).</p>
</div>
<div class="paragraph">
<p>This declares that the <code>Point</code> class implements the <code>Comparable</code>
interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">declare parents: <span class="predefined-type">Point</span> <span class="directive">implements</span> <span class="predefined-type">Comparable</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Of course, this will be an error unless <code>Point</code> defines the methods
required by <code>Comparable</code>.</p>
</div>
<div class="paragraph">
<p>This declares that the <code>Point</code> class extends the <code>GeometricObject</code>
class.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">declare parents: <span class="predefined-type">Point</span> <span class="directive">extends</span> GeometricObject;</code></pre>
</div>
</div>
<div class="paragraph">
<p>An aspect can have several inter-type declarations. For example, the
following declarations</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="predefined-type">String</span> <span class="predefined-type">Point</span>.name;
<span class="directive">public</span> <span class="type">void</span> <span class="predefined-type">Point</span>.setName(<span class="predefined-type">String</span> name) { <span class="local-variable">this</span>.name = name; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>publicly declare that Point has both a String field <code>name</code> and a <code>void</code>
method <code>setName(String)</code> (which refers to the <code>name</code> field declared by
the aspect).</p>
</div>
<div class="paragraph">
<p>An inter-type member can only have one target type, but often you may
wish to declare the same member on more than one type. This can be done
by using an inter-type member in combination with a private interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect A {
  <span class="directive">private</span> <span class="type">interface</span> <span class="class">HasName</span> {}
  declare parents: (<span class="predefined-type">Point</span> || <span class="predefined-type">Line</span> || Square) <span class="directive">implements</span> HasName;

  <span class="directive">private</span> <span class="predefined-type">String</span> HasName.name;
  <span class="directive">public</span>  <span class="predefined-type">String</span> HasName.getName()  { <span class="keyword">return</span> name; }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This declares a marker interface <code>HasName</code>, and also declares that any
type that is either <code>Point</code>, <code>Line</code>, or <code>Square</code> implements that
interface. It also privately declares that all <code>HasName</code> object have a
<code>String</code> field called <code>name</code>, and publically declares that all <code>HasName</code>
objects have a <code>String</code> method <code>getName()</code> (which refers to the
privately declared <code>name</code> field).</p>
</div>
<div class="paragraph">
<p>As you can see from the above example, an aspect can declare that
interfaces have fields and methods, even non-constant fields and methods
with bodies.</p>
</div>
<div class="sect3">
<h4 id="_inter_type_scope">Inter-type Scope</h4>
<div class="paragraph">
<p>AspectJ allows private and package-protected (default) inter-type
declarations in addition to public inter-type declarations. Private
means private in relation to the aspect, not necessarily the target
type. So, if an aspect makes a private inter-type declaration of a field</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">private</span> <span class="type">int</span> Foo.x;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then code in the aspect can refer to <code>Foo</code>'s <code>x</code> field, but nobody else
can. Similarly, if an aspect makes a package-protected introduction,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">int</span> Foo.x;</code></pre>
</div>
</div>
<div class="paragraph">
<p>then everything in the aspect&#8217;s package (which may or may not be <code>Foo</code>'s
package) can access <code>x</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_example_pointassertions">Example: <code>PointAssertions</code></h4>
<div class="paragraph">
<p>The example below consists of one class and one aspect. The aspect
privately declares the assertion methods of <code>Point</code>, <code>assertX</code> and
<code>assertY</code>. It also guards calls to <code>setX</code> and <code>setY</code> with calls to these
assertion methods. The assertion methods are declared privately because
other parts of the program (including the code in <code>Point</code>) have no
business accessing the assert methods. Only the code inside of the
aspect can call those methods.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">Point</span>  {
  <span class="type">int</span> x, y;

  <span class="directive">public</span> <span class="type">void</span> setX(<span class="type">int</span> x) { <span class="local-variable">this</span>.x = x; }
  <span class="directive">public</span> <span class="type">void</span> setY(<span class="type">int</span> y) { <span class="local-variable">this</span>.y = y; }

  <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
    <span class="predefined-type">Point</span> p = <span class="keyword">new</span> <span class="predefined-type">Point</span>();
    p.setX(<span class="integer">3</span>); p.setY(<span class="integer">333</span>);
  }
}

aspect PointAssertions {

  <span class="directive">private</span> <span class="type">boolean</span> <span class="predefined-type">Point</span>.assertX(<span class="type">int</span> x) {
    <span class="keyword">return</span> (x &lt;= <span class="integer">100</span> &amp;&amp; x &gt;= <span class="integer">0</span>);
  }
  <span class="directive">private</span> <span class="type">boolean</span> <span class="predefined-type">Point</span>.assertY(<span class="type">int</span> y) {
    <span class="keyword">return</span> (y &lt;= <span class="integer">100</span> &amp;&amp; y &gt;= <span class="integer">0</span>);
  }

  before(<span class="predefined-type">Point</span> p, <span class="type">int</span> x): target(p) &amp;&amp; args(x) &amp;&amp; call(<span class="type">void</span> setX(<span class="type">int</span>)) {
    <span class="keyword">if</span> (!p.assertX(x))
      <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Illegal value for x</span><span class="delimiter">&quot;</span></span>); <span class="keyword">return</span>;
  }
  before(<span class="predefined-type">Point</span> p, <span class="type">int</span> y): target(p) &amp;&amp; args(y) &amp;&amp; call(<span class="type">void</span> setY(<span class="type">int</span>)) {
    <span class="keyword">if</span> (!p.assertY(y))
      <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Illegal value for y</span><span class="delimiter">&quot;</span></span>); <span class="keyword">return</span>;
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="language-thisJoinPoint"><code>thisJoinPoint</code></h3>
<div class="paragraph">
<p>AspectJ provides a special reference variable, <code>thisJoinPoint</code>, that
contains reflective information about the current join point for the
advice to use. The <code>thisJoinPoint</code> variable can only be used in the
context of advice, just like <code>this</code> can only be used in the context of
non-static methods and variable initializers. In advice, <code>thisJoinPoint</code>
is an object of type
<a href="../runtime-api/org/aspectj/lang/JoinPoint.html"><code>org.aspectj.lang.JoinPoint</code></a>.</p>
</div>
<div class="paragraph">
<p>One way to use it is simply to print it out. Like all Java objects,
<code>thisJoinPoint</code> has a <code>toString()</code> method that makes quick-and-dirty
tracing easy:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect TraceNonStaticMethods {
  before(<span class="predefined-type">Point</span> p): target(p) &amp;&amp; call(* *(..)) {
    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Entering </span><span class="delimiter">&quot;</span></span> + thisJoinPoint + <span class="string"><span class="delimiter">&quot;</span><span class="content"> in </span><span class="delimiter">&quot;</span></span> + p);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The type of <code>thisJoinPoint</code> includes a rich reflective class hierarchy
of signatures, and can be used to access both static and dynamic
information about join points such as the arguments of the join point:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">thisJoinPoint.getArgs()</code></pre>
</div>
</div>
<div class="paragraph">
<p>In addition, it holds an object consisting of all the static information
about the join point such as corresponding line number and static
signature:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">thisJoinPoint.getStaticPart()</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you only need the static information about the join point, you may
access the static part of the join point directly with the special
variable <code>thisJoinPointStaticPart</code>. Using <code>thisJoinPointStaticPart</code> will
avoid the run-time creation of the join point object that may be
necessary when using <code>thisJoinPoint</code> directly.</p>
</div>
<div class="paragraph">
<p>It is always the case that</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">thisJoinPointStaticPart == thisJoinPoint.getStaticPart()

thisJoinPoint.getKind() == thisJoinPointStaticPart.getKind()
thisJoinPoint.getSignature() == thisJoinPointStaticPart.getSignature()
thisJoinPoint.getSourceLocation() == thisJoinPointStaticPart.getSourceLocation()</code></pre>
</div>
</div>
<div class="paragraph">
<p>One more reflective variable is available:
<code>thisEnclosingJoinPointStaticPart</code>. This, like
<code>thisJoinPointStaticPart</code>, only holds the static part of a join point,
but it is not the current but the enclosing join point. So, for example,
it is possible to print out the calling source location (if available)
with</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">before() : execution (* *(..)) {
  <span class="predefined-type">System</span>.err.println(thisEnclosingJoinPointStaticPart.getSourceLocation())
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="examples">Examples</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="examples-intro">Introduction</h3>
<div class="paragraph">
<p>This chapter consists entirely of examples of AspectJ use.</p>
</div>
<div class="paragraph">
<p>The examples can be grouped into four categories:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">technique</dt>
<dd>
<p>Examples which illustrate how to use one or more features of the language</p>
</dd>
<dt class="hdlist1">development</dt>
<dd>
<p>Examples of using AspectJ during the development phase of a project</p>
</dd>
<dt class="hdlist1">production</dt>
<dd>
<p>Examples of using AspectJ to provide functionality in an application</p>
</dd>
<dt class="hdlist1">reusable</dt>
<dd>
<p>Examples of reuse of aspects and pointcuts</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="examples-howto">Obtaining, Compiling and Running the Examples</h3>
<div class="paragraph">
<p>The examples source code is part of the AspectJ distribution which may
be downloaded from the <a href="https://eclipse.org/aspectj">AspectJ project page</a>.</p>
</div>
<div class="paragraph">
<p>Compiling most examples is straightforward. Go the <code>InstallDir/examples</code>
directory, and look for a <code>.lst</code> file in one of the example
subdirectories. Use the <code>-arglist</code> option to <code>ajc</code> to compile the
example. For instance, to compile the telecom example with billing, type</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">ajc -argfile telecom/billing.lst</code></pre>
</div>
</div>
<div class="paragraph">
<p>To run the examples, your classpath must include the AspectJ run-time
Java archive (<code>aspectjrt.jar</code>). You may either set the <code>CLASSPATH</code>
environment variable or use the <code>-classpath</code> command line option to the
Java interpreter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">(In Unix use a : in the CLASSPATH)
java -classpath &quot;.:InstallDir/lib/aspectjrt.jar&quot; telecom.billingSimulation</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">(In Windows use a ; in the CLASSPATH)
java -classpath &quot;.;InstallDir/lib/aspectjrt.jar&quot; telecom.billingSimulation</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="examples-basic">Basic Techniques</h3>
<div class="paragraph">
<p>This section presents two basic techniques of using AspectJ, one each
from the two fundamental ways of capturing crosscutting concerns: with
dynamic join points and advice, and with static introduction. Advice
changes an application&#8217;s behavior. Introduction changes both an
application&#8217;s behavior and its structure.</p>
</div>
<div class="paragraph">
<p>The first example, <a href="#examples-joinPoints">Join Points and <code>thisJoinPoint</code></a>, is about
gathering and using information about the join point that has triggered
some advice. The second example, <a href="#examples-roles">Roles and Views</a>,
concerns a crosscutting view of an existing class hierarchy.</p>
</div>
<div class="sect3">
<h4 id="examples-joinPoints">Join Points and <code>thisJoinPoint</code></h4>
<div class="paragraph">
<p>(The code for this example is in <code>InstallDir/examples/tjp</code>.)</p>
</div>
<div class="paragraph">
<p>A join point is some point in the execution of a program together with a
view into the execution context when that point occurs. Join points are
picked out by pointcuts. When a program reaches a join point, advice on
that join point may run in addition to (or instead of) the join point
itself.</p>
</div>
<div class="paragraph">
<p>When using a pointcut that picks out join points of a single kind by
name, typicaly the the advice will know exactly what kind of join point
it is associated with. The pointcut may even publish context about the
join point. Here, for example, since the only join points picked out by
the pointcut are calls of a certain method, we can get the target value
and one of the argument values of the method calls directly.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">before(<span class="predefined-type">Point</span> p, <span class="type">int</span> x):
  target(p) &amp;&amp;
  args(x) &amp;&amp;
  call(<span class="type">void</span> setX(<span class="type">int</span>))
{
  <span class="keyword">if</span> (!p.assertX(x))
    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Illegal value for x</span><span class="delimiter">&quot;</span></span>); <span class="keyword">return</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>But sometimes the shape of the join point is not so clear. For instance,
suppose a complex application is being debugged, and we want to trace
when any method of some class is executed. The pointcut</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">pointcut execsInProblemClass():
  within(ProblemClass) &amp;&amp;
  execution(* *(..));</code></pre>
</div>
</div>
<div class="paragraph">
<p>will pick out each execution join point of every method defined within
<code>ProblemClass</code>. Since advice executes at each join point picked out by
the pointcut, we can reasonably ask which join point was reached.</p>
</div>
<div class="paragraph">
<p>Information about the join point that was matched is available to advice
through the special variable <code>thisJoinPoint</code>, of type
<a href="../runtime-api/org/aspectj/lang/JoinPoint.html"><code>org.aspectj.lang.JoinPoint</code></a>.
Through this object we can access information such as</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the kind of join point that was matched</p>
</li>
<li>
<p>the source location of the code associated with the join point</p>
</li>
<li>
<p>normal, short and long string representations of the current join
point</p>
</li>
<li>
<p>the actual argument values of the join point</p>
</li>
<li>
<p>the signature of the member associated with the join point</p>
</li>
<li>
<p>the currently executing object</p>
</li>
<li>
<p>the target object</p>
</li>
<li>
<p>an object encapsulating the static information about the join point.
This is also available through the special variable <code>thisJoinPointStaticPart</code>.</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_the_demo_class">The <code>Demo</code> class</h5>
<div class="paragraph">
<p>The class <code>tjp.Demo</code> in <code>tjp/Demo.java</code> defines two methods <code>foo</code> and
<code>bar</code> with different parameter lists and return types. Both are called,
with suitable arguments, by <code>Demo</code>'s <code>go</code> method which was invoked from
within its <code>main</code> method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Demo</span> {
  <span class="directive">static</span> Demo d;

  <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
    <span class="keyword">new</span> Demo().go();
  }

  <span class="type">void</span> go() {
    d = <span class="keyword">new</span> Demo();
    d.foo(<span class="integer">1</span>,d);
    <span class="predefined-type">System</span>.out.println(d.bar(<span class="keyword">new</span> <span class="predefined-type">Integer</span>(<span class="integer">3</span>)));
  }

  <span class="type">void</span> foo(<span class="type">int</span> i, <span class="predefined-type">Object</span> o) {
    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Demo.foo(</span><span class="delimiter">&quot;</span></span> + i + <span class="string"><span class="delimiter">&quot;</span><span class="content">, </span><span class="delimiter">&quot;</span></span> + o + <span class="string"><span class="delimiter">&quot;</span><span class="content">)</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>);
  }

  <span class="predefined-type">String</span> bar (<span class="predefined-type">Integer</span> j)  {
    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Demo.bar(</span><span class="delimiter">&quot;</span></span> + j + <span class="string"><span class="delimiter">&quot;</span><span class="content">)</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>);
    <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Demo.bar(</span><span class="delimiter">&quot;</span></span> + j  + <span class="string"><span class="delimiter">&quot;</span><span class="content">)</span><span class="delimiter">&quot;</span></span>;
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_the_getinfo_aspect">The <code>GetInfo</code> aspect</h5>
<div class="paragraph">
<p>This aspect uses around advice to intercept the execution of methods
<code>foo</code> and <code>bar</code> in <code>Demo</code>, and prints out information garnered from
<code>thisJoinPoint</code> to the console.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect GetInfo {

  <span class="directive">static</span> <span class="directive">final</span> <span class="type">void</span> println(<span class="predefined-type">String</span> s){ <span class="predefined-type">System</span>.out.println(s); }

  pointcut goCut(): cflow(<span class="local-variable">this</span>(Demo) &amp;&amp; execution(<span class="type">void</span> go()));

  pointcut demoExecs(): within(Demo) &amp;&amp; execution(* *(..));

  <span class="predefined-type">Object</span> around(): demoExecs() &amp;&amp; !execution(* go()) &amp;&amp; goCut() {
    println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Intercepted message: </span><span class="delimiter">&quot;</span></span> +
      thisJoinPointStaticPart.getSignature().getName());
    println(<span class="string"><span class="delimiter">&quot;</span><span class="content">in class: </span><span class="delimiter">&quot;</span></span> +
      thisJoinPointStaticPart.getSignature().getDeclaringType().getName());
    printParameters(thisJoinPoint);
    println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Running original method: </span><span class="char">\n</span><span class="delimiter">&quot;</span></span> );
    <span class="predefined-type">Object</span> result = proceed();
    println(<span class="string"><span class="delimiter">&quot;</span><span class="content">  result: </span><span class="delimiter">&quot;</span></span> + result );
    <span class="keyword">return</span> result;
  }

  <span class="directive">static</span> <span class="directive">private</span> <span class="type">void</span> printParameters(JoinPoint jp) {
    println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Arguments: </span><span class="delimiter">&quot;</span></span> );
    <span class="predefined-type">Object</span><span class="type">[]</span> args = jp.getArgs();
    <span class="predefined-type">String</span><span class="type">[]</span> names = ((CodeSignature)jp.getSignature()).getParameterNames();
    <span class="predefined-type">Class</span><span class="type">[]</span> types = ((CodeSignature)jp.getSignature()).getParameterTypes();
    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="integer">0</span>; i &lt; args.length; i++) {
      println(
        <span class="string"><span class="delimiter">&quot;</span><span class="content">  </span><span class="delimiter">&quot;</span></span>  + i + <span class="string"><span class="delimiter">&quot;</span><span class="content">. </span><span class="delimiter">&quot;</span></span> + names[i] +
        <span class="string"><span class="delimiter">&quot;</span><span class="content"> : </span><span class="delimiter">&quot;</span></span> +            types[i].getName() +
        <span class="string"><span class="delimiter">&quot;</span><span class="content"> = </span><span class="delimiter">&quot;</span></span> +            args[i]);
    }
  }
}</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="_defining_the_scope_of_a_pointcut">Defining the scope of a pointcut</h6>
<div class="paragraph">
<p>The pointcut <code>goCut</code> is defined as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">cflow(<span class="local-variable">this</span>(Demo)) &amp;&amp; execution(<span class="type">void</span> go())</code></pre>
</div>
</div>
<div class="paragraph">
<p>so that only executions made in the control flow of <code>Demo.go</code> are
intercepted. The control flow from the method <code>go</code> includes the
execution of <code>go</code> itself, so the definition of the around advice
includes <code>!execution(* go())</code> to exclude it from the set of executions
advised.</p>
</div>
</div>
<div class="sect5">
<h6 id="_printing_the_class_and_method_name">Printing the class and method name</h6>
<div class="paragraph">
<p>The name of the method and that method&#8217;s defining class are available as
parts of the
<a href="../runtime-api/org/aspectj/lang/Signature.html"><code>org.aspectj.lang.Signature</code></a>
object returned by calling <code>getSignature()</code> on either <code>thisJoinPoint</code> or
<code>thisJoinPointStaticPart</code>.</p>
</div>
</div>
<div class="sect5">
<h6 id="_printing_the_parameters">Printing the parameters</h6>
<div class="paragraph">
<p>The static portions of the parameter details, the name and types of the
parameters, can be accessed through the
<a href="../runtime-api/org/aspectj/lang/reflect/CodeSignature.html"><code>org.aspectj.lang.reflect.CodeSignature</code></a>
associated with the join point. All execution join points have code
signatures, so the cast to <code>CodeSignature</code> cannot fail.</p>
</div>
<div class="paragraph">
<p>The dynamic portions of the parameter details, the actual values of the
parameters, are accessed directly from the execution join point object.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="examples-roles">Roles and Views</h4>
<div class="paragraph">
<p>(The code for this example is in <code>InstallDir/examples/introduction</code>.)</p>
</div>
<div class="paragraph">
<p>Like advice, inter-type declarations are members of an aspect. They
declare members that act as if they were defined on another class.
Unlike advice, inter-type declarations affect not only the behavior of
the application, but also the structural relationship between an
application&#8217;s classes.</p>
</div>
<div class="paragraph">
<p>This is crucial: Publically affecting the class structure of an
application makes these modifications available to other components of
the application.</p>
</div>
<div class="paragraph">
<p>Aspects can declare inter-type</p>
</div>
<div class="ulist">
<ul>
<li>
<p>fields</p>
</li>
<li>
<p>methods</p>
</li>
<li>
<p>constructors</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>and can also declare that target types</p>
</div>
<div class="ulist">
<ul>
<li>
<p>implement new interfaces</p>
</li>
<li>
<p>extend new classes</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This example provides three illustrations of the use of inter-type
declarations to encapsulate roles or views of a class. The class our
aspect will be dealing with, <code>Point</code>, is a simple class with rectangular
and polar coordinates. Our inter-type declarations will make the class
<code>Point</code>, in turn, cloneable, hashable, and comparable. These facilities
are provided by AspectJ without having to modify the code for the class
<code>Point</code>.</p>
</div>
<div class="sect4">
<h5 id="_the_point_class">The <code>Point</code> class</h5>
<div class="paragraph">
<p>The <code>Point</code> class defines geometric points whose interface includes
polar and rectangular coordinates, plus some simple operations to
relocate points. <code>Point</code>'s implementation has attributes for both its
polar and rectangular coordinates, plus flags to indicate which
currently reflect the position of the point. Some operations cause the
polar coordinates to be updated from the rectangular, and some have the
opposite effect. This implementation, which is in intended to give the
minimum number of conversions between coordinate systems, has the
property that not all the attributes stored in a <code>Point</code> object are
necessary to give a canonical representation such as might be used for
storing, comparing, cloning or making hash codes from points. Thus the
aspects, though simple, are not totally trivial.</p>
</div>
<div class="paragraph">
<p>The diagram below gives an overview of the aspects and their interaction
with the class <code>Point</code>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/aspects.png" alt="image"></span></p>
</div>
</div>
<div class="sect4">
<h5 id="_the_cloneablepoint_aspect">The <code>CloneablePoint</code> aspect</h5>
<div class="paragraph">
<p>This first aspect is responsible for <code>Point</code>'s implementation of the
<code>Cloneable</code> interface. It declares that <code>Point implements Cloneable</code>
with a <code>declare parents</code> form, and also publically declares a
specialized <code>Point</code>'s <code>clone()</code> method. In Java, all objects inherit the
method <code>clone</code> from the class <code>Object</code>, but an object is not cloneable
unless its class also implements the interface <code>Cloneable</code>. In addition,
classes frequently have requirements over and above the simple
bit-for-bit copying that <code>Object.clone</code> does. In our case, we want to
update a <code>Point</code>'s coordinate systems before we actually clone the
<code>Point</code>. So our aspect makes sure that <code>Point</code> overrides <code>Object.clone</code>
with a new method that does what we want.</p>
</div>
<div class="paragraph">
<p>We also define a test <code>main</code> method in the aspect for convenience.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> aspect CloneablePoint {

  declare parents: <span class="predefined-type">Point</span> <span class="directive">implements</span> <span class="predefined-type">Cloneable</span>;

  <span class="directive">public</span> <span class="predefined-type">Object</span> <span class="predefined-type">Point</span>.clone() <span class="directive">throws</span> <span class="exception">CloneNotSupportedException</span> {
    <span class="comment">// we choose to bring all fields up to date before cloning.</span>
    makeRectangular();
    makePolar();
    <span class="keyword">return</span> <span class="local-variable">super</span>.clone();
  }

  <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
    <span class="predefined-type">Point</span> p1 = <span class="keyword">new</span> <span class="predefined-type">Point</span>();
    <span class="predefined-type">Point</span> p2 = <span class="predefined-constant">null</span>;

    p1.setPolar(<span class="predefined-type">Math</span>.PI, <span class="float">1.0</span>);
    <span class="keyword">try</span> {
      p2 = (<span class="predefined-type">Point</span>)p1.clone();
    } <span class="keyword">catch</span> (<span class="exception">CloneNotSupportedException</span> e) {}
    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">p1 =</span><span class="delimiter">&quot;</span></span> + p1);
    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">p2 =</span><span class="delimiter">&quot;</span></span> + p2);

    p1.rotate(<span class="predefined-type">Math</span>.PI / -<span class="integer">2</span>);
    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">p1 =</span><span class="delimiter">&quot;</span></span> + p1);
    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">p2 =</span><span class="delimiter">&quot;</span></span> + p2);
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_the_comparablepoint_aspect">The <code>ComparablePoint</code> aspect</h5>
<div class="paragraph">
<p><code>ComparablePoint</code> is responsible for <code>Point</code>'s implementation of the
<code>Comparable</code> interface.</p>
</div>
<div class="paragraph">
<p>The interface <code>Comparable</code> defines the single method <code>compareTo</code> which
can be use to define a natural ordering relation among the objects of a
class that implement it.</p>
</div>
<div class="paragraph">
<p><code>ComparablePoint</code> uses <code>declare parents</code> to declare that <code>Point implements Comparable</code>,
and also publically declares the appropriate <code>compareTo(Object)</code> method:
A <code>Point</code> <code>p1</code> is said to be less than another <code>Point p2</code> if <code>p1</code> is closer to the origin.</p>
</div>
<div class="paragraph">
<p>We also define a test <code>main</code> method in the aspect for convenience.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> aspect ComparablePoint {

  declare parents: <span class="predefined-type">Point</span> <span class="directive">implements</span> <span class="predefined-type">Comparable</span>;

  <span class="directive">public</span> <span class="type">int</span> <span class="predefined-type">Point</span>.compareTo(<span class="predefined-type">Object</span> o) {
    <span class="keyword">return</span> (<span class="type">int</span>) (<span class="local-variable">this</span>.getRho() - ((<span class="predefined-type">Point</span>)o).getRho());
  }

  <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
    <span class="predefined-type">Point</span> p1 = <span class="keyword">new</span> <span class="predefined-type">Point</span>();
    <span class="predefined-type">Point</span> p2 = <span class="keyword">new</span> <span class="predefined-type">Point</span>();

    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">p1 =?= p2 :</span><span class="delimiter">&quot;</span></span> + p1.compareTo(p2));

    p1.setRectangular(<span class="integer">2</span>,<span class="integer">5</span>);
    p2.setRectangular(<span class="integer">2</span>,<span class="integer">5</span>);
    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">p1 =?= p2 :</span><span class="delimiter">&quot;</span></span> + p1.compareTo(p2));

    p2.setRectangular(<span class="integer">3</span>,<span class="integer">6</span>);
    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">p1 =?= p2 :</span><span class="delimiter">&quot;</span></span> + p1.compareTo(p2));

    p1.setPolar(<span class="predefined-type">Math</span>.PI, <span class="integer">4</span>);
    p2.setPolar(<span class="predefined-type">Math</span>.PI, <span class="integer">4</span>);
    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">p1 =?= p2 :</span><span class="delimiter">&quot;</span></span> + p1.compareTo(p2));

    p1.rotate(<span class="predefined-type">Math</span>.PI / <span class="float">4.0</span>);
    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">p1 =?= p2 :</span><span class="delimiter">&quot;</span></span> + p1.compareTo(p2));

    p1.offset(<span class="integer">1</span>,<span class="integer">1</span>);
    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">p1 =?= p2 :</span><span class="delimiter">&quot;</span></span> + p1.compareTo(p2));
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_the_hashablepoint_aspect">The <code>HashablePoint</code> aspect</h5>
<div class="paragraph">
<p>Our third aspect is responsible for <code>Point</code>'s overriding of <code>Object</code>'s
<code>equals</code> and <code>hashCode</code> methods in order to make <code>Point</code>s hashable.</p>
</div>
<div class="paragraph">
<p>The method <code>Object.hashCode</code> returns an integer, suitable for use as a
hash table key. It is not required that two objects which are not equal
(according to the <code>equals</code> method) return different integer results from
<code>hashCode</code> but it can improve performance when the integer is used as a
key into a data structure. However, any two objects which are equal must
return the same integer value from a call to <code>hashCode</code>. Since the
default implementation of <code>Object.equals</code> returns <code>true</code> only when two
objects are identical, we need to redefine both <code>equals</code> and <code>hashCode</code>
to work correctly with objects of type <code>Point</code>. For example, we want two
<code>Point</code> objects to test equal when they have the same <code>x</code> and <code>y</code>
values, or the same <code>rho</code> and <code>theta</code> values, not just when they refer
to the same object. We do this by overriding the methods <code>equals</code> and
<code>hashCode</code> in the class <code>Point</code>.</p>
</div>
<div class="paragraph">
<p>So <code>HashablePoint</code> declares <code>Point</code>'s <code>hashCode</code> and <code>equals</code> methods,
using <code>Point</code>'s rectangular coordinates to generate a hash code and to
test for equality. The <code>x</code> and <code>y</code> coordinates are obtained using the
appropriate get methods, which ensure the rectangular coordinates are
up-to-date before returning their values.</p>
</div>
<div class="paragraph">
<p>And again, we supply a <code>main</code> method in the aspect for testing.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> aspect HashablePoint {

  <span class="directive">public</span> <span class="type">int</span> <span class="predefined-type">Point</span>.hashCode() {
    <span class="keyword">return</span> (<span class="type">int</span>) (getX() + getY() % <span class="predefined-type">Integer</span>.MAX_VALUE);
  }

  <span class="directive">public</span> <span class="type">boolean</span> <span class="predefined-type">Point</span>.equals(<span class="predefined-type">Object</span> o) {
    <span class="keyword">if</span> (o == <span class="local-variable">this</span>) <span class="keyword">return</span> <span class="predefined-constant">true</span>;
    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> <span class="predefined-type">Point</span>)) <span class="keyword">return</span> <span class="predefined-constant">false</span>;
    <span class="predefined-type">Point</span> other = (<span class="predefined-type">Point</span>)o;
    <span class="keyword">return</span> (getX() == other.getX()) &amp;&amp; (getY() == other.getY());
  }

  <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
    <span class="predefined-type">Hashtable</span> h = <span class="keyword">new</span> <span class="predefined-type">Hashtable</span>();
    <span class="predefined-type">Point</span> p1 = <span class="keyword">new</span> <span class="predefined-type">Point</span>();

    p1.setRectangular(<span class="integer">10</span>, <span class="integer">10</span>);
    <span class="predefined-type">Point</span> p2 = <span class="keyword">new</span> <span class="predefined-type">Point</span>();

    p2.setRectangular(<span class="integer">10</span>, <span class="integer">10</span>);

    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">p1 = </span><span class="delimiter">&quot;</span></span> + p1);
    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">p2 = </span><span class="delimiter">&quot;</span></span> + p2);
    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">p1.hashCode() = </span><span class="delimiter">&quot;</span></span> + p1.hashCode());
    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">p2.hashCode() = </span><span class="delimiter">&quot;</span></span> + p2.hashCode());

    h.put(p1, <span class="string"><span class="delimiter">&quot;</span><span class="content">P1</span><span class="delimiter">&quot;</span></span>);
    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Got: </span><span class="delimiter">&quot;</span></span> + h.get(p2));
  }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="examples-development">Development Aspects</h3>
<div class="sect3">
<h4 id="_tracing_using_aspects">Tracing using aspects</h4>
<div class="paragraph">
<p>(The code for this example is in <code>InstallDir/examples/tracing</code>.)</p>
</div>
<div class="paragraph">
<p>Writing a class that provides tracing functionality is easy: a couple of
functions, a boolean flag for turning tracing on and off, a choice for
an output stream, maybe some code for formatting the output&#8201;&#8212;&#8201;these are
all elements that <code>Trace</code> classes have been known to have. <code>Trace</code>
classes may be highly sophisticated, too, if the task of tracing the
execution of a program demands it.</p>
</div>
<div class="paragraph">
<p>But developing the support for tracing is just one part of the effort of
inserting tracing into a program, and, most likely, not the biggest
part. The other part of the effort is calling the tracing functions at
appropriate times. In large systems, this interaction with the tracing
support can be overwhelming. Plus, tracing is one of those things that
slows the system down, so these calls should often be pulled out of the
system before the product is shipped. For these reasons, it is not
unusual for developers to write ad-hoc scripting programs that rewrite
the source code by inserting/deleting trace calls before and after the
method bodies.</p>
</div>
<div class="paragraph">
<p>AspectJ can be used for some of these tracing concerns in a less ad-hoc
way. Tracing can be seen as a concern that crosscuts the entire system
and as such is amenable to encapsulation in an aspect. In addition, it
is fairly independent of what the system is doing. Therefore tracing is
one of those kind of system aspects that can potentially be plugged in
and unplugged without any side-effects in the basic functionality of the
system.</p>
</div>
<div class="sect4">
<h5 id="_an_example_application">An Example Application</h5>
<div class="paragraph">
<p>Throughout this example we will use a simple application that contains
only four classes. The application is about shapes. The <code>TwoDShape</code>
class is the root of the shape hierarchy:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">TwoDShape</span> {
  <span class="directive">protected</span> <span class="type">double</span> x, y;
  <span class="directive">protected</span> TwoDShape(<span class="type">double</span> x, <span class="type">double</span> y) {
    <span class="local-variable">this</span>.x = x; <span class="local-variable">this</span>.y = y;
  }
  <span class="directive">public</span> <span class="type">double</span> getX() { <span class="keyword">return</span> x; }
  <span class="directive">public</span> <span class="type">double</span> getY() { <span class="keyword">return</span> y; }
  <span class="directive">public</span> <span class="type">double</span> distance(TwoDShape s) {
    <span class="type">double</span> dx = <span class="predefined-type">Math</span>.abs(s.getX() - x);
    <span class="type">double</span> dy = <span class="predefined-type">Math</span>.abs(s.getY() - y);
    <span class="keyword">return</span> <span class="predefined-type">Math</span>.sqrt(dx*dx + dy*dy);
  }
  <span class="directive">public</span> <span class="directive">abstract</span> <span class="type">double</span> perimeter();
  <span class="directive">public</span> <span class="directive">abstract</span> <span class="type">double</span> area();
  <span class="directive">public</span> <span class="predefined-type">String</span> toString() {
    <span class="keyword">return</span> (<span class="string"><span class="delimiter">&quot;</span><span class="content"> @ (</span><span class="delimiter">&quot;</span></span> + <span class="predefined-type">String</span>.valueOf(x) + <span class="string"><span class="delimiter">&quot;</span><span class="content">, </span><span class="delimiter">&quot;</span></span> + <span class="predefined-type">String</span>.valueOf(y) + <span class="string"><span class="delimiter">&quot;</span><span class="content">) </span><span class="delimiter">&quot;</span></span>);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>TwoDShape</code> has two subclasses, <code>Circle</code> and <code>Square</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Circle</span> <span class="directive">extends</span> TwoDShape {
  <span class="directive">protected</span> <span class="type">double</span> r;
  <span class="directive">public</span> Circle(<span class="type">double</span> x, <span class="type">double</span> y, <span class="type">double</span> r) {
    <span class="local-variable">super</span>(x, y); <span class="local-variable">this</span>.r = r;
  }
  <span class="directive">public</span> Circle(<span class="type">double</span> x, <span class="type">double</span> y) { <span class="local-variable">this</span>(  x,   y, <span class="float">1.0</span>); }
  <span class="directive">public</span> Circle(<span class="type">double</span> r)           { <span class="local-variable">this</span>(<span class="float">0.0</span>, <span class="float">0.0</span>,   r); }
  <span class="directive">public</span> Circle()                   { <span class="local-variable">this</span>(<span class="float">0.0</span>, <span class="float">0.0</span>, <span class="float">1.0</span>); }
  <span class="directive">public</span> <span class="type">double</span> perimeter() {
    <span class="keyword">return</span> <span class="integer">2</span> * <span class="predefined-type">Math</span>.PI * r;
  }
  <span class="directive">public</span> <span class="type">double</span> area() {
    <span class="keyword">return</span> <span class="predefined-type">Math</span>.PI * r*r;
  }
  <span class="directive">public</span> <span class="predefined-type">String</span> toString() {
    <span class="keyword">return</span> (<span class="string"><span class="delimiter">&quot;</span><span class="content">Circle radius = </span><span class="delimiter">&quot;</span></span> + <span class="predefined-type">String</span>.valueOf(r) + <span class="local-variable">super</span>.toString());
  }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Square</span> <span class="directive">extends</span> TwoDShape {
  <span class="directive">protected</span> <span class="type">double</span> s;  <span class="comment">// side</span>
  <span class="directive">public</span> Square(<span class="type">double</span> x, <span class="type">double</span> y, <span class="type">double</span> s) {
    <span class="local-variable">super</span>(x, y); <span class="local-variable">this</span>.s = s;
  }
  <span class="directive">public</span> Square(<span class="type">double</span> x, <span class="type">double</span> y) { <span class="local-variable">this</span>(  x,   y, <span class="float">1.0</span>); }
  <span class="directive">public</span> Square(<span class="type">double</span> s)           { <span class="local-variable">this</span>(<span class="float">0.0</span>, <span class="float">0.0</span>,   s); }
  <span class="directive">public</span> Square()                   { <span class="local-variable">this</span>(<span class="float">0.0</span>, <span class="float">0.0</span>, <span class="float">1.0</span>); }
  <span class="directive">public</span> <span class="type">double</span> perimeter() {
    <span class="keyword">return</span> <span class="integer">4</span> * s;
  }
  <span class="directive">public</span> <span class="type">double</span> area() {
    <span class="keyword">return</span> s*s;
  }
  <span class="directive">public</span> <span class="predefined-type">String</span> toString() {
    <span class="keyword">return</span> (<span class="string"><span class="delimiter">&quot;</span><span class="content">Square side = </span><span class="delimiter">&quot;</span></span> + <span class="predefined-type">String</span>.valueOf(s) + <span class="local-variable">super</span>.toString());
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To run this application, compile the classes. You can do it with or
without ajc, the AspectJ compiler. If you&#8217;ve installed AspectJ, go to
the directory <code>InstallDir/examples</code> and type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">ajc -argfile tracing/notrace.lst</code></pre>
</div>
</div>
<div class="paragraph">
<p>To run the program, type</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">java tracing.ExampleMain</code></pre>
</div>
</div>
<div class="paragraph">
<p>(we don&#8217;t need anything special on the classpath since this is pure Java
code). You should see the following output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">c1.perimeter() = 12.566370614359172
c1.area() = 12.566370614359172
s1.perimeter() = 4.0
s1.area() = 1.0
c2.distance(c1) = 4.242640687119285
s1.distance(c1) = 2.23606797749979
s1.toString(): Square side = 1.0 @ (1.0, 2.0)</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tracing_version_1">Tracing - Version 1</h5>
<div class="paragraph">
<p>In a first attempt to insert tracing in this application, we will start
by writing a <code>Trace</code> class that is exactly what we would write if we
didn&#8217;t have aspects. The implementation is in <code>version1/Trace.java</code>. Its
public interface is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Trace</span> {
  <span class="directive">public</span> <span class="directive">static</span> <span class="type">int</span> TRACELEVEL = <span class="integer">0</span>;
  <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> initStream(<span class="predefined-type">PrintStream</span> s) {...}
  <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> traceEntry(<span class="predefined-type">String</span> str) {...}
  <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> traceExit(<span class="predefined-type">String</span> str) {...}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we didn&#8217;t have AspectJ, we would have to insert calls to <code>traceEntry</code>
and <code>traceExit</code> in all methods and constructors we wanted to trace, and
to initialize <code>TRACELEVEL</code> and the stream. If we wanted to trace all the
methods and constructors in our example, that would amount to around 40
calls, and we would hope we had not forgotten any method. But we can do
that more consistently and reliably with the following aspect (found in
<code>version1/TraceMyClasses.java</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> aspect TraceMyClasses {
  pointcut myClass(): within(TwoDShape) || within(Circle) || within(Square);
  pointcut myConstructor(): myClass() &amp;&amp; execution(<span class="keyword">new</span>(..));
  pointcut myMethod(): myClass() &amp;&amp; execution(* *(..));

  before (): myConstructor() {
    Trace.traceEntry(<span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span> + thisJoinPointStaticPart.getSignature());
  }
  after(): myConstructor() {
    Trace.traceExit(<span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span> + thisJoinPointStaticPart.getSignature());
  }

  before (): myMethod() {
    Trace.traceEntry(<span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span> + thisJoinPointStaticPart.getSignature());
  }
  after(): myMethod() {
    Trace.traceExit(<span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span> + thisJoinPointStaticPart.getSignature());
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This aspect performs the tracing calls at appropriate times. According
to this aspect, tracing is performed at the entrance and exit of every
method and constructor defined within the shape hierarchy.</p>
</div>
<div class="paragraph">
<p>What is printed at before and after each of the traced join points is
the signature of the method executing. Since the signature is static
information, we can get it through <code>thisJoinPointStaticPart</code>.</p>
</div>
<div class="paragraph">
<p>To run this version of tracing, go to the directory
<code>InstallDir/examples</code> and type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">ajc -argfile tracing/tracev1.lst</code></pre>
</div>
</div>
<div class="paragraph">
<p>Running the main method of <code>tracing.version1.TraceMyClasses</code> should
produce the output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">  --&gt; tracing.TwoDShape(double, double)
  &lt;-- tracing.TwoDShape(double, double)
  --&gt; tracing.Circle(double, double, double)
  &lt;-- tracing.Circle(double, double, double)
  --&gt; tracing.TwoDShape(double, double)
  &lt;-- tracing.TwoDShape(double, double)
  --&gt; tracing.Circle(double, double, double)
  &lt;-- tracing.Circle(double, double, double)
  --&gt; tracing.Circle(double)
  &lt;-- tracing.Circle(double)
  --&gt; tracing.TwoDShape(double, double)
  &lt;-- tracing.TwoDShape(double, double)
  --&gt; tracing.Square(double, double, double)
  &lt;-- tracing.Square(double, double, double)
  --&gt; tracing.Square(double, double)
  &lt;-- tracing.Square(double, double)
  --&gt; double tracing.Circle.perimeter()
  &lt;-- double tracing.Circle.perimeter()
c1.perimeter() = 12.566370614359172
  --&gt; double tracing.Circle.area()
  &lt;-- double tracing.Circle.area()
c1.area() = 12.566370614359172
  --&gt; double tracing.Square.perimeter()
  &lt;-- double tracing.Square.perimeter()
s1.perimeter() = 4.0
  --&gt; double tracing.Square.area()
  &lt;-- double tracing.Square.area()
s1.area() = 1.0
  --&gt; double tracing.TwoDShape.distance(TwoDShape)
    --&gt; double tracing.TwoDShape.getX()
    &lt;-- double tracing.TwoDShape.getX()
    --&gt; double tracing.TwoDShape.getY()
    &lt;-- double tracing.TwoDShape.getY()
  &lt;-- double tracing.TwoDShape.distance(TwoDShape)
c2.distance(c1) = 4.242640687119285
  --&gt; double tracing.TwoDShape.distance(TwoDShape)
    --&gt; double tracing.TwoDShape.getX()
    &lt;-- double tracing.TwoDShape.getX()
    --&gt; double tracing.TwoDShape.getY()
    &lt;-- double tracing.TwoDShape.getY()
  &lt;-- double tracing.TwoDShape.distance(TwoDShape)
s1.distance(c1) = 2.23606797749979
  --&gt; String tracing.Square.toString()
    --&gt; String tracing.TwoDShape.toString()
    &lt;-- String tracing.TwoDShape.toString()
  &lt;-- String tracing.Square.toString()
s1.toString(): Square side = 1.0 @ (1.0, 2.0)</code></pre>
</div>
</div>
<div class="paragraph">
<p>When <code>TraceMyClasses.java</code> is not provided to <code>ajc</code>, the aspect does not
have any affect on the system and the tracing is unplugged.</p>
</div>
</div>
<div class="sect4">
<h5 id="_tracing_version_2">Tracing - Version 2</h5>
<div class="paragraph">
<p>Another way to accomplish the same thing would be to write a reusable
tracing aspect that can be used not only for these application classes,
but for any class. One way to do this is to merge the tracing
functionality of <code>Trace - version1</code> with the crosscutting support of
<code>TraceMyClasses - version1</code>. We end up with a <code>Trace</code> aspect (found in
<code>version2/Trace.java</code>) with the following public interface</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">abstract</span> aspect Trace {
  <span class="directive">public</span> <span class="directive">static</span> <span class="type">int</span> TRACELEVEL = <span class="integer">2</span>;
  <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> initStream(<span class="predefined-type">PrintStream</span> s) {...}
  <span class="directive">protected</span> <span class="directive">static</span> <span class="type">void</span> traceEntry(<span class="predefined-type">String</span> str) {...}
  <span class="directive">protected</span> <span class="directive">static</span> <span class="type">void</span> traceExit(<span class="predefined-type">String</span> str) {...}
  <span class="directive">abstract</span> pointcut myClass();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In order to use it, we need to define our own subclass that knows about
our application classes, in <code>version2/TraceMyClasses.java</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> aspect TraceMyClasses <span class="directive">extends</span> Trace {
  pointcut myClass(): within(TwoDShape) || within(Circle) || within(Square);

  <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
    Trace.TRACELEVEL = <span class="integer">2</span>;
    Trace.initStream(<span class="predefined-type">System</span>.err);
    ExampleMain.main(args);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that we&#8217;ve simply made the pointcut <code>classes</code>, that was an
abstract pointcut in the super-aspect, concrete. To run this version of
tracing, go to the directory <code>examples</code> and type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">ajc -argfile tracing/tracev2.lst</code></pre>
</div>
</div>
<div class="paragraph">
<p>The file <code>tracev2.lst</code> lists the application classes as well as this
version of the files Trace.java and TraceMyClasses.java. Running the
main method of <code>tracing.version2.TraceMyClasses</code> should output exactly
the same trace information as that from version 1.</p>
</div>
<div class="paragraph">
<p>The entire implementation of the new <code>Trace</code> class is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">abstract</span> aspect Trace {

  <span class="comment">// implementation part</span>

  <span class="directive">public</span> <span class="directive">static</span> <span class="type">int</span> TRACELEVEL = <span class="integer">2</span>;
  <span class="directive">protected</span> <span class="directive">static</span> <span class="predefined-type">PrintStream</span> stream = <span class="predefined-type">System</span>.err;
  <span class="directive">protected</span> <span class="directive">static</span> <span class="type">int</span> callDepth = <span class="integer">0</span>;

  <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> initStream(<span class="predefined-type">PrintStream</span> s) {
    stream = s;
  }
  <span class="directive">protected</span> <span class="directive">static</span> <span class="type">void</span> traceEntry(<span class="predefined-type">String</span> str) {
    <span class="keyword">if</span> (TRACELEVEL == <span class="integer">0</span>) <span class="keyword">return</span>;
    <span class="keyword">if</span> (TRACELEVEL == <span class="integer">2</span>) callDepth++;
    printEntering(str);
  }
  <span class="directive">protected</span> <span class="directive">static</span> <span class="type">void</span> traceExit(<span class="predefined-type">String</span> str) {
    <span class="keyword">if</span> (TRACELEVEL == <span class="integer">0</span>) <span class="keyword">return</span>;
    printExiting(str);
    <span class="keyword">if</span> (TRACELEVEL == <span class="integer">2</span>) callDepth--;
  }
  <span class="directive">private</span> <span class="directive">static</span> <span class="type">void</span> printEntering(<span class="predefined-type">String</span> str) {
    printIndent();
    stream.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">--&gt; </span><span class="delimiter">&quot;</span></span> + str);
  }
  <span class="directive">private</span> <span class="directive">static</span> <span class="type">void</span> printExiting(<span class="predefined-type">String</span> str) {
    printIndent();
    stream.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">&lt;-- </span><span class="delimiter">&quot;</span></span> + str);
  }
  <span class="directive">private</span> <span class="directive">static</span> <span class="type">void</span> printIndent() {
    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="integer">0</span>; i &lt; callDepth; i++)
      stream.print(<span class="string"><span class="delimiter">&quot;</span><span class="content">  </span><span class="delimiter">&quot;</span></span>);
  }

  <span class="comment">// protocol part</span>

  <span class="directive">abstract</span> pointcut myClass();

  pointcut myConstructor(): myClass() &amp;&amp; execution(<span class="keyword">new</span>(..));
  pointcut myMethod(): myClass() &amp;&amp; execution(* *(..));

  before(): myConstructor() {
    traceEntry(<span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span> + thisJoinPointStaticPart.getSignature());
  }
  after(): myConstructor() {
    traceExit(<span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span> + thisJoinPointStaticPart.getSignature());
  }

  before(): myMethod() {
    traceEntry(<span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span> + thisJoinPointStaticPart.getSignature());
  }
  after(): myMethod() {
    traceExit(<span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span> + thisJoinPointStaticPart.getSignature());
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This version differs from version 1 in several subtle ways. The first
thing to notice is that this <code>Trace</code> class merges the functional part of
tracing with the crosscutting of the tracing calls. That is, in version
1, there was a sharp separation between the tracing support (the class
<code>Trace</code>) and the crosscutting usage of it (by the class
<code>TraceMyClasses</code>). In this version those two things are merged. That&#8217;s
why the description of this class explicitly says that "Trace messages
are printed before and after constructors and methods are," which is
what we wanted in the first place. That is, the placement of the calls,
in this version, is established by the aspect class itself, leaving less
opportunity for misplacing calls.</p>
</div>
<div class="paragraph">
<p>A consequence of this is that there is no need for providing
<code>traceEntry</code> and <code>traceExit</code> as public operations of this class. You can
see that they were classified as protected. They are supposed to be
internal implementation details of the advice.</p>
</div>
<div class="paragraph">
<p>The key piece of this aspect is the abstract pointcut classes that
serves as the base for the definition of the pointcuts constructors and
methods. Even though <code>classes</code> is abstract, and therefore no concrete
classes are mentioned, we can put advice on it, as well as on the
pointcuts that are based on it. The idea is "we don&#8217;t know exactly what
the pointcut will be, but when we do, here&#8217;s what we want to do with
it." In some ways, abstract pointcuts are similar to abstract methods.
Abstract methods don&#8217;t provide the implementation, but you know that the
concrete subclasses will, so you can invoke those methods.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="examples-production">Production Aspects</h3>
<div class="sect3">
<h4 id="_a_bean_aspect">A Bean Aspect</h4>
<div class="paragraph">
<p>(The code for this example is in <code>InstallDir/examples/bean</code>.)</p>
</div>
<div class="paragraph">
<p>This example examines an aspect that makes Point objects into Java beans
with bound properties.</p>
</div>
<div class="paragraph">
<p>Java beans are reusable software components that can be visually
manipulated in a builder tool. The requirements for an object to be a
bean are few. Beans must define a no-argument constructor and must be
either <code>Serializable</code> or <code>Externalizable</code>. Any properties of the object
that are to be treated as bean properties should be indicated by the
presence of appropriate <code>get</code> and <code>set</code> methods whose names are
<code>get<em>property</em></code> and <code>set<em>property</em></code> where <code><em>property</em></code> is the name of
a field in the bean class. Some bean properties, known as bound
properties, fire events whenever their values change so that any
registered listeners (such as, other beans) will be informed of those
changes. Making a bound property involves keeping a list of registered
listeners, and creating and dispatching event objects in methods that
change the property values, such as <code>set<em>property</em></code> methods.</p>
</div>
<div class="paragraph">
<p><code>Point</code> is a simple class representing points with rectangular
coordinates. <code>Point</code> does not know anything about being a bean: there
are set methods for <code>x</code> and <code>y</code> but they do not fire events, and the
class is not serializable. Bound is an aspect that makes <code>Point</code> a
serializable class and makes its <code>get</code> and <code>set</code> methods support the
bound property protocol.</p>
</div>
<div class="sect4">
<h5 id="_the_point_class_2">The <code>Point</code> class</h5>
<div class="paragraph">
<p>The <code>Point</code> class is a very simple class with trivial getters and
setters, and a simple vector offset method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">Point</span> {

  <span class="directive">protected</span> <span class="type">int</span> x = <span class="integer">0</span>;
  <span class="directive">protected</span> <span class="type">int</span> y = <span class="integer">0</span>;

  <span class="directive">public</span> <span class="type">int</span> getX() {
    <span class="keyword">return</span> x;
  }

  <span class="directive">public</span> <span class="type">int</span> getY() {
    <span class="keyword">return</span> y;
  }

  <span class="directive">public</span> <span class="type">void</span> setRectangular(<span class="type">int</span> newX, <span class="type">int</span> newY) {
    setX(newX);
    setY(newY);
  }

  <span class="directive">public</span> <span class="type">void</span> setX(<span class="type">int</span> newX) {
    x = newX;
  }

  <span class="directive">public</span> <span class="type">void</span> setY(<span class="type">int</span> newY) {
    y = newY;
  }

  <span class="directive">public</span> <span class="type">void</span> offset(<span class="type">int</span> deltaX, <span class="type">int</span> deltaY) {
    setRectangular(x + deltaX, y + deltaY);
  }

  <span class="directive">public</span> <span class="predefined-type">String</span> toString() {
    <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">(</span><span class="delimiter">&quot;</span></span> + getX() + <span class="string"><span class="delimiter">&quot;</span><span class="content">, </span><span class="delimiter">&quot;</span></span> + getY() + <span class="string"><span class="delimiter">&quot;</span><span class="content">)</span><span class="delimiter">&quot;</span></span> ;
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_the_boundpoint_aspect">The <code>BoundPoint</code> aspect</h5>
<div class="paragraph">
<p>The <code>BoundPoint</code> aspect is responsible for <code>Point</code>'s "beanness". The
first thing it does is privately declare that each <code>Point</code> has a
<code>support</code> field that holds reference to an instance of
<code>PropertyChangeSupport</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">private</span> <span class="predefined-type">PropertyChangeSupport</span> <span class="predefined-type">Point</span>.support = <span class="keyword">new</span> <span class="predefined-type">PropertyChangeSupport</span>(<span class="local-variable">this</span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The property change support object must be constructed with a reference
to the bean for which it is providing support, so it is initialized by
passing it <code>this</code>, an instance of <code>Point</code>. Since the <code>support</code> field is
private declared in the aspect, only the code in the aspect can refer to
it.</p>
</div>
<div class="paragraph">
<p>The aspect also declares <code>Point</code>'s methods for registering and managing
listeners for property change events, which delegate the work to the
property change support object:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">void</span> <span class="predefined-type">Point</span>.addPropertyChangeListener(<span class="predefined-type">PropertyChangeListener</span> listener){
  support.addPropertyChangeListener(listener);
}
<span class="directive">public</span> <span class="type">void</span> <span class="predefined-type">Point</span>.addPropertyChangeListener(<span class="predefined-type">String</span> propertyName, <span class="predefined-type">PropertyChangeListener</span> listener) {
  support.addPropertyChangeListener(propertyName, listener);
}
<span class="directive">public</span> <span class="type">void</span> <span class="predefined-type">Point</span>.removePropertyChangeListener(<span class="predefined-type">String</span> propertyName, <span class="predefined-type">PropertyChangeListener</span> listener) {
  support.removePropertyChangeListener(propertyName, listener);
}
<span class="directive">public</span> <span class="type">void</span> <span class="predefined-type">Point</span>.removePropertyChangeListener(<span class="predefined-type">PropertyChangeListener</span> listener) {
  support.removePropertyChangeListener(listener);
}
<span class="directive">public</span> <span class="type">void</span> <span class="predefined-type">Point</span>.hasListeners(<span class="predefined-type">String</span> propertyName) {
  support.hasListeners(propertyName);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The aspect is also responsible for making sure <code>Point</code> implements the
<code>Serializable</code> interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">declare parents: <span class="predefined-type">Point</span> <span class="directive">implements</span> <span class="predefined-type">Serializable</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Implementing this interface in Java does not require any methods to be
implemented. Serialization for <code>Point</code> objects is provided by the
default serialization method.</p>
</div>
<div class="paragraph">
<p>The <code>setters</code> pointcut picks out calls to the <code>Point</code>'s <code>set</code> methods:
any method whose name begins with &#8220;set&#8221; and takes one parameter. The
around advice on <code>setters()</code> stores the values of the <code>X</code> and <code>Y</code>
properties, calls the original <code>set</code> method and then fires the
appropriate property change event according to which set method was
called.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect BoundPoint {
  <span class="directive">private</span> <span class="predefined-type">PropertyChangeSupport</span> <span class="predefined-type">Point</span>.support = <span class="keyword">new</span> <span class="predefined-type">PropertyChangeSupport</span>(<span class="local-variable">this</span>);

  <span class="directive">public</span> <span class="type">void</span> <span class="predefined-type">Point</span>.addPropertyChangeListener(<span class="predefined-type">PropertyChangeListener</span> listener) {
    support.addPropertyChangeListener(listener);
  }
  <span class="directive">public</span> <span class="type">void</span> <span class="predefined-type">Point</span>.addPropertyChangeListener(<span class="predefined-type">String</span> propertyName, <span class="predefined-type">PropertyChangeListener</span> listener) {
    support.addPropertyChangeListener(propertyName, listener);
  }
  <span class="directive">public</span> <span class="type">void</span> <span class="predefined-type">Point</span>.removePropertyChangeListener(<span class="predefined-type">String</span> propertyName, <span class="predefined-type">PropertyChangeListener</span> listener) {
    support.removePropertyChangeListener(propertyName, listener);
  }
  <span class="directive">public</span> <span class="type">void</span> <span class="predefined-type">Point</span>.removePropertyChangeListener(<span class="predefined-type">PropertyChangeListener</span> listener) {
    support.removePropertyChangeListener(listener);
  }
  <span class="directive">public</span> <span class="type">void</span> <span class="predefined-type">Point</span>.hasListeners(<span class="predefined-type">String</span> propertyName) {
    support.hasListeners(propertyName);
  }

  declare parents: <span class="predefined-type">Point</span> <span class="directive">implements</span> <span class="predefined-type">Serializable</span>;

  pointcut setter(<span class="predefined-type">Point</span> p): call(<span class="type">void</span> <span class="predefined-type">Point</span>.set*(*)) &amp;&amp; target(p);

  <span class="type">void</span> around(<span class="predefined-type">Point</span> p): setter(p) {
    <span class="predefined-type">String</span> propertyName =
    thisJoinPointStaticPart.getSignature().getName().substring(<span class="string"><span class="delimiter">&quot;</span><span class="content">set</span><span class="delimiter">&quot;</span></span>.length());
    <span class="type">int</span> oldX = p.getX();
    <span class="type">int</span> oldY = p.getY();
    proceed(p);
    <span class="keyword">if</span> (propertyName.equals(<span class="string"><span class="delimiter">&quot;</span><span class="content">X</span><span class="delimiter">&quot;</span></span>)){
      firePropertyChange(p, propertyName, oldX, p.getX());
    } <span class="keyword">else</span> {
      firePropertyChange(p, propertyName, oldY, p.getY());
    }
  }

  <span class="type">void</span> firePropertyChange(<span class="predefined-type">Point</span> p, <span class="predefined-type">String</span> property, <span class="type">double</span> oldval, <span class="type">double</span> newval) {
    p.support.firePropertyChange(property, <span class="keyword">new</span> <span class="predefined-type">Double</span>(oldval), <span class="keyword">new</span> <span class="predefined-type">Double</span>(newval));
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_the_test_program">The Test Program</h5>
<div class="paragraph">
<p>The test program registers itself as a property change listener to a
<code>Point</code> object that it creates and then performs simple manipulation of
that point: calling its set methods and the offset method. Then it
serializes the point and writes it to a file and then reads it back. The
result of saving and restoring the point is that a new point is created.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">Demo</span> <span class="directive">implements</span> <span class="predefined-type">PropertyChangeListener</span> {

  <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">String</span> fileName = <span class="string"><span class="delimiter">&quot;</span><span class="content">test.tmp</span><span class="delimiter">&quot;</span></span>;

  <span class="directive">public</span> <span class="type">void</span> propertyChange(<span class="predefined-type">PropertyChangeEvent</span> e){
    <span class="predefined-type">System</span>.out.println(
      <span class="string"><span class="delimiter">&quot;</span><span class="content">Property </span><span class="delimiter">&quot;</span></span> + e.getPropertyName() + <span class="string"><span class="delimiter">&quot;</span><span class="content"> changed from </span><span class="delimiter">&quot;</span></span> +
      e.getOldValue() + <span class="string"><span class="delimiter">&quot;</span><span class="content"> to </span><span class="delimiter">&quot;</span></span> + e.getNewValue()
    );
  }

  <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
    <span class="predefined-type">Point</span> p1 = <span class="keyword">new</span> <span class="predefined-type">Point</span>();
    p1.addPropertyChangeListener(<span class="keyword">new</span> Demo());
    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">p1 =</span><span class="delimiter">&quot;</span></span> + p1);
    p1.setRectangular(<span class="integer">5</span>,<span class="integer">2</span>);
    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">p1 =</span><span class="delimiter">&quot;</span></span> + p1);
    p1.setX( <span class="integer">6</span> );
    p1.setY( <span class="integer">3</span> );
    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">p1 =</span><span class="delimiter">&quot;</span></span> + p1);
    p1.offset(<span class="integer">6</span>,<span class="integer">4</span>);
    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">p1 =</span><span class="delimiter">&quot;</span></span> + p1);
    save(p1, fileName);
    <span class="predefined-type">Point</span> p2 = (<span class="predefined-type">Point</span>) restore(fileName);
    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Had: </span><span class="delimiter">&quot;</span></span> + p1);
    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Got: </span><span class="delimiter">&quot;</span></span> + p2);
  }
  <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_compiling_and_running_the_example">Compiling and Running the Example</h5>
<div class="paragraph">
<p>To compile and run this example, go to the examples directory and type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">ajc -argfile bean/files.lst
java bean.Demo</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="the-subject-observer-protocol">The Subject/Observer Protocol</h4>
<div class="paragraph">
<p>(The code for this example is in <code>InstallDir/examples/observer</code>.)</p>
</div>
<div class="paragraph">
<p>This demo illustrates how the Subject/Observer design pattern can be
coded with aspects.</p>
</div>
<div class="paragraph">
<p>The demo consists of the following: A colored label is a renderable
object that has a color that cycles through a set of colors, and a
number that records the number of cycles it has been through. A button
is an action item that records when it is clicked.</p>
</div>
<div class="paragraph">
<p>With these two kinds of objects, we can build up a Subject/Observer
relationship in which colored labels observe the clicks of buttons; that
is, where colored labels are the observers and buttons are the subjects.</p>
</div>
<div class="paragraph">
<p>The demo is designed and implemented using the Subject/Observer design
pattern. The remainder of this example explains the classes and aspects
of this demo, and tells you how to run it.</p>
</div>
<div class="sect4">
<h5 id="_generic_components">Generic Components</h5>
<div class="paragraph">
<p>The generic parts of the protocol are the interfaces <code>Subject</code> and
<code>Observer</code>, and the abstract aspect <code>SubjectObserverProtocol</code>. The
<code>Subject</code> interface is simple, containing methods to add, remove, and
view <code>Observer</code> objects, and a method for getting data about state
changes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">interface</span> <span class="class">Subject</span> {
  <span class="type">void</span> addObserver(<span class="predefined-type">Observer</span> obs);
  <span class="type">void</span> removeObserver(<span class="predefined-type">Observer</span> obs);
  <span class="predefined-type">Vector</span> getObservers();
  <span class="predefined-type">Object</span> getData();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Observer</code> interface is just as simple, with methods to set and get
<code>Subject</code> objects, and a method to call when the subject gets updated.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">interface</span> <span class="class">Observer</span> {
  <span class="type">void</span> setSubject(<span class="predefined-type">Subject</span> s);
  <span class="predefined-type">Subject</span> getSubject();
  <span class="type">void</span> update();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>SubjectObserverProtocol</code> aspect contains within it all of the
generic parts of the protocol, namely, how to fire the <code>Observer</code>
objects' update methods when some state changes in a subject.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">abstract</span> aspect SubjectObserverProtocol {

  <span class="directive">abstract</span> pointcut stateChanges(<span class="predefined-type">Subject</span> s);

  after(<span class="predefined-type">Subject</span> s): stateChanges(s) {
    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="integer">0</span>; i &lt; s.getObservers().size(); i++) {
      ((<span class="predefined-type">Observer</span>)s.getObservers().elementAt(i)).update();
    }
  }

  <span class="directive">private</span> <span class="predefined-type">Vector</span> <span class="predefined-type">Subject</span>.observers = <span class="keyword">new</span> <span class="predefined-type">Vector</span>();
  <span class="directive">public</span> <span class="type">void</span>    <span class="predefined-type">Subject</span>.addObserver(<span class="predefined-type">Observer</span> obs) {
    observers.addElement(obs);
    obs.setSubject(<span class="local-variable">this</span>);
  }
  <span class="directive">public</span> <span class="type">void</span>    <span class="predefined-type">Subject</span>.removeObserver(<span class="predefined-type">Observer</span> obs) {
    observers.removeElement(obs);
    obs.setSubject(<span class="predefined-constant">null</span>);
  }
  <span class="directive">public</span> <span class="predefined-type">Vector</span>  <span class="predefined-type">Subject</span>.getObservers() { <span class="keyword">return</span> observers; }

  <span class="directive">private</span> <span class="predefined-type">Subject</span> <span class="predefined-type">Observer</span>.subject = <span class="predefined-constant">null</span>;
  <span class="directive">public</span> <span class="type">void</span>     <span class="predefined-type">Observer</span>.setSubject(<span class="predefined-type">Subject</span> s) { subject = s; }
  <span class="directive">public</span> <span class="predefined-type">Subject</span>  <span class="predefined-type">Observer</span>.getSubject() { <span class="keyword">return</span> subject; }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that this aspect does three things. It define an abstract pointcut
that extending aspects can override. It defines advice that should run
after the join points of the pointcut. And it declares an inter-type
field and two inter-type methods so that each <code>Observer</code> can hold onto
its <code>Subject</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_application_classes">Application Classes</h5>
<div class="paragraph">
<p><code>Button</code> objects extend <code>java.awt.Button</code>, and all they do is make sure
the <code>void click()</code> method is called whenever a button is clicked.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">Button</span> <span class="directive">extends</span> java.awt.Button {

  <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">Color</span>  defaultBackgroundColor = <span class="predefined-type">Color</span>.gray;
  <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">Color</span>  defaultForegroundColor = <span class="predefined-type">Color</span>.black;
  <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">String</span> defaultText = <span class="string"><span class="delimiter">&quot;</span><span class="content">cycle color</span><span class="delimiter">&quot;</span></span>;

  <span class="predefined-type">Button</span>(Display display) {
    <span class="local-variable">super</span>();
    setLabel(defaultText);
    setBackground(defaultBackgroundColor);
    setForeground(defaultForegroundColor);
    addActionListener(<span class="keyword">new</span> <span class="predefined-type">ActionListener</span>() {
      <span class="directive">public</span> <span class="type">void</span> actionPerformed(<span class="predefined-type">ActionEvent</span> e) {
        <span class="predefined-type">Button</span>.this.click();
      }
    });
    display.addToFrame(<span class="local-variable">this</span>);
  }

  <span class="directive">public</span> <span class="type">void</span> click() {}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that this class knows nothing about being a Subject.</p>
</div>
<div class="paragraph">
<p>ColorLabel objects are labels that support the void colorCycle() method.
Again, they know nothing about being an observer.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">ColorLabel</span> <span class="directive">extends</span> <span class="predefined-type">Label</span> {

  ColorLabel(Display display) {
    <span class="local-variable">super</span>();
    display.addToFrame(<span class="local-variable">this</span>);
  }

  <span class="directive">final</span> <span class="directive">static</span> <span class="predefined-type">Color</span><span class="type">[]</span> colors =
    { <span class="predefined-type">Color</span>.red, <span class="predefined-type">Color</span>.blue, <span class="predefined-type">Color</span>.green, <span class="predefined-type">Color</span>.magenta };
  <span class="directive">private</span> <span class="type">int</span> colorIndex = <span class="integer">0</span>;
  <span class="directive">private</span> <span class="type">int</span> cycleCount = <span class="integer">0</span>;
  <span class="type">void</span> colorCycle() {
    cycleCount++;
    colorIndex = (colorIndex + <span class="integer">1</span>) % colors.length;
    setBackground(colors[colorIndex]);
    setText(<span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span> + cycleCount);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, the <code>SubjectObserverProtocolImpl</code> implements the
subject/observer protocol, with <code>Button</code> objects as subjects and
<code>ColorLabel</code> objects as observers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">observer</span>;

<span class="keyword">import</span> <span class="include">java.util.Vector</span>;

aspect SubjectObserverProtocolImpl <span class="directive">extends</span> SubjectObserverProtocol {

  declare parents: <span class="predefined-type">Button</span> <span class="directive">implements</span> <span class="predefined-type">Subject</span>;
  <span class="directive">public</span> <span class="predefined-type">Object</span>    <span class="predefined-type">Button</span>.getData() { <span class="keyword">return</span> <span class="local-variable">this</span>; }

  declare parents: ColorLabel <span class="directive">implements</span> <span class="predefined-type">Observer</span>;
  <span class="directive">public</span> <span class="type">void</span>      ColorLabel.update() {
    colorCycle();
  }

  pointcut stateChanges(<span class="predefined-type">Subject</span> s):
    target(s) &amp;&amp;
    call(<span class="type">void</span> <span class="predefined-type">Button</span>.click());

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It does this by assuring that <code>Button</code> and <code>ColorLabel</code> implement the
appropriate interfaces, declaring that they implement the methods
required by those interfaces, and providing a definition for the
abstract <code>stateChanges</code> pointcut. Now, every time a <code>Button</code> is clicked,
all <code>ColorLabel</code> objects observing that button will <code>colorCycle</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_compiling_and_running">Compiling and Running</h5>
<div class="paragraph">
<p><code>Demo</code> is the top class that starts this demo. It instantiates a two
buttons and three observers and links them together as subjects and
observers. So to run the demo, go to the <code>examples</code> directory and type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">ajc -argfile observer/files.lst
java observer.Demo</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_a_simple_telecom_simulation">A Simple Telecom Simulation</h4>
<div class="paragraph">
<p>(The code for this example is in <code>InstallDir/examples/telecom</code>.)</p>
</div>
<div class="paragraph">
<p>This example illustrates some ways that dependent concerns can be
encoded with aspects. It uses an example system comprising a simple
model of telephone connections to which timing and billing features are
added using aspects, where the billing feature depends upon the timing
feature.</p>
</div>
<div class="sect4">
<h5 id="_the_application">The Application</h5>
<div class="paragraph">
<p>The example application is a simple simulation of a telephony system in
which customers make, accept, merge and hang-up both local and long
distance calls. The application architecture is in three layers.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The basic objects provide basic functionality to simulate customers,
calls and connections (regular calls have one connection, conference
calls have more than one).</p>
</li>
<li>
<p>The timing feature is concerned with timing the connections and
keeping the total connection time per customer. Aspects are used to add
a timer to each connection and to manage the total time per customer.</p>
</li>
<li>
<p>The billing feature is concerned with charging customers for the calls
they make. Aspects are used to calculate a charge per connection and,
upon termination of a connection, to add the charge to the appropriate
customer&#8217;s bill. The billing aspect builds upon the timing aspect: it
uses a pointcut defined in Timing and it uses the timers that are
associated with connections.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The simulation of system has three configurations: basic, timing and
billing. Programs for the three configurations are in classes
<code>BasicSimulation</code>, <code>TimingSimulation</code> and <code>BillingSimulation</code>. These
share a common superclass <code>AbstractSimulation</code>, which defines the method
run with the simulation itself and the method wait used to simulate
elapsed time.</p>
</div>
</div>
<div class="sect4">
<h5 id="_the_basic_objects">The Basic Objects</h5>
<div class="paragraph">
<p>The telecom simulation comprises the classes <code>Customer</code>, <code>Call</code> and the
abstract class <code>Connection</code> with its two concrete subclasses <code>Local</code> and
<code>LongDistance</code>. Customers have a name and a numeric area code. They also
have methods for managing calls. Simple calls are made between one
customer (the caller) and another (the receiver), a <code>Connection</code> object
is used to connect them. Conference calls between more than two
customers will involve more than one connection. A customer may be
involved in many calls at one time.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/telecom.png" alt="image"></span></p>
</div>
</div>
<div class="sect4">
<h5 id="_the_customer_class">The <code>Customer</code> class</h5>
<div class="paragraph">
<p><code>Customer</code> has methods <code>call</code>, <code>pickup</code>, <code>hangup</code> and <code>merge</code> for
managing calls.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Customer</span> {

  <span class="directive">private</span> <span class="predefined-type">String</span> name;
  <span class="directive">private</span> <span class="type">int</span> areacode;
  <span class="directive">private</span> <span class="predefined-type">Vector</span> calls = <span class="keyword">new</span> <span class="predefined-type">Vector</span>();

  <span class="directive">protected</span> <span class="type">void</span> removeCall(Call c){
    calls.removeElement(c);
  }

  <span class="directive">protected</span> <span class="type">void</span> addCall(Call c){
    calls.addElement(c);
  }

  <span class="directive">public</span> Customer(<span class="predefined-type">String</span> name, <span class="type">int</span> areacode) {
    <span class="local-variable">this</span>.name = name;
    <span class="local-variable">this</span>.areacode = areacode;
  }

  <span class="directive">public</span> <span class="predefined-type">String</span> toString() {
    <span class="keyword">return</span> name + <span class="string"><span class="delimiter">&quot;</span><span class="content">(</span><span class="delimiter">&quot;</span></span> + areacode + <span class="string"><span class="delimiter">&quot;</span><span class="content">)</span><span class="delimiter">&quot;</span></span>;
  }

  <span class="directive">public</span> <span class="type">int</span> getAreacode(){
    <span class="keyword">return</span> areacode;
  }

  <span class="directive">public</span> <span class="type">boolean</span> localTo(Customer other){
    <span class="keyword">return</span> areacode == other.areacode;
  }

  <span class="directive">public</span> Call call(Customer receiver) {
    Call call = <span class="keyword">new</span> Call(<span class="local-variable">this</span>, receiver);
    addCall(call);
    <span class="keyword">return</span> call;
  }

  <span class="directive">public</span> <span class="type">void</span> pickup(Call call) {
    call.pickup();
    addCall(call);
  }

  <span class="directive">public</span> <span class="type">void</span> hangup(Call call) {
    call.hangup(<span class="local-variable">this</span>);
    removeCall(call);
  }

  <span class="directive">public</span> <span class="type">void</span> merge(Call call1, Call call2){
    call1.merge(call2);
    removeCall(call2);
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_the_call_class">The <code>Call</code> class</h5>
<div class="paragraph">
<p>Calls are created with a caller and receiver who are customers. If the
caller and receiver have the same area code then the call can be
established with a <code>Local</code> connection (see below), otherwise a
<code>LongDistance</code> connection is required. A call comprises a number of
connections between customers. Initially there is only the connection
between the caller and receiver but additional connections can be added
if calls are merged to form conference calls.</p>
</div>
</div>
<div class="sect4">
<h5 id="_the_connection_class">The <code>Connection</code> class</h5>
<div class="paragraph">
<p>The class <code>Connection</code> models the physical details of establishing a
connection between customers. It does this with a simple state machine
(connections are initially <code>PENDING</code>, then <code>COMPLETED</code> and finally
<code>DROPPED</code>). Messages are printed to the console so that the state of
connections can be observed. Connection is an abstract class with two
concrete subclasses: <code>Local</code> and <code>LongDistance</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">abstract</span> <span class="type">class</span> <span class="class">Connection</span> {

  <span class="directive">public</span> <span class="directive">static</span> <span class="directive">final</span> <span class="type">int</span> PENDING = <span class="integer">0</span>;
  <span class="directive">public</span> <span class="directive">static</span> <span class="directive">final</span> <span class="type">int</span> COMPLETE = <span class="integer">1</span>;
  <span class="directive">public</span> <span class="directive">static</span> <span class="directive">final</span> <span class="type">int</span> DROPPED = <span class="integer">2</span>;

  Customer caller, receiver;
  <span class="directive">private</span> <span class="type">int</span> state = PENDING;

  <span class="predefined-type">Connection</span>(Customer a, Customer b) {
    <span class="local-variable">this</span>.caller = a;
    <span class="local-variable">this</span>.receiver = b;
  }

  <span class="directive">public</span> <span class="type">int</span> getState(){
    <span class="keyword">return</span> state;
  }

  <span class="directive">public</span> Customer getCaller() { <span class="keyword">return</span> caller; }

  <span class="directive">public</span> Customer getReceiver() { <span class="keyword">return</span> receiver; }

  <span class="type">void</span> complete() {
    state = COMPLETE;
    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">connection completed</span><span class="delimiter">&quot;</span></span>);
  }

  <span class="type">void</span> drop() {
    state = DROPPED;
    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">connection dropped</span><span class="delimiter">&quot;</span></span>);
  }

  <span class="directive">public</span> <span class="type">boolean</span> connects(Customer c){
    <span class="keyword">return</span> (caller == c || receiver == c);
  }

}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_the_local_and_longdistance_classes">The <code>Local</code> and <code>LongDistance</code> classes</h5>
<div class="paragraph">
<p>The two kinds of connections supported by our simulation are <code>Local</code> and
<code>LongDistance</code> connections.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">Local</span> <span class="directive">extends</span> <span class="predefined-type">Connection</span> {
  Local(Customer a, Customer b) {
    <span class="local-variable">super</span>(a, b);
    <span class="predefined-type">System</span>.out.println(
      <span class="string"><span class="delimiter">&quot;</span><span class="content">[new local connection from </span><span class="delimiter">&quot;</span></span> + a + <span class="string"><span class="delimiter">&quot;</span><span class="content"> to </span><span class="delimiter">&quot;</span></span> + b + <span class="string"><span class="delimiter">&quot;</span><span class="content">]</span><span class="delimiter">&quot;</span></span>
    );
  }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">LongDistance</span> <span class="directive">extends</span> <span class="predefined-type">Connection</span> {
  LongDistance(Customer a, Customer b) {
    <span class="local-variable">super</span>(a, b);
    <span class="predefined-type">System</span>.out.println(
      <span class="string"><span class="delimiter">&quot;</span><span class="content">[new long distance connection from </span><span class="delimiter">&quot;</span></span> + a + <span class="string"><span class="delimiter">&quot;</span><span class="content"> to </span><span class="delimiter">&quot;</span></span> + b + <span class="string"><span class="delimiter">&quot;</span><span class="content">]</span><span class="delimiter">&quot;</span></span>
    );
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_compiling_and_running_the_basic_simulation">Compiling and Running the Basic Simulation</h5>
<div class="paragraph">
<p>The source files for the basic system are listed in the file
<code>basic.lst</code>. To build and run the basic system, in a shell window, type
these commands:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">ajc -argfile telecom/basic.lst
java telecom.BasicSimulation</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_the_timing_aspect">The Timing aspect</h5>
<div class="paragraph">
<p>The <code>Timing</code> aspect keeps track of total connection time for each
<code>Customer</code> by starting and stopping a timer associated with each
connection. It uses some helper classes:</p>
</div>
<div class="sect5">
<h6 id="_the_timer_class">The <code>Timer</code> class</h6>
<div class="paragraph">
<p>A <code>Timer</code> object simply records the current time when it is started and
stopped, and returns their difference when asked for the elapsed time.
The aspect <code>TimerLog</code> (below) can be used to cause the start and stop
times to be printed to standard output.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">Timer</span> {
  <span class="type">long</span> startTime, stopTime;

  <span class="directive">public</span> <span class="type">void</span> start() {
    startTime = <span class="predefined-type">System</span>.currentTimeMillis();
    stopTime = startTime;
  }

  <span class="directive">public</span> <span class="type">void</span> stop() {
    stopTime = <span class="predefined-type">System</span>.currentTimeMillis();
  }

  <span class="directive">public</span> <span class="type">long</span> getTime() {
    <span class="keyword">return</span> stopTime - startTime;
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_the_timerlog_aspect">The <code>TimerLog</code> aspect</h5>
<div class="paragraph">
<p>The <code>TimerLog</code> aspect can be included in a build to get the timer to
announce when it is started and stopped.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> aspect TimerLog {

  after(<span class="predefined-type">Timer</span> t): target(t) &amp;&amp; call(* <span class="predefined-type">Timer</span>.start())  {
    <span class="predefined-type">System</span>.err.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Timer started: </span><span class="delimiter">&quot;</span></span> + t.startTime);
  }

  after(<span class="predefined-type">Timer</span> t): target(t) &amp;&amp; call(* <span class="predefined-type">Timer</span>.stop()) {
    <span class="predefined-type">System</span>.err.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Timer stopped: </span><span class="delimiter">&quot;</span></span> + t.stopTime);
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_the_timing_aspect_2">The <code>Timing</code> aspect</h5>
<div class="paragraph">
<p>The <code>Timing</code> aspect is declares an inter-type field <code>totalConnectTime</code>
for <code>Customer</code> to store the accumulated connection time per <code>Customer</code>.
It also declares that each <code>Connection</code> object has a timer.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">long</span> Customer.totalConnectTime = <span class="integer">0</span>;
<span class="directive">private</span> <span class="predefined-type">Timer</span> <span class="predefined-type">Connection</span>.timer = <span class="keyword">new</span> <span class="predefined-type">Timer</span>();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Two pieces of after advice ensure that the timer is started when a
connection is completed and and stopped when it is dropped. The pointcut
<code>endTiming</code> is defined so that it can be used by the <code>Billing</code> aspect.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> aspect Timing {

  <span class="directive">public</span> <span class="type">long</span> Customer.totalConnectTime = <span class="integer">0</span>;

  <span class="directive">public</span> <span class="type">long</span> getTotalConnectTime(Customer cust) {
    <span class="keyword">return</span> cust.totalConnectTime;
  }
  <span class="directive">private</span> <span class="predefined-type">Timer</span> <span class="predefined-type">Connection</span>.timer = <span class="keyword">new</span> <span class="predefined-type">Timer</span>();
  <span class="directive">public</span> <span class="predefined-type">Timer</span> getTimer(<span class="predefined-type">Connection</span> conn) { <span class="keyword">return</span> conn.timer; }

  after (<span class="predefined-type">Connection</span> c): target(c) &amp;&amp; call(<span class="type">void</span> <span class="predefined-type">Connection</span>.complete()) {
    getTimer(c).start();
  }

  pointcut endTiming(<span class="predefined-type">Connection</span> c): target(c) &amp;&amp;
    call(<span class="type">void</span> <span class="predefined-type">Connection</span>.drop());

  after(<span class="predefined-type">Connection</span> c): endTiming(c) {
    getTimer(c).stop();
    c.getCaller().totalConnectTime += getTimer(c).getTime();
    c.getReceiver().totalConnectTime += getTimer(c).getTime();
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_the_billing_aspect">The <code>Billing</code> aspect</h5>
<div class="paragraph">
<p>The Billing system adds billing functionality to the telecom application
on top of timing.</p>
</div>
<div class="paragraph">
<p>The <code>Billing</code> aspect declares that each <code>Connection</code> has a <code>payer</code>
inter-type field to indicate who initiated the call and therefore who is
responsible to pay for it. It also declares the inter-type method
<code>callRate</code> of <code>Connection</code> so that local and long distance calls can be
charged differently. The call charge must be calculated after the timer
is stopped; the after advice on pointcut <code>Timing.endTiming</code> does this,
and <code>Billing</code> is declared to be more precedent than <code>Timing</code> to make
sure that this advice runs after <code>Timing</code>'s advice on the same join
point. Finally, it declares inter-type methods and fields for <code>Customer</code>
to handle the <code>totalCharge</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> aspect Billing {
  <span class="comment">// precedence required to get advice on endtiming in the right order</span>
  declare precedence: Billing, Timing;

  <span class="directive">public</span> <span class="directive">static</span> <span class="directive">final</span> <span class="type">long</span> LOCAL_RATE = <span class="integer">3</span>;
  <span class="directive">public</span> <span class="directive">static</span> <span class="directive">final</span> <span class="type">long</span> LONG_DISTANCE_RATE = <span class="integer">10</span>;

  <span class="directive">public</span> Customer <span class="predefined-type">Connection</span>.payer;
  <span class="directive">public</span> Customer getPayer(<span class="predefined-type">Connection</span> conn) { <span class="keyword">return</span> conn.payer; }

  after(Customer cust) returning (<span class="predefined-type">Connection</span> conn):
  args(cust, ..) &amp;&amp; call(<span class="predefined-type">Connection</span>+.new(..)) {
    conn.payer = cust;
  }

  <span class="directive">public</span> <span class="directive">abstract</span> <span class="type">long</span> <span class="predefined-type">Connection</span>.callRate();

  <span class="directive">public</span> <span class="type">long</span> LongDistance.callRate() { <span class="keyword">return</span> LONG_DISTANCE_RATE; }
  <span class="directive">public</span> <span class="type">long</span> Local.callRate() { <span class="keyword">return</span> LOCAL_RATE; }

  after(<span class="predefined-type">Connection</span> conn): Timing.endTiming(conn) {
    <span class="type">long</span> time = Timing.aspectOf().getTimer(conn).getTime();
    <span class="type">long</span> rate = conn.callRate();
    <span class="type">long</span> cost = rate * time;
    getPayer(conn).addCharge(cost);
  }

  <span class="directive">public</span> <span class="type">long</span> Customer.totalCharge = <span class="integer">0</span>;
  <span class="directive">public</span> <span class="type">long</span> getTotalCharge(Customer cust) { <span class="keyword">return</span> cust.totalCharge; }

  <span class="directive">public</span> <span class="type">void</span> Customer.addCharge(<span class="type">long</span> charge) {
    totalCharge += charge;
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_accessing_the_inter_type_state">Accessing the inter-type state</h5>
<div class="paragraph">
<p>Both the aspects <code>Timing</code> and <code>Billing</code> contain the definition of
operations that the rest of the system may want to access. For example,
when running the simulation with one or both aspects, we want to find
out how much time each customer spent on the telephone and how big their
bill is. That information is also stored in the classes, but they are
accessed through static methods of the aspects, since the state they
refer to is private to the aspect.</p>
</div>
<div class="paragraph">
<p>Take a look at the file <code>TimingSimulation.java</code>. The most important
method of this class is the method <code>report(Customer)</code>, which is used in
the method run of the superclass <code>AbstractSimulation</code>. This method is
intended to print out the status of the customer, with respect to the
<code>Timing</code> feature.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">protected</span> <span class="type">void</span> report(Customer c){
  Timing t = Timing.aspectOf();
  <span class="predefined-type">System</span>.out.println(c + <span class="string"><span class="delimiter">&quot;</span><span class="content"> spent </span><span class="delimiter">&quot;</span></span> + t.getTotalConnectTime(c));
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_compiling_and_running_2">Compiling and Running</h5>
<div class="paragraph">
<p>The files timing.lst and billing.lst contain file lists for the timing
and billing configurations. To build and run the application with only
the timing feature, go to the directory examples and type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">ajc -argfile telecom/timing.lst
java telecom.TimingSimulation</code></pre>
</div>
</div>
<div class="paragraph">
<p>To build and run the application with the timing and billing features,
go to the directory examples and type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">ajc -argfile telecom/billing.lst
java telecom.BillingSimulation</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_discussion">Discussion</h5>
<div class="paragraph">
<p>There are some explicit dependencies between the aspects <code>Billing</code> and
<code>Timing</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Billing</code> is declared more precedent than <code>Timing</code> so that <code>Billing</code>'s after
advice runs after that of <code>Timing</code> when they are on the same join point.</p>
</li>
<li>
<p><code>Billing</code> uses the pointcut <code>Timing.endTiming</code>.</p>
</li>
<li>
<p><code>Billing</code> needs access to the timer associated with a connection.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="examples-reusable">Reusable Aspects</h3>
<div class="sect3">
<h4 id="_tracing_using_aspects_revisited">Tracing using Aspects, Revisited</h4>
<div class="paragraph">
<p>(The code for this example is in <code>InstallDir/examples/tracing</code>.)</p>
</div>
<div class="sect4">
<h5 id="_tracing_version_3">Tracing - Version 3</h5>
<div class="paragraph">
<p>One advantage of not exposing the methods <code>traceEntry</code> and <code>traceExit</code> as
public operations is that we can easily change their interface without
any dramatic consequences in the rest of the code.</p>
</div>
<div class="paragraph">
<p>Consider, again, the program without AspectJ. Suppose, for example, that
at some point later the requirements for tracing change, stating that
the trace messages should always include the string representation of
the object whose methods are being traced. This can be achieved in at
least two ways. One way is keep the interface of the methods
<code>traceEntry</code> and <code>traceExit</code> as it was before,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> traceEntry(<span class="predefined-type">String</span> str);
<span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> traceExit(<span class="predefined-type">String</span> str);</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case, the caller is responsible for ensuring that the string
representation of the object is part of the string given as argument.
So, calls must look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Trace.traceEntry(<span class="string"><span class="delimiter">&quot;</span><span class="content">Square.distance in </span><span class="delimiter">&quot;</span></span> + toString());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Another way is to enforce the requirement with a second argument in the
trace operations, e.g.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> traceEntry(<span class="predefined-type">String</span> str, <span class="predefined-type">Object</span> obj);
<span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> traceExit(<span class="predefined-type">String</span> str, <span class="predefined-type">Object</span> obj);</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case, the caller is still responsible for sending the right
object, but at least there is some guarantees that some object will be
passed. The calls will look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Trace.traceEntry(<span class="string"><span class="delimiter">&quot;</span><span class="content">Square.distance</span><span class="delimiter">&quot;</span></span>, <span class="local-variable">this</span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>In either case, this change to the requirements of tracing will have
dramatic consequences in the rest of the code&#8201;&#8212;&#8201;every call to the trace
operations <code>traceEntry</code> and <code>traceExit</code> must be changed!</p>
</div>
<div class="paragraph">
<p>Here&#8217;s another advantage of doing tracing with an aspect. We&#8217;ve already
seen that in version 2 <code>traceEntry</code> and <code>traceExit</code> are not publicly
exposed. So changing their interfaces, or the way they are used, has
only a small effect inside the <code>Trace</code> class. Here&#8217;s a partial view at
the implementation of <code>Trace</code>, version 3. The differences with respect
to version 2 are stressed in the comments:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">abstract</span> aspect Trace {

  <span class="directive">public</span> <span class="directive">static</span> <span class="type">int</span> TRACELEVEL = <span class="integer">0</span>;
  <span class="directive">protected</span> <span class="directive">static</span> <span class="predefined-type">PrintStream</span> stream = <span class="predefined-constant">null</span>;
  <span class="directive">protected</span> <span class="directive">static</span> <span class="type">int</span> callDepth = <span class="integer">0</span>;

  <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> initStream(<span class="predefined-type">PrintStream</span> s) {
    stream = s;
  }

  <span class="directive">protected</span> <span class="directive">static</span> <span class="type">void</span> traceEntry(<span class="predefined-type">String</span> str, <span class="predefined-type">Object</span> o) {
    <span class="keyword">if</span> (TRACELEVEL == <span class="integer">0</span>) <span class="keyword">return</span>;
    <span class="keyword">if</span> (TRACELEVEL == <span class="integer">2</span>) callDepth++;
    printEntering(str + <span class="string"><span class="delimiter">&quot;</span><span class="content">: </span><span class="delimiter">&quot;</span></span> + o.toString());
  }

  <span class="directive">protected</span> <span class="directive">static</span> <span class="type">void</span> traceExit(<span class="predefined-type">String</span> str, <span class="predefined-type">Object</span> o) {
    <span class="keyword">if</span> (TRACELEVEL == <span class="integer">0</span>) <span class="keyword">return</span>;
    printExiting(str + <span class="string"><span class="delimiter">&quot;</span><span class="content">: </span><span class="delimiter">&quot;</span></span> + o.toString());
    <span class="keyword">if</span> (TRACELEVEL == <span class="integer">2</span>) callDepth--;
  }

  <span class="directive">private</span> <span class="directive">static</span> <span class="type">void</span> printEntering(<span class="predefined-type">String</span> str) {
    printIndent();
    stream.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Entering </span><span class="delimiter">&quot;</span></span> + str);
  }

  <span class="directive">private</span> <span class="directive">static</span> <span class="type">void</span> printExiting(<span class="predefined-type">String</span> str) {
    printIndent();
    stream.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Exiting </span><span class="delimiter">&quot;</span></span> + str);
  }

  <span class="directive">private</span> <span class="directive">static</span> <span class="type">void</span> printIndent() {
    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="integer">0</span>; i &lt; callDepth; i++)
      stream.print(<span class="string"><span class="delimiter">&quot;</span><span class="content">  </span><span class="delimiter">&quot;</span></span>);
  }

  <span class="directive">abstract</span> pointcut myClass(<span class="predefined-type">Object</span> obj);

  pointcut myConstructor(<span class="predefined-type">Object</span> obj): myClass(obj) &amp;&amp; execution(<span class="keyword">new</span>(..));
  pointcut myMethod(<span class="predefined-type">Object</span> obj):
    myClass(obj) &amp;&amp; execution(* *(..)) &amp;&amp; !execution(<span class="predefined-type">String</span> toString());

  before(<span class="predefined-type">Object</span> obj): myConstructor(obj) {
    traceEntry(<span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span> + thisJoinPointStaticPart.getSignature(), obj);
  }
  after(<span class="predefined-type">Object</span> obj): myConstructor(obj) {
    traceExit(<span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span> + thisJoinPointStaticPart.getSignature(), obj);
  }

  before(<span class="predefined-type">Object</span> obj): myMethod(obj) {
    traceEntry(<span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span> + thisJoinPointStaticPart.getSignature(), obj);
  }
  after(<span class="predefined-type">Object</span> obj): myMethod(obj) {
    traceExit(<span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span> + thisJoinPointStaticPart.getSignature(), obj);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, we decided to apply the first design by preserving the
interface of the methods <code>traceEntry</code> and <code>traceExit</code>. But it doesn&#8217;t
matter - we could as easily have applied the second design (the code in
the directory <code>examples/tracing/version3</code> has the second design). The
point is that the effects of this change in the tracing requirements are
limited to the <code>Trace</code> aspect class.</p>
</div>
<div class="paragraph">
<p>One implementation change worth noticing is the specification of the
pointcuts. They now expose the object. To maintain full consistency with
the behavior of version 2, we should have included tracing for static
methods, by defining another pointcut for static methods and advising
it. We leave that as an exercise.</p>
</div>
<div class="paragraph">
<p>Moreover, we had to exclude the execution join point of the method
<code>toString</code> from the <code>methods</code> pointcut. The problem here is that
<code>toString</code> is being called from inside the advice. Therefore if we trace
it, we will end up in an infinite recursion of calls. This is a subtle
point, and one that you must be aware when writing advice. If the advice
calls back to the objects, there is always the possibility of recursion.
Keep that in mind!</p>
</div>
<div class="paragraph">
<p>In fact, esimply excluding the execution join point may not be enough,
if there are calls to other traced methods within it - in which case,
the restriction should be</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">&amp;&amp; !cflow(execution(<span class="predefined-type">String</span> toString()))</code></pre>
</div>
</div>
<div class="paragraph">
<p>excluding both the execution of <code>toString</code> methods and all join points
under that execution.</p>
</div>
<div class="paragraph">
<p>In summary, to implement the change in the tracing requirements we had
to make a couple of changes in the implementation of the <code>Trace</code> aspect
class, including changing the specification of the pointcuts. That&#8217;s
only natural. But the implementation changes were limited to this
aspect. Without aspects, we would have to change the implementation of
every application class.</p>
</div>
<div class="paragraph">
<p>Finally, to run this version of tracing, go to the directory <code>examples</code>
and type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">ajc -argfile tracing/tracev3.lst</code></pre>
</div>
</div>
<div class="paragraph">
<p>The file <code>tracev3.lst</code> lists the application classes as well as this
version of the files <code>Trace.java</code> and <code>TraceMyClasses.java</code>. To run the
program, type</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">java tracing.version3.TraceMyClasses</code></pre>
</div>
</div>
<div class="paragraph">
<p>The output should be:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">  --&gt; tracing.TwoDShape(double, double)
  &lt;-- tracing.TwoDShape(double, double)
  --&gt; tracing.Circle(double, double, double)
  &lt;-- tracing.Circle(double, double, double)
  --&gt; tracing.TwoDShape(double, double)
  &lt;-- tracing.TwoDShape(double, double)
  --&gt; tracing.Circle(double, double, double)
  &lt;-- tracing.Circle(double, double, double)
  --&gt; tracing.Circle(double)
  &lt;-- tracing.Circle(double)
  --&gt; tracing.TwoDShape(double, double)
  &lt;-- tracing.TwoDShape(double, double)
  --&gt; tracing.Square(double, double, double)
  &lt;-- tracing.Square(double, double, double)
  --&gt; tracing.Square(double, double)
  &lt;-- tracing.Square(double, double)
  --&gt; double tracing.Circle.perimeter()
  &lt;-- double tracing.Circle.perimeter()
c1.perimeter() = 12.566370614359172
  --&gt; double tracing.Circle.area()
  &lt;-- double tracing.Circle.area()
c1.area() = 12.566370614359172
  --&gt; double tracing.Square.perimeter()
  &lt;-- double tracing.Square.perimeter()
s1.perimeter() = 4.0
  --&gt; double tracing.Square.area()
  &lt;-- double tracing.Square.area()
s1.area() = 1.0
  --&gt; double tracing.TwoDShape.distance(TwoDShape)
    --&gt; double tracing.TwoDShape.getX()
    &lt;-- double tracing.TwoDShape.getX()
    --&gt; double tracing.TwoDShape.getY()
    &lt;-- double tracing.TwoDShape.getY()
  &lt;-- double tracing.TwoDShape.distance(TwoDShape)
c2.distance(c1) = 4.242640687119285
  --&gt; double tracing.TwoDShape.distance(TwoDShape)
    --&gt; double tracing.TwoDShape.getX()
    &lt;-- double tracing.TwoDShape.getX()
    --&gt; double tracing.TwoDShape.getY()
    &lt;-- double tracing.TwoDShape.getY()
  &lt;-- double tracing.TwoDShape.distance(TwoDShape)
s1.distance(c1) = 2.23606797749979
  --&gt; String tracing.Square.toString()
    --&gt; String tracing.TwoDShape.toString()
    &lt;-- String tracing.TwoDShape.toString()
  &lt;-- String tracing.Square.toString()
s1.toString(): Square side = 1.0 @ (1.0, 2.0)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_idioms">Idioms</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="idioms-intro">Introduction</h3>
<div class="paragraph">
<p>This chapter consists of very short snippets of AspectJ code, typically
pointcuts, that are particularly evocative or useful. This section is a
work in progress.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s an example of how to enfore a rule that code in the <code>java.sql</code>
package can only be used from one particular package in your system.
This doesn&#8217;t require any access to code in the <code>java.sql</code> package.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">/* Any call to methods or constructors in java.sql */</span>
pointcut restrictedCall():
  call(* java.sql.*.*(..)) || call(java.sql.*.new(..));

<span class="comment">/* Any code in my system not in the sqlAccess package */</span>
pointcut illegalSource():
  within(com.foo..*) &amp;&amp; !within(com.foo.sqlAccess.*);

declare error: restrictedCall() &amp;&amp; illegalSource():
  <span class="string"><span class="delimiter">&quot;</span><span class="content">java.sql package can only be accessed from com.foo.sqlAccess</span><span class="delimiter">&quot;</span></span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Any call to an instance of a subtype of <code>AbstractFacade</code> whose class is
not exactly equal to <code>AbstractFacade</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">pointcut nonAbstract(AbstractFacade af):
  call(* *(..))
  &amp;&amp; target(af)
  &amp;&amp; !<span class="keyword">if</span>(af.getClass() == AbstractFacade.class);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>AbstractFacade</code> is an abstract class or an interface, then every
instance must be of a subtype and you can replace this with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">pointcut nonAbstract(AbstractFacade af):
  call(* *(..))
  &amp;&amp; target(af);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Any call to a method which is defined by a subtype of <code>AbstractFacade</code>,
but which isn&#8217;t defined by the type <code>AbstractFacade</code> itself:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">pointcut callToUndefinedMethod():
   call(* AbstractFacade+.*(..))
   &amp;&amp; !call(* AbstractFacade.*(..));</code></pre>
</div>
</div>
<div class="paragraph">
<p>The execution of a method that is defined in the source code for a type
that is a subtype of <code>AbstractFacade</code> but not in <code>AbstractFacade</code> itself:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">pointcut executionOfUndefinedMethod():
  execution(* *(..))
  &amp;&amp; within(AbstractFacade+)
  &amp;&amp; !within(AbstractFacade)</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_pitfalls">Pitfalls</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="pitfalls-intro">Introduction</h3>
<div class="paragraph">
<p>This chapter consists of a few AspectJ programs that may lead to
surprising behavior and how to understand them.</p>
</div>
</div>
<div class="sect2">
<h3 id="pitfalls-infiniteLoops">Infinite loops</h3>
<div class="paragraph">
<p>Here is a Java program with peculiar behavior</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Main</span> {
  <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
    foo();
    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">done with call to foo</span><span class="delimiter">&quot;</span></span>);
  }

  <span class="directive">static</span> <span class="type">void</span> foo() {
    <span class="keyword">try</span> {
      foo();
    } <span class="keyword">finally</span> {
      foo();
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This program will never reach the <code>println</code> call, but when it aborts may
have no stack trace.</p>
</div>
<div class="paragraph">
<p>This silence is caused by multiple <code>StackOverflowException</code>s. First the
infinite loop in the body of the method generates one, which the finally
clause tries to handle. But this finally clause also generates an
infinite loop which the current JVMs can&#8217;t handle gracefully leading to
the completely silent abort.</p>
</div>
<div class="paragraph">
<p>The following short aspect will also generate this behavior:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect A {
  before(): call(* *(..)) { <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">before</span><span class="delimiter">&quot;</span></span>); }
  after():  call(* *(..)) { <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">after</span><span class="delimiter">&quot;</span></span>); }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Why? Because the call to println is also a call matched by the pointcut
<code>call (* *(..))</code>. We get no output because we used simple <code>after()</code>
advice. If the aspect were changed to</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect A {
  before(): call(* *(..)) { <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">before</span><span class="delimiter">&quot;</span></span>); }
  after() returning:  call(* *(..)) { <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">after</span><span class="delimiter">&quot;</span></span>); }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>then at least a <code>StackOverflowException</code> with a stack trace would be seen.
In both cases, though, the overall problem is advice applying within its
own body.</p>
</div>
<div class="paragraph">
<p>There&#8217;s a simple idiom to use if you ever have a worry that your advice
might apply in this way. Just restrict the advice from occurring in join
points caused within the aspect. So:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect A {
  before(): call(* *(..)) &amp;&amp; !within(A) { <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">before</span><span class="delimiter">&quot;</span></span>); }
  after() returning:  call(* *(..)) &amp;&amp; !within(A) { <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">after</span><span class="delimiter">&quot;</span></span>); }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Other solutions might be to more closely restrict the pointcut in other
ways, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect A {
  before(): call(* MyObject.*(..))  { <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">before</span><span class="delimiter">&quot;</span></span>); }
  after() returning:  call(* MyObject.*(..))  { <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">after</span><span class="delimiter">&quot;</span></span>); }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The moral of the story is that unrestricted generic pointcuts can pick
out more join points than intended.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="quick">AspectJ Quick Reference</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="quick-pointcuts">Pointcuts</h3>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><strong>Methods and Constructors</strong></th>
<th class="tableblock halign-left valign-top"></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>call(Signature)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">every call to any method or constructor matching
<code>Signature</code> at the call site</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>execution(Signature)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">every execution of any method or constructor
matching <code>Signature</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Fields</strong></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>get(Signature)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">every reference to any field matching <code>Signature</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>set(Signature)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">every assignment to any field matching <code>Signature</code>.
The assigned value can be exposed with an <code>args</code> pointcut</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Exception Handlers</strong></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>handler(TypePattern)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">every exception handler for any <code>Throwable</code>
type in <code>TypePattern</code>. The exception value can be exposed with an <code>args</code>
pointcut</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Advice</strong></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>adviceexecution()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">every execution of any piece of advice</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Initialization</strong></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>staticinitialization(TypePattern)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">every execution of a static
initializer for any type in <code>TypePattern</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>initialization(Signature)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">every initialization of an object when the
first constructor called in the type matches <code>Signature</code>, encompassing
the return from the super constructor call to the return of the
first-called constructor</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>preinitialization(Signature)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">every pre-initialization of an object
when the first constructor called in the type matches <code>Signature</code>,
encompassing the entry of the first-called constructor to the call to
the super constructor</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Lexical</strong></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>within(TypePattern)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">every join point from code defined in a type in
<code>TypePattern</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>withincode(Signature)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">every join point from code defined in a method
or constructor matching <code>Signature</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="quick-typePatterns">Type Patterns</h3>
<div class="paragraph">
<p>A type pattern is one of</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><strong>Type pattern</strong></th>
<th class="tableblock halign-left valign-top"></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TypeNamePattern</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">all types in <code>TypeNamePattern</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SubtypePattern</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">all types in <code>SubtypePattern</code>, a pattern with a <code>+</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ArrayTypePattern</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">all types in <code>ArrayTypePattern</code>, a pattern with one or more <code>[]</code>s.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>!TypePattern</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">all types not in <code>TypePattern</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TypePattern0 &amp;&amp; TypePattern1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">all types in both <code>TypePattern0</code> and <code>TypePattern1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TypePattern0 || TypePattern1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">all types in either <code>TypePattern0</code> or <code>TypePattern1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>( TypePattern )</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">all types in <code>TypePattern</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>where <code>TypeNamePattern</code> can either be a plain type name, the wildcard
<code>*</code> (indicating all types), or an identifier with embedded <code>*</code> and <code>..</code>
wildcards.</p>
</div>
<div class="paragraph">
<p>An embedded <code>*</code> in an identifier matches any sequence of characters, but
does not match the package (or inner-type) separator <code>.</code>.</p>
</div>
<div class="paragraph">
<p>An embedded <code>..</code> in an identifier matches any sequence of characters
that starts and ends with the package (or inner-type) separator <code>.</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="quick-advice">Advice</h3>
<div class="paragraph">
<p>Each piece of advice is of the form</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">[ strictfp ] AdviceSpec [ throws TypeList ] : Pointcut { Body }</code></pre>
</div>
</div>
<div class="paragraph">
<p>where <code>AdviceSpec</code> is one of</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>before( Formals )</code></dt>
<dd>
<p>runs before each join point</p>
</dd>
<dt class="hdlist1"><code>after( Formals ) returning [ ( Formal ) ]</code></dt>
<dd>
<p>runs after each join point that returns normally. The optional formal
gives access to the returned value</p>
</dd>
<dt class="hdlist1"><code>after( Formals ) throwing [ ( Formal ) ]</code></dt>
<dd>
<p>runs after each join point that throws a <code>Throwable</code>.
If the optional formal is present, runs only after each join point
that throws a <code>Throwable</code> of the type of <code>Formal</code>, and <code>Formal</code> gives access to the
<code>Throwable</code> exception value</p>
</dd>
<dt class="hdlist1"><code>after( Formals )</code></dt>
<dd>
<p>runs after each join point regardless of whether it returns normally
or throws a <code>Throwable</code></p>
</dd>
<dt class="hdlist1"><code>Type around( Formals )</code></dt>
<dd>
<p>runs in place of each join point. The join point can be executed by
calling <code>proceed</code>, which takes the same number and types of arguments as the around
advice.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Three special variables are available inside of advice bodies:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>thisJoinPoint</code></dt>
<dd>
<p>an object of type <code>org.aspectj.lang.JoinPoint</code> representing the join point
at which the advice is executing</p>
</dd>
<dt class="hdlist1"><code>thisJoinPointStaticPart</code></dt>
<dd>
<p>equivalent to <code>thisJoinPoint.getStaticPart()</code>, but may use fewer runtime resources</p>
</dd>
<dt class="hdlist1"><code>thisEnclosingJoinPointStaticPart</code></dt>
<dd>
<p>the static part of the dynamically enclosing join point</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="quick-interType">Inter-type member declarations</h3>
<div class="paragraph">
<p>Each inter-type member is one of</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>Modifiers ReturnType OnType . Id ( Formals ) [ throws TypeList ] { Body }</code></dt>
<dd>
<p>a method on <code>OnType</code></p>
</dd>
<dt class="hdlist1"><code>abstract Modifiers ReturnType OnType . Id ( Formals ) [ throws TypeList ] ;</code></dt>
<dd>
<p>an abstract method on <code>OnType</code></p>
</dd>
<dt class="hdlist1"><code>Modifiers OnType .  new ( Formals ) [ throws TypeList ] { Body }</code></dt>
<dd>
<p>a constructor on <code>OnType</code></p>
</dd>
<dt class="hdlist1"><code>Modifiers Type OnType . Id [ = Expression ] ;</code></dt>
<dd>
<p>a field on <code>OnType</code></p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="quick-other">Other declarations</h3>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>declare parents : TypePattern extends Type ;</code></dt>
<dd>
<p>the types in <code>TypePattern</code> extend <code>Type</code></p>
</dd>
<dt class="hdlist1"><code>declare parents : TypePattern implements TypeList ;</code></dt>
<dd>
<p>the types in <code>TypePattern</code> implement the types in <code>TypeList</code></p>
</dd>
<dt class="hdlist1"><code>declare warning : Pointcut : String ;</code></dt>
<dd>
<p>if any of the join points in <code>Pointcut</code> possibly exist in the program,
the compiler emits the warning <code>String</code></p>
</dd>
<dt class="hdlist1"><code>declare error : Pointcut : String ;</code></dt>
<dd>
<p>if any of the join points in <code>Pointcut</code> could possibly exist in the program,
the compiler emits the error <code>String</code></p>
</dd>
<dt class="hdlist1"><code>declare soft : Type : Pointcut ;</code></dt>
<dd>
<p>any <code>Type</code> exception that gets thrown at any join point picked out by <code>Pointcut</code>
is wrapped in <code>org.aspectj.lang.SoftException</code></p>
</dd>
<dt class="hdlist1"><code>declare precedence : TypePatternList ;</code></dt>
<dd>
<p>at any join point where multiple pieces of advice apply, the advice
precedence at that join point is in <code>TypePatternList</code> order</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="quick-aspectAssociations">Aspects</h3>
<div class="paragraph">
<p>Each aspect is of the form</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">[ privileged ] Modifiers aspect Id [ extends Type ] [ implements TypeList ] [ PerClause ] { Body }</code></pre>
</div>
</div>
<div class="paragraph">
<p>where <code>PerClause</code> defines how the aspect is instantiated and associated
(<code>issingleton()</code> by default):</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">PerClause</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Accessor</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">[ <code>issingleton()</code> ]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">One instance of the aspect is made. This is the
default.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>aspectOf()</code> at all join points</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>perthis(Pointcut)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An instance is associated with each object that is
the currently executing object at any join point in <code>Pointcut</code>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>aspectOf(Object)</code> at all join points</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pertarget(Pointcut)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An instance is associated with each object that
is the target object at any join point in <code>Pointcut</code>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>aspectOf(Object)</code> at all join points</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>percflow(Pointcut)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The aspect is defined for each entrance to the
control flow of the join points defined by <code>Pointcut</code>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>aspectOf()</code> at
join points in <code>cflow(Pointcut)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>percflowbelow(Pointcut)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The aspect is defined for each entrance to
the control flow below the join points defined by <code>Pointcut</code>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>aspectOf()</code> at join points in <code>cflowbelow(Pointcut)</code></p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="semantics">Language Semantics</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="semantics-intro">Introduction</h3>
<div class="paragraph">
<p>AspectJ extends Java by overlaying a concept of join points onto the
existing Java semantics and adding a few new program elements to Java:</p>
</div>
<div class="paragraph">
<p>A join point is a well-defined point in the execution of a program.
These include method and constructor calls, field accesses and others
described below.</p>
</div>
<div class="paragraph">
<p>A pointcut picks out join points, and exposes some of the values in the
execution context of those join points. There are several primitive
pointcut designators, and others can be named and defined by the
<code>pointcut</code> declaration.</p>
</div>
<div class="paragraph">
<p>A piece of advice is code that executes at each join point in a
pointcut. Advice has access to the values exposed by the pointcut.
Advice is defined by <code>before</code>, <code>after</code>, and <code>around</code> declarations.</p>
</div>
<div class="paragraph">
<p>Inter-type declarations form AspectJ&#8217;s static crosscutting features,
that is, is code that may change the type structure of a program, by
adding to or extending interfaces and classes with new fields,
constructors, or methods. Some inter-type declarations are defined
through an extension of usual method, field, and constructor
declarations, and other declarations are made with a new <code>declare</code>
keyword.</p>
</div>
<div class="paragraph">
<p>An aspect is a crosscutting type that encapsulates pointcuts, advice,
and static crosscutting features. By type, we mean Java&#8217;s notion: a
modular unit of code, with a well-defined interface, about which it is
possible to do reasoning at compile time. Aspects are defined by the
<code>aspect</code> declaration.</p>
</div>
</div>
<div class="sect2">
<h3 id="semantics-joinPoints">Join Points</h3>
<div class="paragraph">
<p>While aspects define types that crosscut, the AspectJ system does not
allow completely arbitrary crosscutting. Rather, aspects define types
that cut across principled points in a program&#8217;s execution. These
principled points are called join points.</p>
</div>
<div class="paragraph">
<p>A join point is a well-defined point in the execution of a program. The
join points defined by AspectJ are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Method call</dt>
<dd>
<p>When a method is called, not including super calls of non-static
methods.</p>
</dd>
<dt class="hdlist1">Method execution</dt>
<dd>
<p>When the body of code for an actual method executes.</p>
</dd>
<dt class="hdlist1">Constructor call</dt>
<dd>
<p>When an object is built and that object&#8217;s initial constructor is
called (i.e., not for <code>super</code> or <code>this</code> constructor calls). The object
being constructed is returned at a constructor call join point, so its
return type is considered to be the type of the object, and the object
itself may be accessed with <code>after returning</code> advice.</p>
</dd>
<dt class="hdlist1">Constructor execution</dt>
<dd>
<p>When the body of code for an actual constructor executes, after its
this or super constructor call. The object being constructed is the
currently executing object, and so may be accessed with the <code>this()</code> pointcut.
The constructor execution join point for a constructor that
calls a super constructor also includes any non-static initializers of
enclosing class. No value is returned from a constructor execution
join point, so its return type is considered to be <code>void</code>.</p>
</dd>
<dt class="hdlist1">Static initializer execution</dt>
<dd>
<p>When the static initializer for a class executes. No value is returned
from a static initializer execution join point, so its return type is
considered to be <code>void</code>.</p>
</dd>
<dt class="hdlist1">Object pre-initialization</dt>
<dd>
<p>Before the object initialization code for a particular class runs.
This encompasses the time between the start of its first called
constructor and the start of its parent&#8217;s constructor. Thus, the
execution of these join points encompass the join points of the
evaluation of the arguments of <code>this()</code> and <code>super()</code> constructor calls.
No value is returned from an object pre-initialization join point, so its
return type is considered to be <code>void</code>.</p>
</dd>
<dt class="hdlist1">Object initialization</dt>
<dd>
<p>When the object initialization code for a particular class runs. This
encompasses the time between the return of its parent&#8217;s constructor
and the return of its first called constructor. It includes all the
dynamic initializers and constructors used to create the object. The
object being constructed is the currently executing object, and so may
be accessed with the <code>this()</code> pointcut. No value is returned from a constructor
execution join point, so its return type is considered to be <code>void</code>.</p>
</dd>
<dt class="hdlist1">Field reference</dt>
<dd>
<p>When a non-constant field is referenced. [Note that references to
constant fields (static final fields bound to a constant string object
or primitive value) are not join points, since Java requires them to
be inlined.]</p>
</dd>
<dt class="hdlist1">Field set</dt>
<dd>
<p>When a field is assigned to. Field set join points are considered to
have one argument, the value the field is being set to. No value is
returned from a field set join point, so its return type is considered
to be void. [Note that the initializations of constant fields (<code>static final</code>
fields where the initializer is a constant string object or
primitive value) are not join points, since Java requires their
references to be inlined.]</p>
</dd>
<dt class="hdlist1">Handler execution</dt>
<dd>
<p>When an exception handler executes. Handler execution join points are
considered to have one argument, the exception being handled. No value
is returned from a field set join point, so its return type is
considered to be void.</p>
</dd>
<dt class="hdlist1">Advice execution</dt>
<dd>
<p>When the body of code for a piece of advice executes.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Each join point potentially has three pieces of state associated with
it: the currently executing object, the target object, and an object
array of arguments. These are exposed by the three state-exposing
pointcuts, <code>this</code>, <code>target</code>, and <code>args</code>, respectively.</p>
</div>
<div class="paragraph">
<p>Informally, the currently executing object is the object that a <code>this</code>
expression would pick out at the join point. The target object is where
control or attention is transferred to by the join point. The arguments
are those values passed for that transfer of control or attention.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><strong>Join Point</strong></th>
<th class="tableblock halign-left valign-top"><strong>Current Object</strong></th>
<th class="tableblock halign-left valign-top"><strong>Target Object</strong></th>
<th class="tableblock halign-left valign-top"><strong>Arguments</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Method Call</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">executing object*</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">target object**</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">method arguments</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Method Execution</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">executing object*</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">executing object*</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">method
arguments</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Constructor Call</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">executing object*</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">None</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">constructor arguments</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Constructor Execution</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">executing object</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">executing object</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">constructor
arguments</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Static initializer execution</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">None</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">None</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">None</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Object pre-initialization</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">None</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">None</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">constructor arguments</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Object initialization</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">executing object</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">executing object</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">constructor
arguments</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Field reference</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">executing object*</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">target object**</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">None</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Field assignment</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">executing object*</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">target object**</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">assigned value</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Handler execution</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">executing object*</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">executing object*</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">caught
exception</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Advice execution</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">executing aspect</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">executing aspect</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">advice arguments</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>* There is no executing object in static contexts such as static method
bodies or static initializers.</p>
</div>
<div class="paragraph">
<p>** There is no target object for join points associated with static
methods or fields.</p>
</div>
</div>
<div class="sect2">
<h3 id="semantics-pointcuts">Pointcuts</h3>
<div class="paragraph">
<p>A pointcut is a program element that picks out join points and exposes
data from the execution context of those join points. Pointcuts are used
primarily by advice. They can be composed with boolean operators to
build up other pointcuts. The primitive pointcuts and combinators
provided by the language are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>call(MethodPattern)</code></dt>
<dd>
<p>Picks out each method call join point whose signature matches <code><em>MethodPattern</em></code>.</p>
</dd>
<dt class="hdlist1"><code>execution(MethodPattern)</code></dt>
<dd>
<p>Picks out each method execution join point whose signature matches <code><em>MethodPattern</em></code>.</p>
</dd>
<dt class="hdlist1"><code>get(FieldPattern)</code></dt>
<dd>
<p>Picks out each field reference join point whose signature matches <code><em>FieldPattern</em></code>. [Note that references to constant fields (static final fields bound
to a constant string object or primitive value) are not join points,
since Java requires them to be inlined.]</p>
</dd>
<dt class="hdlist1"><code>set(FieldPattern)</code></dt>
<dd>
<p>Picks out each field set join point whose signature matches <code><em>FieldPattern</em></code>. [Note that the initializations of constant fields (static final
fields where the initializer is a constant string object or primitive
value) are not join points, since Java requires their references to be
inlined.]</p>
</dd>
<dt class="hdlist1"><code>call(ConstructorPattern)</code></dt>
<dd>
<p>Picks out each constructor call join point whose signature matches <code><em>ConstructorPattern</em></code>.</p>
</dd>
<dt class="hdlist1"><code>execution(ConstructorPattern)</code></dt>
<dd>
<p>Picks out each constructor execution join point whose signature
matches <code><em>ConstructorPattern</em></code>.</p>
</dd>
<dt class="hdlist1"><code>initialization(ConstructorPattern)</code></dt>
<dd>
<p>Picks out each object initialization join point whose signature
matches <code><em>ConstructorPattern</em></code>.</p>
</dd>
<dt class="hdlist1"><code>preinitialization(ConstructorPattern)</code></dt>
<dd>
<p>Picks out each object pre-initialization join point whose signature
matches <code><em>ConstructorPattern</em></code>.</p>
</dd>
<dt class="hdlist1"><code>staticinitialization(TypePattern)</code></dt>
<dd>
<p>Picks out each static initializer execution join point whose signature
matches <code><em>TypePattern</em></code>.</p>
</dd>
<dt class="hdlist1"><code>handler(TypePattern)</code></dt>
<dd>
<p>Picks out each exception handler join point whose signature matches <code><em>TypePattern</em></code>.</p>
</dd>
<dt class="hdlist1"><code>adviceexecution()</code></dt>
<dd>
<p>Picks out all advice execution join points.</p>
</dd>
<dt class="hdlist1"><code>within(TypePattern)</code></dt>
<dd>
<p>Picks out each join point where the executing code is defined in a
type matched by <code><em>TypePattern</em></code>.</p>
</dd>
<dt class="hdlist1"><code>withincode(MethodPattern)</code></dt>
<dd>
<p>Picks out each join point where the executing code is defined in a
method whose signature matches <code><em>MethodPattern</em></code>.</p>
</dd>
<dt class="hdlist1"><code>withincode(ConstructorPattern)</code></dt>
<dd>
<p>Picks out each join point where the executing code is defined in a
constructor whose signature matches <code><em>ConstructorPattern</em></code>.</p>
</dd>
<dt class="hdlist1"><code>cflow(Pointcut)</code></dt>
<dd>
<p>Picks out each join point in the control flow of any join point <code><em>P</em></code> picked out by <code><em>Pointcut</em></code> , including <code><em>P</em></code> itself.</p>
</dd>
<dt class="hdlist1"><code>cflowbelow(Pointcut)</code></dt>
<dd>
<p>Picks out each join point in the control flow of any join point <code><em>P</em></code> picked out by <code><em>Pointcut</em></code>, but not <code><em>P</em></code> itself.</p>
</dd>
<dt class="hdlist1"><code>this(Type or Id)</code></dt>
<dd>
<p>Picks out each join point where the currently executing object (the
object bound to <code><em>this</em></code>) is an instance of <code><em>Type</em></code> , or of the type of the identifier <code><em>Id</em></code> (which must be bound in the enclosing advice or pointcut definition).
Will not match any join points from static contexts.</p>
</dd>
<dt class="hdlist1"><code>target(Type or Id)</code></dt>
<dd>
<p>Picks out each join point where the target object (the object on which
a call or field operation is applied to) is an instance of <code><em>Type</em></code> , or of the type of the identifier <code><em>Id</em></code> (which must be bound in the enclosing advice or pointcut definition).
Will not match any calls, gets, or sets of static members.</p>
</dd>
<dt class="hdlist1"><code>args(Type or Id, &#8230;&#8203;)</code></dt>
<dd>
<p>Picks out each join point where the arguments are instances of the
appropriate type (or type of the identifier if using that form). A <code><em>null</em></code> argument is matched iff the static type of the argument (declared
parameter type or field type) is the same as, or a subtype of, the
specified args type.</p>
</dd>
<dt class="hdlist1"><code>PointcutId(TypePattern or Id, &#8230;&#8203;)</code></dt>
<dd>
<p>Picks out each join point that is picked out by the user-defined
pointcut designator named by <code><em>PointcutId</em></code> .</p>
</dd>
<dt class="hdlist1"><code>if(BooleanExpression)</code></dt>
<dd>
<p>Picks out each join point where the boolean expression evaluates to <code><em>true</em></code> . The boolean expression used can only access static members,
parameters exposed by the enclosing pointcut or advice, and <code><em>thisJoinPoint</em></code> forms. In particular, it cannot call non-static methods on the aspect
or use return values or exceptions exposed by after advice.</p>
</dd>
<dt class="hdlist1"><code>! Pointcut</code></dt>
<dd>
<p>Picks out each join point that is not picked out by <code><em>Pointcut</em></code> .</p>
</dd>
<dt class="hdlist1"><code>Pointcut0 &amp;&amp; Pointcut1</code></dt>
<dd>
<p>Picks out each join points that is picked out by both <code><em>Pointcut0</em></code> and <code><em>Pointcut1</em></code> .</p>
</dd>
<dt class="hdlist1"><code>Pointcut0 || Pointcut1</code></dt>
<dd>
<p>Picks out each join point that is picked out by either pointcuts. <code><em>Pointcut0</em></code> or <code><em>Pointcut1</em></code> .</p>
</dd>
<dt class="hdlist1"><code>( Pointcut )</code></dt>
<dd>
<p>Picks out each join points picked out by <code><em>Pointcut</em></code> .</p>
</dd>
</dl>
</div>
<div class="sect3">
<h4 id="_pointcut_definition">Pointcut definition</h4>
<div class="paragraph">
<p>Pointcuts are defined and named by the programmer with the <code>pointcut</code>
declaration.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">pointcut publicIntCall(<span class="type">int</span> i):
  call(<span class="directive">public</span> * *(<span class="type">int</span>)) &amp;&amp; args(i);</code></pre>
</div>
</div>
<div class="paragraph">
<p>A named pointcut may be defined in either a class or aspect, and is
treated as a member of the class or aspect where it is found. As a
member, it may have an access modifier such as <code>public</code> or <code>private</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">C</span> {
  pointcut publicCall(<span class="type">int</span> i):
    call(<span class="directive">public</span> * *(<span class="type">int</span>)) &amp;&amp; args(i);
}

<span class="type">class</span> <span class="class">D</span> {
  pointcut myPublicCall(<span class="type">int</span> i):
    C.publicCall(i) &amp;&amp; within(SomeType);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Pointcuts that are not final may be declared abstract, and defined
without a body. Abstract pointcuts may only be declared within abstract
aspects.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">abstract</span> aspect A {
  <span class="directive">abstract</span> pointcut publicCall(<span class="type">int</span> i);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In such a case, an extending aspect may override the abstract pointcut.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect B <span class="directive">extends</span> A {
  pointcut publicCall(<span class="type">int</span> i): call(<span class="directive">public</span> Foo.m(<span class="type">int</span>)) &amp;&amp; args(i);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For completeness, a pointcut with a declaration may be declared <code>final</code>.</p>
</div>
<div class="paragraph">
<p>Though named pointcut declarations appear somewhat like method
declarations, and can be overridden in subaspects, they cannot be
overloaded. It is an error for two pointcuts to be named with the same
name in the same class or aspect declaration.</p>
</div>
<div class="paragraph">
<p>The scope of a named pointcut is the enclosing class declaration. This
is different than the scope of other members; the scope of other members
is the enclosing class <em>body</em>. This means that the following code is
legal:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect B percflow(publicCall()) {
  pointcut publicCall(): call(<span class="directive">public</span> Foo.m(<span class="type">int</span>));
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_context_exposure">Context exposure</h4>
<div class="paragraph">
<p>Pointcuts have an interface; they expose some parts of the execution
context of the join points they pick out. For example, the PublicIntCall
above exposes the first argument from the receptions of all public unary
integer methods. This context is exposed by providing typed formal
parameters to named pointcuts and advice, like the formal parameters of
a Java method. These formal parameters are bound by name matching.</p>
</div>
<div class="paragraph">
<p>On the right-hand side of advice or pointcut declarations, in certain
pointcut designators, a Java identifier is allowed in place of a type or
collection of types. The pointcut designators that allow this are
<code>this</code>, <code>target</code>, and <code>args</code>. In all such cases, using an identifier
rather than a type does two things. First, it selects join points as
based on the type of the formal parameter. So the pointcut</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">pointcut intArg(<span class="type">int</span> i): args(i);</code></pre>
</div>
</div>
<div class="paragraph">
<p>picks out join points where an <code>int</code> (or a <code>byte</code>, <code>short</code>, or <code>char</code>;
anything assignable to an <code>int</code>) is being passed as an argument. Second,
though, it makes the value of that argument available to the enclosing
advice or pointcut.</p>
</div>
<div class="paragraph">
<p>Values can be exposed from named pointcuts as well, so</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">pointcut publicCall(<span class="type">int</span> x): call(<span class="directive">public</span> *.*(<span class="type">int</span>)) &amp;&amp; intArg(x);
pointcut intArg(<span class="type">int</span> i): args(i);</code></pre>
</div>
</div>
<div class="paragraph">
<p>is a legal way to pick out all calls to public methods accepting an int
argument, and exposing that argument.</p>
</div>
<div class="paragraph">
<p>There is one special case for this kind of exposure. Exposing an
argument of type Object will also match primitive typed arguments, and
expose a "boxed" version of the primitive. So,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">pointcut publicCall(): call(<span class="directive">public</span> *.*(..)) &amp;&amp; args(<span class="predefined-type">Object</span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>will pick out all unary methods that take, as their only argument,
subtypes of Object (i.e., not primitive types like <code>int</code>), but</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">pointcut publicCall(<span class="predefined-type">Object</span> o): call(<span class="directive">public</span> *.*(..)) &amp;&amp; args(o);</code></pre>
</div>
</div>
<div class="paragraph">
<p>will pick out all unary methods that take any argument: And if the
argument was an <code>int</code>, then the value passed to advice will be of type
<code>java.lang.Integer</code>.</p>
</div>
<div class="paragraph">
<p>The "boxing" of the primitive value is based on the <em>original</em> primitive
type. So in the following program</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">InstanceOf</span> {
  <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
    doInt(<span class="integer">5</span>);
  }

  <span class="directive">static</span> <span class="type">void</span> doInt(<span class="type">int</span> i) {  }
}

aspect IntToLong {
  pointcut el(<span class="type">long</span> l) :
    execution(* doInt(..)) &amp;&amp; args(l);

  before(<span class="predefined-type">Object</span> o) : el(o) {
    <span class="predefined-type">System</span>.out.println(o.getClass());
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The pointcut will match and expose the integer argument, but it will
expose it as an <code>Integer</code>, not a <code>Long</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_primitive_pointcuts">Primitive pointcuts</h4>
<div class="sect4">
<h5 id="_method_related_pointcuts">Method-related pointcuts</h5>
<div class="paragraph">
<p>AspectJ provides two primitive pointcut designators designed to capture
method call and execution join points.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>call( MethodPattern )</code></p>
</li>
<li>
<p><code>execution( MethodPattern )</code></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_field_related_pointcuts">Field-related pointcuts</h5>
<div class="paragraph">
<p>AspectJ provides two primitive pointcut designators designed to capture
field reference and set join points:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>get( FieldPattern )</code></p>
</li>
<li>
<p><code>set( FieldPattern )</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All set join points are treated as having one argument, the value the
field is being set to, so at a set join point, that value can be
accessed with an <code>args</code> pointcut. So an aspect guarding a static integer
variable x declared in type T might be written as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect GuardedX {
  <span class="directive">static</span> <span class="directive">final</span> <span class="type">int</span> MAX_CHANGE = <span class="integer">100</span>;

  before(<span class="type">int</span> newval): set(<span class="directive">static</span> <span class="type">int</span> T.x) &amp;&amp; args(newval) {
    <span class="keyword">if</span> (<span class="predefined-type">Math</span>.abs(newval - T.x) &gt; MAX_CHANGE)
      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">RuntimeException</span>();
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_object_creation_related_pointcuts">Object creation-related pointcuts</h5>
<div class="paragraph">
<p>AspectJ provides primitive pointcut designators designed to capture the
initializer execution join points of objects.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>call( ConstructorPattern )</code></p>
</li>
<li>
<p><code>execution( ConstructorPattern )</code></p>
</li>
<li>
<p><code>initialization( ConstructorPattern )</code></p>
</li>
<li>
<p><code>preinitialization( ConstructorPattern )</code></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_class_initialization_related_pointcuts">Class initialization-related pointcuts</h5>
<div class="paragraph">
<p>AspectJ provides one primitive pointcut designator to pick out static
initializer execution join points.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>staticinitialization( TypePattern )</code></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_exception_handler_execution_related_pointcuts">Exception handler execution-related pointcuts</h5>
<div class="paragraph">
<p>AspectJ provides one primitive pointcut designator to capture execution
of exception handlers:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>handler( TypePattern )</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All handler join points are treated as having one argument, the value of
the exception being handled. That value can be accessed with an <code>args</code>
pointcut. So an aspect used to put <code>FooException</code> objects into some
normal form before they are handled could be written as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect NormalizeFooException {
  before(FooException e): handler(FooException) &amp;&amp; args(e) {
    e.normalize();
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_advice_execution_related_pointcuts">Advice execution-related pointcuts</h5>
<div class="paragraph">
<p>AspectJ provides one primitive pointcut designator to capture execution
of advice</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>adviceexecution()</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This can be used, for example, to filter out any join point in the
control flow of advice from a particular aspect.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect TraceStuff {
  pointcut myAdvice(): adviceexecution() &amp;&amp; within(TraceStuff);

  before(): call(* *(..)) &amp;&amp; !cflow(myAdvice) {
    <span class="comment">// do something</span>
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_state_based_pointcuts">State-based pointcuts</h5>
<div class="paragraph">
<p>Many concerns cut across the dynamic times when an object of a
particular type is executing, being operated on, or being passed around.
AspectJ provides primitive pointcuts that capture join points at these
times. These pointcuts use the dynamic types of their objects to pick
out join points. They may also be used to expose the objects used for
discrimination.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>this( Type or Id )</code></p>
</li>
<li>
<p><code>target( Type or Id )</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>this</code> pointcut picks out each join point where the currently
executing object (the object bound to <code>this</code>) is an instance of a
particular type. The <code>target</code> pointcut picks out each join point where
the target object (the object on which a method is called or a field is
accessed) is an instance of a particular type. Note that <code>target</code> should
be understood to be the object the current join point is transfering
control to. This means that the target object is the same as the current
object at a method execution join point, for example, but may be
different at a method call join point.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>args( Type or Id or "..", &#8230;&#8203;)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The args pointcut picks out each join point where the arguments are
instances of some types. Each element in the comma-separated list is one
of four things. If it is a type name, then the argument in that position
must be an instance of that type. If it is an identifier, then that
identifier must be bound in the enclosing advice or pointcut
declaration, and so the argument in that position must be an instance of
the type of the identifier (or of any type if the identifier is typed to
Object). If it is the <code>*</code> wildcard, then any argument will match, and if
it is the special wildcard <code>..</code>, then any number of arguments will
match, just like in signature patterns. So the pointcut</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">args(<span class="type">int</span>, .., <span class="predefined-type">String</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>will pick out all join points where the first argument is an <code>int</code> and
the last is a <code>String</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_control_flow_based_pointcuts">Control flow-based pointcuts</h5>
<div class="paragraph">
<p>Some concerns cut across the control flow of the program. The <code>cflow</code>
and <code>cflowbelow</code> primitive pointcut designators capture join points
based on control flow.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>cflow( Pointcut )</code></p>
</li>
<li>
<p><code>cflowbelow( Pointcut )</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>cflow</code> pointcut picks out all join points that occur between entry
and exit of each join point <code>P</code> picked out by <code>Pointcut</code>, including <code>P</code>
itself. Hence, it picks out the join points <em>in</em> the control flow of the
join points picked out by <code>Pointcut</code>.</p>
</div>
<div class="paragraph">
<p>The <code>cflowbelow</code> pointcut picks out all join points that occur between
entry and exit of each join point <code>P</code> picked out by <code>Pointcut</code>, but not
including <code>P</code> itself. Hence, it picks out the join points <em>below</em> the
control flow of the join points picked out by <code>Pointcut</code>.</p>
</div>
<div class="sect5">
<h6 id="_context_exposure_from_control_flows">Context exposure from control flows</h6>
<div class="paragraph">
<p>The <code>cflow</code> and <code>cflowbelow</code> pointcuts may expose context state through
enclosed <code>this</code>, <code>target</code>, and <code>args</code> pointcuts.</p>
</div>
<div class="paragraph">
<p>Anytime such state is accessed, it is accessed through the <em>most recent</em>
control flow that matched. So the "current arg" that would be printed by
the following program is zero, even though it is in many control flows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">Test</span> {
  <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
    fact(<span class="integer">5</span>);
  }
  <span class="directive">static</span> <span class="type">int</span> fact(<span class="type">int</span> x) {
    <span class="keyword">if</span> (x == <span class="integer">0</span>) {
      <span class="predefined-type">System</span>.err.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">bottoming out</span><span class="delimiter">&quot;</span></span>);
      <span class="keyword">return</span> <span class="integer">1</span>;
    }
    <span class="keyword">else</span> <span class="keyword">return</span> x * fact(x - <span class="integer">1</span>);
  }
}

aspect A {
  pointcut entry(<span class="type">int</span> i): call(<span class="type">int</span> fact(<span class="type">int</span>)) &amp;&amp; args(i);
  pointcut writing(): call(<span class="type">void</span> println(<span class="predefined-type">String</span>)) &amp;&amp; ! within(A);

  before(<span class="type">int</span> i): writing() &amp;&amp; cflow(entry(i)) {
    <span class="predefined-type">System</span>.err.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Current arg is </span><span class="delimiter">&quot;</span></span> + i);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is an error to expose such state through <em>negated</em> control flow
pointcuts, such as within <code>!cflowbelow(P)</code>.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_program_text_based_pointcuts">Program text-based pointcuts</h5>
<div class="paragraph">
<p>While many concerns cut across the runtime structure of the program,
some must deal with the lexical structure. AspectJ allows aspects to
pick out join points based on where their associated code is defined.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>within( TypePattern )</code></p>
</li>
<li>
<p><code>withincode( MethodPattern )</code></p>
</li>
<li>
<p><code>withincode( ConstructorPattern )</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>within</code> pointcut picks out each join point where the code executing
is defined in the declaration of one of the types in <code>TypePattern</code>. This
includes the class initialization, object initialization, and method and
constructor execution join points for the type, as well as any join
points associated with the statements and expressions of the type. It
also includes any join points that are associated with code in a type&#8217;s
nested types, and that type&#8217;s default constructor, if there is one.</p>
</div>
<div class="paragraph">
<p>The <code>withincode</code> pointcuts picks out each join point where the code
executing is defined in the declaration of a particular method or
constructor. This includes the method or constructor execution join
point as well as any join points associated with the statements and
expressions of the method or constructor. It also includes any join
points that are associated with code in a method or constructor&#8217;s local
or anonymous types.</p>
</div>
</div>
<div class="sect4">
<h5 id="_expression_based_pointcuts">Expression-based pointcuts</h5>
<div class="ulist">
<ul>
<li>
<p><code>if( BooleanExpression )</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The if pointcut picks out join points based on a dynamic property. its
syntax takes an expression, which must evaluate to a boolean true or
false. Within this expression, the <code>thisJoinPoint</code> object is available.
So one (extremely inefficient) way of picking out all call join points
would be to use the pointcut</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">if</span>(thisJoinPoint.getKind().equals(<span class="string"><span class="delimiter">&quot;</span><span class="content">call</span><span class="delimiter">&quot;</span></span>))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the order of evaluation for pointcut expression components at
a join point is undefined. Writing <code>if</code> pointcuts that have side-effects
is considered bad style and may also lead to potentially confusing or
even changing behavior with regard to when or if the test code will run.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_signatures">Signatures</h4>
<div class="paragraph">
<p>One very important property of a join point is its signature, which is
used by many of AspectJ&#8217;s pointcut designators to select particular join
points.</p>
</div>
<div class="sect4">
<h5 id="_methods">Methods</h5>
<div class="paragraph">
<p>Join points associated with methods typically have method signatures,
consisting of a method name, parameter types, return type, the types of
the declared (checked) exceptions, and some type that the method could
be called on (below called the "qualifying type").</p>
</div>
<div class="paragraph">
<p>At a method call join point, the signature is a method signature whose
qualifying type is the static type used to <em>access</em> the method. This
means that the signature for the join point created from the call
<code>((Integer)i).toString()</code> is different than that for the call
<code>((Object)i).toString()</code>, even if <code>i</code> is the same variable.</p>
</div>
<div class="paragraph">
<p>At a method execution join point, the signature is a method signature
whose qualifying type is the declaring type of the method.</p>
</div>
</div>
<div class="sect4">
<h5 id="_fields">Fields</h5>
<div class="paragraph">
<p>Join points associated with fields typically have field signatures,
consisting of a field name and a field type. A field reference join
point has such a signature, and no parameters. A field set join point
has such a signature, but has a has a single parameter whose type is the
same as the field type.</p>
</div>
</div>
<div class="sect4">
<h5 id="_constructors">Constructors</h5>
<div class="paragraph">
<p>Join points associated with constructors typically have constructor
signatures, consisting of a parameter types, the types of the declared
(checked) exceptions, and the declaring type.</p>
</div>
<div class="paragraph">
<p>At a constructor call join point, the signature is the constructor
signature of the called constructor. At a constructor execution join
point, the signature is the constructor signature of the currently
executing constructor.</p>
</div>
<div class="paragraph">
<p>At object initialization and pre-initialization join points, the
signature is the constructor signature for the constructor that started
this initialization: the first constructor entered during this type&#8217;s
initialization of this object.</p>
</div>
</div>
<div class="sect4">
<h5 id="_others">Others</h5>
<div class="paragraph">
<p>At a handler execution join point, the signature is composed of the
exception type that the handler handles.</p>
</div>
<div class="paragraph">
<p>At an advice execution join point, the signature is composed of the
aspect type, the parameter types of the advice, the return type (void
for all but around advice) and the types of the declared (checked)
exceptions.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_matching">Matching</h4>
<div class="paragraph">
<p>The <code>withincode</code>, <code>call</code>, <code>execution</code>, <code>get</code>, and <code>set</code> primitive
pointcut designators all use signature patterns to determine the join
points they describe. A signature pattern is an abstract description of
one or more join-point signatures. Signature patterns are intended to
match very closely the same kind of things one would write when
declaring individual members and constructors.</p>
</div>
<div class="paragraph">
<p>Method declarations in Java include method names, method parameters,
return types, modifiers like static or private, and throws clauses,
while constructor declarations omit the return type and replace the
method name with the class name. The start of a particular method
declaration, in class <code>Test</code>, for example, might be</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">C</span> {
  <span class="directive">public</span> <span class="directive">final</span> <span class="type">void</span> foo() <span class="directive">throws</span> ArrayOutOfBoundsException { ... }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In AspectJ, method signature patterns have all these, but most elements
can be replaced by wildcards. So</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">call(<span class="directive">public</span> <span class="directive">final</span> <span class="type">void</span> C.foo() <span class="directive">throws</span> ArrayOutOfBoundsException)</code></pre>
</div>
</div>
<div class="paragraph">
<p>picks out call join points to that method, and the pointcut</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">call(<span class="directive">public</span> <span class="directive">final</span> <span class="type">void</span> *.*() <span class="directive">throws</span> ArrayOutOfBoundsException)</code></pre>
</div>
</div>
<div class="paragraph">
<p>picks out all call join points to methods, regardless of their name name
or which class they are defined on, so long as they take no arguments,
return no value, are both <code>public</code> and <code>final</code>, and are declared to
throw <code>ArrayOutOfBoundsException</code>s.</p>
</div>
<div class="paragraph">
<p>The defining type name, if not present, defaults to *, so another way of
writing that pointcut would be</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">call(<span class="directive">public</span> <span class="directive">final</span> <span class="type">void</span> *() <span class="directive">throws</span> ArrayOutOfBoundsException)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The wildcard <code>..</code> indicates zero or more parameters, so</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">execution(<span class="type">void</span> m(..))</code></pre>
</div>
</div>
<div class="paragraph">
<p>picks out execution join points for void methods named <code>m</code>, of any
number of arguments, while</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">execution(<span class="type">void</span> m(.., <span class="type">int</span>))</code></pre>
</div>
</div>
<div class="paragraph">
<p>picks out execution join points for void methods named <code>m</code> whose last
parameter is of type <code>int</code>.</p>
</div>
<div class="paragraph">
<p>The modifiers also form part of the signature pattern. If an AspectJ
signature pattern should match methods without a particular modifier,
such as all non-public methods, the appropriate modifier should be
negated with the <code>!</code> operator. So,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">withincode(!<span class="directive">public</span> <span class="type">void</span> foo())</code></pre>
</div>
</div>
<div class="paragraph">
<p>picks out all join points associated with code in null non-public void
methods named <code>foo</code>, while</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">withincode(<span class="type">void</span> foo())</code></pre>
</div>
</div>
<div class="paragraph">
<p>picks out all join points associated with code in null void methods
named <code>foo</code>, regardless of access modifier.</p>
</div>
<div class="paragraph">
<p>Method names may contain the * wildcard, indicating any number of
characters in the method name. So</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">call(<span class="type">int</span> *())</code></pre>
</div>
</div>
<div class="paragraph">
<p>picks out all call join points to <code>int</code> methods regardless of name, but</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">call(<span class="type">int</span> get*())</code></pre>
</div>
</div>
<div class="paragraph">
<p>picks out all call join points to <code>int</code> methods where the method name
starts with the characters "get".</p>
</div>
<div class="paragraph">
<p>AspectJ uses the <code>new</code> keyword for constructor signature patterns rather
than using a particular class name. So the execution join points of
private null constructor of a class <code>C</code> defined to throw an
<code>ArithmeticException</code> can be picked out with</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">execution(<span class="directive">private</span> C.new() <span class="directive">throws</span> <span class="exception">ArithmeticException</span>)</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_matching_based_on_the_declaring_type">Matching based on the declaring type</h5>
<div class="paragraph">
<p>The signature-matching pointcuts all specify a declaring type, but the
meaning varies slightly for each join point signature, in line with Java
semantics.</p>
</div>
<div class="paragraph">
<p>When matching for pointcuts <code>withincode</code>, <code>get</code>, and <code>set</code>, the
declaring type is the class that contains the declaration.</p>
</div>
<div class="paragraph">
<p>When matching method-call join points, the declaring type is the static
type used to access the method. A common mistake is to specify a
declaring type for the <code>call</code> pointcut that is a subtype of the
originally-declaring type. For example, given the class</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">Service</span> <span class="directive">implements</span> <span class="predefined-type">Runnable</span> {
  <span class="directive">public</span> <span class="type">void</span> run() { ... }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>the following pointcut</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">call(<span class="type">void</span> Service.run())</code></pre>
</div>
</div>
<div class="paragraph">
<p>would fail to pick out the join point for the code</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">((<span class="predefined-type">Runnable</span>) <span class="keyword">new</span> Service()).run();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Specifying the originally-declaring type is correct, but would pick out
any such call (here, calls to the <code>run()</code> method of any <code>Runnable</code>). In
this situation, consider instead picking out the target type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">call(<span class="type">void</span> run()) &amp;&amp; target(Service)</code></pre>
</div>
</div>
<div class="paragraph">
<p>When matching method-execution join points, if the execution pointcut
method signature specifies a declaring type, the pointcut will only
match methods declared in that type, or methods that override methods
declared in or inherited by that type. So the pointcut</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">execution(<span class="directive">public</span> <span class="type">void</span> Middle.*())</code></pre>
</div>
</div>
<div class="paragraph">
<p>picks out all method executions for public methods returning void and
having no arguments that are either declared in, or inherited by,
<code>Middle</code>, even if those methods are overridden in a subclass of <code>Middle</code>. So
the pointcut would pick out the method-execution join point for <code>Sub.m()</code>
in this code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">Super</span> {
  <span class="directive">protected</span> <span class="type">void</span> m() { <span class="comment">/*...*/</span> }
}

<span class="type">class</span> <span class="class">Middle</span> <span class="directive">extends</span> Super {}

<span class="type">class</span> <span class="class">Sub</span> <span class="directive">extends</span> Middle {
  <span class="directive">public</span> <span class="type">void</span> m() { <span class="comment">/*...*/</span> }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_matching_based_on_the_throws_clause">Matching based on the <code>throws</code> clause</h5>
<div class="paragraph">
<p>Type patterns may be used to pick out methods and constructors based on
their <code>throws</code> clauses. This allows the following two kinds of extremely
wildcarded pointcuts:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">pointcut throwsMathlike():
  <span class="comment">// each call to a method with a throws clause containing at least</span>
  <span class="comment">// one exception exception with &quot;Math&quot; in its name.</span>
  call(* *(..) <span class="directive">throws</span> *..*<span class="predefined-type">Math</span>*);

pointcut doesNotThrowMathlike():
  <span class="comment">// each call to a method with a throws clause containing no</span>
  <span class="comment">// exceptions with &quot;Math&quot; in its name.</span>
  call(* *(..) <span class="directive">throws</span> !*..*<span class="predefined-type">Math</span>*);</code></pre>
</div>
</div>
<div class="paragraph">
<p>A <code>ThrowsClausePattern</code> is a comma-separated list of <code>ThrowsClausePatternItem</code>s, where</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">ThrowsClausePatternItem := [ ! ] TypeNamePattern</code></pre>
</div>
</div>
<div class="paragraph">
<p>A <code>ThrowsClausePattern</code> matches the <code>throws</code> clause of any code member
signature. To match, each <code>ThrowsClausePatternItem</code> must match the
<code>throws</code> clause of the member in question. If any item doesn&#8217;t match, then
the whole pattern doesn&#8217;t match.</p>
</div>
<div class="paragraph">
<p>If a <code>ThrowsClausePatternItem</code> begins with <code>!</code>, then it matches a
particular <code>throws</code> clause if and only if <em>none</em> of the types named in the
<code>throws</code> clause is matched by the <code>TypeNamePattern</code>.</p>
</div>
<div class="paragraph">
<p>If a <code>ThrowsClausePatternItem</code> does not begin with <code>!</code>, then it matches
a throws clause if and only if <em>any</em> of the types named in the <code>throws</code>
clause is matched by the <code>TypeNamePattern</code>.</p>
</div>
<div class="paragraph">
<p>The rule for <code>!</code> matching has one potentially surprising property, in
that these two pointcuts</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>call(* *(..) throws !IOException)</code></p>
</li>
<li>
<p><code>call(* *(..) throws (!IOException))</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>will match differently on calls to</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">void</span> m() <span class="directive">throws</span> <span class="exception">RuntimeException</span>, <span class="exception">IOException</span> {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>[1] will <strong>not</strong> match the method <code>m()</code>, because <code>m</code>'s throws clause
declares that it <code>throws IOException</code>.</p>
</div>
<div class="paragraph">
<p>[2] <strong>will</strong> match the method <code>m()</code>, because <code>m</code>'s throws clause declares that
it throws some exception which does not match <code>IOException</code>, i.e. <code>RuntimeException</code>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_type_patterns">Type patterns</h4>
<div class="paragraph">
<p>Type patterns are a way to pick out collections of types and use them in
places where you would otherwise use only one type. The rules for using
type patterns are simple.</p>
</div>
<div class="sect4">
<h5 id="_exact_type_pattern">Exact type pattern</h5>
<div class="paragraph">
<p>First, all type names are also type patterns. So <code>Object</code>,
<code>java.util.HashMap</code>, <code>Map.Entry</code>, <code>int</code> are all type patterns.</p>
</div>
<div class="paragraph">
<p>If a type pattern is an exact type - if it doesn&#8217;t include a wildcard -
then the matching works just like normal type lookup in Java:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Patterns that have the same names as primitive types (like <code>int</code>) match those
primitive types.</p>
</li>
<li>
<p>Patterns that are qualified by package names (like <code>java.util.HashMap</code>) match
types in other packages.</p>
</li>
<li>
<p>Patterns that are not qualified (like <code>HashMap</code>) match types that are resolved
by Java&#8217;s normal scope rules. So, for example, <code>HashMap</code> might match a package-level
type in the same package or a type that have been imported with Java&#8217;s <code>import</code>
form. But it would not match <code>java.util.HashMap</code> unless the aspect were in <code>java.util</code>
or the type had been imported.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>So exact type patterns match based on usual Java scope rules.</p>
</div>
</div>
<div class="sect4">
<h5 id="_type_name_patterns">Type name patterns</h5>
<div class="paragraph">
<p>There is a special type name, <code>*</code>, which is also a type pattern. <code>*</code> picks
out all types, including primitive types. So</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">call(<span class="type">void</span> foo(*))</code></pre>
</div>
</div>
<div class="paragraph">
<p>picks out all call join points to void methods named foo, taking one
argument of any type.</p>
</div>
<div class="paragraph">
<p>Type names that contain the two wildcards <code>*</code> and <code>..</code> are also type
patterns. The <code>*</code> wildcard matches zero or more characters characters
except for <code>.</code>, so it can be used when types have a certain naming
convention. So</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">handler(java.util.*<span class="predefined-type">Map</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>picks out the types <code>java.util.Map</code> and <code>java.util.java.util.HashMap</code>, among
others, and</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">handler(java.util.*)</code></pre>
</div>
</div>
<div class="paragraph">
<p>picks out all types that start with <code>java.util.</code> and don&#8217;t have any
more <code>.</code>s, that is, the types in the <code>java.util</code> package, but not inner
types (such as <code>java.util.Map.Entry</code>).</p>
</div>
<div class="paragraph">
<p>The <code>..</code> wildcard matches any sequence of characters that start and
end with a <code>.</code>, so it can be used to pick out all types in any
subpackage, or all inner types. So</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">within(com.xerox..*)</code></pre>
</div>
</div>
<div class="paragraph">
<p>picks out all join points where the code is in any declaration of a type
whose name begins with <code>com.xerox.</code>.</p>
</div>
<div class="paragraph">
<p>Type patterns with wildcards do not depend on Java&#8217;s usual scope rules -
they match against all types available to the weaver, not just those
that are imported into an Aspect&#8217;s declaring file.</p>
</div>
</div>
<div class="sect4">
<h5 id="_subtype_patterns">Subtype patterns</h5>
<div class="paragraph">
<p>It is possible to pick out all subtypes of a type (or a collection of
types) with the <code>` wildcard. The `</code> wildcard follows immediately a
type name pattern. So, while</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">call(Foo.new())</code></pre>
</div>
</div>
<div class="paragraph">
<p>picks out all constructor call join points where an instance of exactly
type <code>Foo</code> is constructed,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">call(Foo+.new())</code></pre>
</div>
</div>
<div class="paragraph">
<p>picks out all constructor call join points where an instance of any
subtype of <code>Foo</code> (including <code>Foo</code> itself) is constructed, and the unlikely</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">call(*<span class="predefined-type">Handler</span>+.new())</code></pre>
</div>
</div>
<div class="paragraph">
<p>picks out all constructor call join points where an instance of any
subtype of any type whose name ends in <code>Handler</code> is constructed.</p>
</div>
</div>
<div class="sect4">
<h5 id="_array_type_patterns">Array type patterns</h5>
<div class="paragraph">
<p>A type name pattern or subtype pattern can be followed by one or more
sets of square brackets to make array type patterns. So <code>Object[]</code> is an
array type pattern, and so is <code>com.xerox..*[][]</code>, and so is <code>Object+[]</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_type_patterns_2">Type patterns</h5>
<div class="paragraph">
<p>Type patterns are built up out of type name patterns, subtype patterns,
and array type patterns, and constructed with boolean operators <code>&amp;&amp;</code>,
<code>||</code>, and <code>!</code>. So</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">staticinitialization(Foo || Bar)</code></pre>
</div>
</div>
<div class="paragraph">
<p>picks out the static initializer execution join points of either <code>Foo</code> or
<code>Bar</code>, and</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">call((Foo+ &amp;&amp; ! Foo).new(..))</code></pre>
</div>
</div>
<div class="paragraph">
<p>picks out the constructor call join points when a subtype of <code>Foo</code>, but
not <code>Foo</code> itself, is constructed.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_pattern_summary">Pattern Summary</h4>
<div class="paragraph">
<p>Here is a summary of the pattern syntax used in AspectJ:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">MethodPattern =
    [ModifiersPattern] TypePattern
    [TypePattern . ] IdPattern (TypePattern | &quot;..&quot; , ... )
    [ throws ThrowsPattern ]
ConstructorPattern =
    [ModifiersPattern ]
    [TypePattern . ] new (TypePattern | &quot;..&quot; , ...)
    [ throws ThrowsPattern ]
FieldPattern =
    [ModifiersPattern] TypePattern [TypePattern . ] IdPattern
ThrowsPattern =
    [ ! ] TypePattern , ...
TypePattern =
    IdPattern [ + ] [ [] ... ]
    | ! TypePattern
    | TypePattern &amp;&amp; TypePattern
    | TypePattern || TypePattern
    | ( TypePattern )
IdPattern =
    Sequence of characters, possibly with special * and .. wildcards
ModifiersPattern =
    [ ! ] JavaModifier  ...</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="semantics-advice">Advice</h3>
<div class="paragraph">
<p>Each piece of advice is of the form</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">[ strictfp ] AdviceSpec [ throws TypeList ] : Pointcut { Body }</code></pre>
</div>
</div>
<div class="paragraph">
<p>where <code>AdviceSpec</code> is one of</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>before( Formals )</code></p>
</li>
<li>
<p><code>after( Formals ) returning [ ( Formal ) ]</code></p>
</li>
<li>
<p><code>after( Formals ) throwing [ ( Formal ) ]</code></p>
</li>
<li>
<p><code>after( Formals )</code></p>
</li>
<li>
<p><code>Type around( Formals )</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>and where <code>Formal</code> refers to a variable binding like those used for
method parameters, of the form <code>Type</code> <code>Variable-Name</code>, and <code>Formals</code>
refers to a comma-delimited list of <code>Formal</code>.</p>
</div>
<div class="paragraph">
<p>Advice defines crosscutting behavior. It is defined in terms of
pointcuts. The code of a piece of advice runs at every join point picked
out by its pointcut. Exactly how the code runs depends on the kind of
advice.</p>
</div>
<div class="paragraph">
<p>AspectJ supports three kinds of advice. The kind of advice determines
how it interacts with the join points it is defined over. Thus AspectJ
divides advice into that which runs <strong>before</strong> its join points, that which
runs <strong>after</strong> its join points, and that which runs <strong>in place of (or
"around")</strong> its join points.</p>
</div>
<div class="paragraph">
<p>While <code>before</code> advice is relatively unproblematic, there can be three
interpretations of <code>after</code> advice: After the execution of a join point
completes normally, after it throws an exception, or after it does
either one. AspectJ allows <code>after</code> advice for any of these situations:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect A {
  pointcut publicCall(): call(<span class="directive">public</span> <span class="predefined-type">Object</span> *(..));

  after() returning (<span class="predefined-type">Object</span> o): publicCall() {
    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Returned normally with </span><span class="delimiter">&quot;</span></span> + o);
  }

  after() throwing (<span class="exception">Exception</span> e): publicCall() {
    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Threw an exception: </span><span class="delimiter">&quot;</span></span> + e);
  }

  after(): publicCall(){
    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Returned or threw an Exception</span><span class="delimiter">&quot;</span></span>);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>after returning</code> advice may not care about its returned object, in which
case it may be written</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">after() returning: call(<span class="directive">public</span> <span class="predefined-type">Object</span> *(..)) {
  <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Returned normally</span><span class="delimiter">&quot;</span></span>);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>after returning</code> does expose its returned object, then the type of the
parameter is considered to be an <code>instanceof</code>-like constraint on the
advice: it will run only when the return value is of the appropriate
type.</p>
</div>
<div class="paragraph">
<p>A value is of the appropriate type if it would be assignable to a
variable of that type, in the Java sense. That is, a <code>byte</code> value is
assignable to a <code>short</code> parameter but not vice-versa, an <code>int</code> is
assignable to a <code>float</code> parameter, <code>boolean</code> values are only assignable
to <code>boolean</code> parameters, and reference types work by <code>instanceof</code>.</p>
</div>
<div class="paragraph">
<p>There are two special cases: If the exposed value is typed to <code>Object</code>,
then the advice is not constrained by that type: the actual return value
is converted to an object type for the body of the advice: <code>int</code> values
are represented as <code>java.lang.Integer</code> objects, etc, and no value (from
<code>void</code> methods, for example) is represented as <code>null</code>.</p>
</div>
<div class="paragraph">
<p>Secondly, the <code>null</code> value is assignable to a parameter <code>T</code> if the join
point <em>could</em> return something of type <code>T</code>.</p>
</div>
<div class="paragraph">
<p><code>around</code> advice runs in place of the join point it operates over, rather
than before or after it. Because <code>around</code> is allowed to return a value, it
must be declared with a return type, like a method.</p>
</div>
<div class="paragraph">
<p>Thus, a simple use of <code>around</code> advice is to make a particular method
constant:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect A {
  <span class="type">int</span> around(): call(<span class="type">int</span> C.foo()) {
    <span class="keyword">return</span> <span class="integer">3</span>;
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Within the body of <code>around</code> advice, though, the computation of the
original join point can be executed with the special syntax</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">proceed( ... )</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>proceed</code> form takes as arguments the context exposed by the around&#8217;s
pointcut, and returns whatever the around is declared to return. So the
following around advice will double the second argument to <code>foo</code>
whenever it is called, and then halve its result:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect A {
  <span class="type">int</span> around(<span class="type">int</span> i): call(<span class="type">int</span> C.foo(<span class="predefined-type">Object</span>, <span class="type">int</span>)) &amp;&amp; args(i) {
    <span class="type">int</span> newi = proceed(i*<span class="integer">2</span>)
    <span class="keyword">return</span> newi/<span class="integer">2</span>;
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the return value of <code>around</code> advice is typed to <code>Object</code>, then the
result of proceed is converted to an object representation, even if it
is originally a primitive value. And when the advice returns an <code>Object</code>
value, that value is converted back to whatever representation it was
originally. So another way to write the doubling and halving advice is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect A {
  <span class="predefined-type">Object</span> around(<span class="type">int</span> i): call(<span class="type">int</span> C.foo(<span class="predefined-type">Object</span>, <span class="type">int</span>)) &amp;&amp; args(i) {
    <span class="predefined-type">Integer</span> newi = (<span class="predefined-type">Integer</span>) proceed(i*<span class="integer">2</span>)
    <span class="keyword">return</span> <span class="keyword">new</span> <span class="predefined-type">Integer</span>(newi.intValue() / <span class="integer">2</span>);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Any occurence of <code>proceed(..)</code> within the body of around advice is
treated as the special <code>proceed</code> form (even if the aspect defines a method
named <code>proceed</code>), unless a target other than the aspect instance is
specified as the recipient of the call. For example, in the following
program the first call to <code>proceed</code> will be treated as a method call to
the <code>ICanProceed</code> instance, whereas the second call to <code>proceed</code> is
treated as the special <code>proceed</code> form.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect A {
  <span class="predefined-type">Object</span> around(ICanProceed canProceed) : execution(* *(..)) &amp;&amp; <span class="local-variable">this</span>(canProceed) {
    canProceed.proceed();        <span class="comment">// a method call</span>
    <span class="keyword">return</span> proceed(canProceed);  <span class="comment">// the special proceed form</span>
  }

  <span class="directive">private</span> <span class="predefined-type">Object</span> proceed(ICanProceed canProceed) {
    <span class="comment">// this method cannot be called from inside the body of around advice</span>
    <span class="comment">// in the aspect</span>
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In all kinds of advice, the parameters of the advice behave exactly like
method parameters. In particular, assigning to any parameter affects
only the value of the parameter, not the value that it came from. This
means that</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect A {
  after() returning (<span class="type">int</span> i): call(<span class="type">int</span> C.foo()) {
    i = i * <span class="integer">2</span>;
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>will <em>not</em> double the returned value of the advice. Rather, it will
double the local parameter. Changing the values of parameters or return
values of join points can be done by using <code>around</code> advice.</p>
</div>
<div class="paragraph">
<p>With <code>proceed(..)</code> it is possible to change the values used by
less-precedent advice and the underlying join point by supplying
different values for the variables. For example, this aspect replaces
the string bound to <code>s</code> in the named pointcut <code>privateData</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect A {
  <span class="predefined-type">Object</span> around(<span class="predefined-type">String</span> s): MyPointcuts.privateData(s) {
    <span class="keyword">return</span> proceed(<span class="string"><span class="delimiter">&quot;</span><span class="content">private data</span><span class="delimiter">&quot;</span></span>);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you replace an argument to <code>proceed(..)</code>, you can cause a
<code>ClassCastException</code> at runtime when the argument refers to a supertype
of the actual type and you do not supply a reference of the actual type.
In the following aspect, the around advice replaces the declared target
<code>List</code> with an <code>ArrayList</code>. This is valid code at compile-time since the
types match.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">java.util</span>.*;

aspect A {
  <span class="predefined-type">Object</span> around(<span class="predefined-type">List</span> list): call(* <span class="predefined-type">List</span>+.*()) &amp;&amp; target(list) {
    <span class="keyword">return</span> proceed(<span class="keyword">new</span> <span class="predefined-type">ArrayList</span>());
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>But imagine a simple program where the actual target is <code>LinkedList</code>. In
this case, the advice would cause a <code>ClassCastException</code> at runtime, and
<code>peek()</code> is not declared in <code>ArrayList</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Test</span> {
  <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
    <span class="keyword">new</span> <span class="predefined-type">LinkedList</span>().peek();
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>ClassCastException</code> can occur even in situations where it appears
to be unnecessary, e.g., if the program is changed to call <code>size()</code>,
declared in <code>List</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Test</span> {
  <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
    <span class="keyword">new</span> <span class="predefined-type">LinkedList</span>().size();
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There will still be a <code>ClassCastException</code> because it is impossible to
prove that there won&#8217;t be a runtime binary-compatible change in the
hierarchy of <code>LinkedList</code> or some other advice on the join point that
requires a <code>LinkedList</code>.</p>
</div>
<div class="sect3">
<h4 id="_advice_modifiers">Advice modifiers</h4>
<div class="paragraph">
<p>The <code>strictfp</code> modifier is the only modifier allowed on advice, and it
has the effect of making all floating-point expressions within the
advice be FP-strict.</p>
</div>
</div>
<div class="sect3">
<h4 id="_advice_and_checked_exceptions">Advice and checked exceptions</h4>
<div class="paragraph">
<p>An advice declaration must include a <code>throws</code> clause listing the checked
exceptions the body may throw. This list of checked exceptions must be
compatible with each target join point of the advice, or an error is
signalled by the compiler.</p>
</div>
<div class="paragraph">
<p>For example, in the following declarations:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">java.io.FileNotFoundException</span>;

<span class="type">class</span> <span class="class">C</span> {
  <span class="type">int</span> i;
  <span class="type">int</span> getI() { <span class="keyword">return</span> i; }
}

aspect A {
  before(): get(<span class="type">int</span> C.i) {
    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">FileNotFoundException</span>();
  }

  before() <span class="directive">throws</span> <span class="exception">FileNotFoundException</span>: get(<span class="type">int</span> C.i) {
    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">FileNotFoundException</span>();
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>both pieces of advice are illegal. The first because the body throws an
undeclared checked exception, and the second because field get join
points cannot throw <code>FileNotFoundException</code>s.</p>
</div>
<div class="paragraph">
<p>The exceptions that each kind of join point in AspectJ may throw are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">method call and execution</dt>
<dd>
<p>the checked exceptions declared by the target method&#8217;s <code>throws</code> clause.</p>
</dd>
<dt class="hdlist1">constructor call and execution</dt>
<dd>
<p>the checked exceptions declared by the target constructor&#8217;s <code>throws</code> clause.</p>
</dd>
<dt class="hdlist1">field get and set</dt>
<dd>
<p>no checked exceptions can be thrown from these join points.</p>
</dd>
<dt class="hdlist1">exception handler execution</dt>
<dd>
<p>the exceptions that can be thrown by the target exception handler.</p>
</dd>
<dt class="hdlist1">static initializer execution</dt>
<dd>
<p>no checked exceptions can be thrown from these join points.</p>
</dd>
<dt class="hdlist1">pre-initialization and initialization</dt>
<dd>
<p>any exception that is in the <code>throws</code> clause of all constructors of the initialized class.</p>
</dd>
<dt class="hdlist1">advice execution</dt>
<dd>
<p>any exception that is in the <code>throws</code> clause of the advice.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_advice_precedence">Advice precedence</h4>
<div class="paragraph">
<p>Multiple pieces of advice may apply to the same join point. In such
cases, the resolution order of the advice is based on advice precedence.</p>
</div>
<div class="sect4">
<h5 id="_determining_precedence">Determining precedence</h5>
<div class="paragraph">
<p>There are a number of rules that determine whether a particular piece of
advice has precedence over another when they advise the same join point.</p>
</div>
<div class="paragraph">
<p>If the two pieces of advice are defined in different aspects, then there
are three cases:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If aspect <code>A</code> is matched earlier than aspect <code>B</code> in some <code>declare precedence</code>
form, then all advice in concrete aspect <code>A</code> has precedence over all
advice in concrete aspect <code>B</code> when they are on the same join point.</p>
</li>
<li>
<p>Otherwise, if aspect <code>A</code> is a subaspect of aspect <code>B</code>, then all advice
defined in <code>A</code> has precedence over all advice defined in <code>B</code>. So, unless
otherwise specified with <code>declare precedence</code>, advice in a subaspect has
precedence over advice in a superaspect.</p>
</li>
<li>
<p>Otherwise, if two pieces of advice are defined in two different
aspects, it is undefined which one has precedence.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If the two pieces of advice are defined in the same aspect, then there
are two cases:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If either are <code>after</code> advice, then the one that appears later in the aspect has precedence
over the one that appears earlier.</p>
</li>
<li>
<p>Otherwise, then the one that appears earlier in the aspect has
precedence over the one that appears later.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These rules can lead to circularity, such as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect A {
  before(): execution(<span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args)) {}
  after():  execution(<span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args)) {}
  before(): execution(<span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args)) {}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>such circularities will result in errors signalled by the compiler.</p>
</div>
</div>
<div class="sect4">
<h5 id="_effects_of_precedence">Effects of precedence</h5>
<div class="paragraph">
<p>At a particular join point, advice is ordered by precedence.</p>
</div>
<div class="paragraph">
<p>A piece of <code>around</code> advice controls whether advice of lower precedence
will run by calling <code>proceed</code>. The call to <code>proceed</code> will run the advice
with next precedence, or the computation under the join point if there
is no further advice.</p>
</div>
<div class="paragraph">
<p>A piece of <code>before</code> advice can prevent advice of lower precedence from
running by throwing an exception. If it returns normally, however, then
the advice of the next precedence, or the computation under the join
pint if there is no further advice, will run.</p>
</div>
<div class="paragraph">
<p>Running <code>after returning</code> advice will run the advice of next precedence,
or the computation under the join point if there is no further advice.
Then, if that computation returned normally, the body of the advice will
run.</p>
</div>
<div class="paragraph">
<p>Running <code>after throwing</code> advice will run the advice of next precedence,
or the computation under the join point if there is no further advice.
Then, if that computation threw an exception of an appropriate type, the
body of the advice will run.</p>
</div>
<div class="paragraph">
<p>Running <code>after</code> advice will run the advice of next precedence, or the
computation under the join point if there is no further advice. Then the
body of the advice will run.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_reflective_access_to_the_join_point">Reflective access to the join point</h4>
<div class="paragraph">
<p>Three special variables are visible within bodies of advice and within
<code>if()</code> pointcut expressions: <code>thisJoinPoint</code>, <code>thisJoinPointStaticPart</code>,
and <code>thisEnclosingJoinPointStaticPart</code>. Each is bound to an object that
encapsulates some of the context of the advice&#8217;s current or enclosing
join point. These variables exist because some pointcuts may pick out
very large collections of join points. For example, the pointcut</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">pointcut publicCall(): call(<span class="directive">public</span> * *(..));</code></pre>
</div>
</div>
<div class="paragraph">
<p>picks out calls to many methods. Yet the body of advice over this
pointcut may wish to have access to the method name or parameters of a
particular join point.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>thisJoinPoint</code> is bound to a complete join point object.</p>
</li>
<li>
<p><code>thisJoinPointStaticPart</code> is bound to a part of the join point object
that includes less information, but for which no memory allocation is
required on each execution of the advice. It is equivalent to
<code>thisJoinPoint.getStaticPart()</code>.</p>
</li>
<li>
<p><code>thisEnclosingJoinPointStaticPart</code> is bound to the static part of the
join point enclosing the current join point. Only the static part of
this enclosing join point is available through this mechanism.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Standard Java reflection uses objects from the <code>java.lang.reflect</code>
hierarchy to build up its reflective objects. Similarly, AspectJ join
point objects have types in a type hierarchy. The type of objects bound
to <code>thisJoinPoint</code> is <code>org.aspectj.lang.JoinPoint</code>, while
<code>thisStaticJoinPoint</code> is bound to objects of interface type
<code>org.aspectj.lang.JoinPoint.StaticPart</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="semantics-declare">Static crosscutting</h3>
<div class="paragraph">
<p>Advice declarations change the behavior of classes they crosscut, but do
not change their static type structure. For crosscutting concerns that
do operate over the static structure of type hierarchies, AspectJ
provides inter-type member declarations and other <code>declare</code> forms.</p>
</div>
<div class="sect3">
<h4 id="_inter_type_member_declarations">Inter-type member declarations</h4>
<div class="paragraph">
<p>AspectJ allows the declaration of members by aspects that are associated
with other types.</p>
</div>
<div class="paragraph">
<p>An inter-type method declaration looks like</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>[ Modifiers ] Type OnType . Id ( Formals ) [ ThrowsClause ] { Body }</code></p>
</li>
<li>
<p><code>abstract [ Modifiers ] Type OnType . Id ( Formals ) [ ThrowsClause ] ;</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The effect of such a declaration is to make <code>OnType</code> support the new
method. Even if <code>OnType</code> is an interface. Even if the method is neither
public nor abstract. So the following is legal AspectJ code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">interface</span> <span class="class">Iface</span> {}

aspect A {
  <span class="directive">private</span> <span class="type">void</span> Iface.m() {
    <span class="predefined-type">System</span>.err.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">I'm a private method on an interface</span><span class="delimiter">&quot;</span></span>);
  }

  <span class="type">void</span> worksOnI(Iface iface) {
    <span class="comment">// calling a private method on an interface</span>
    iface.m();
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>An inter-type constructor declaration looks like</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>[ Modifiers ] OnType . new ( Formals ) [ ThrowsClause ] { Body }</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The effect of such a declaration is to make <code>OnType</code> support the new
constructor. It is an error for <code>OnType</code> to be an interface.</p>
</div>
<div class="paragraph">
<p>Inter-type declared constructors cannot be used to assign a value to a
final variable declared in <code>OnType</code>. This limitation significantly
increases the ability to both understand and compile the <code>OnType</code> class
and the declaring aspect separately.</p>
</div>
<div class="paragraph">
<p>Note that in the Java language, classes that define no constructors have
an implicit no-argument constructor that just calls <code>super()</code>. This
means that attempting to declare a no-argument inter-type constructor on
such a class may result in a conflict, even though it <em>looks</em> like no
constructor is defined.</p>
</div>
<div class="paragraph">
<p>An inter-type field declaration looks like one of</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>[ Modifiers ] Type OnType . Id = Expression ;</code></p>
</li>
<li>
<p><code>[ Modifiers ] Type OnType . Id ;</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The effect of such a declaration is to make <code>OnType</code> support the new
field. Even if <code>OnType</code> is an interface. Even if the field is neither
public, nor static, nor final.</p>
</div>
<div class="paragraph">
<p>The initializer, if any, of an inter-type field declaration runs before
the class-local initializers defined in its target class.</p>
</div>
<div class="paragraph">
<p>Any occurrence of the identifier <code>this</code> in the body of an inter-type
constructor or method declaration, or in the initializer of an
inter-type field declaration, refers to the <code>OnType</code> object rather than
to the aspect type; it is an error to access <code>this</code> in such a position
from a <code>static</code> inter-type member declaration.</p>
</div>
</div>
<div class="sect3">
<h4 id="_access_modifiers">Access modifiers</h4>
<div class="paragraph">
<p>Inter-type member declarations may be <code>public</code> or <code>private</code>, or have default
(package-protected) visibility. AspectJ does not provide protected
inter-type members.</p>
</div>
<div class="paragraph">
<p>The access modifier applies in relation to the aspect, not in relation
to the target type. So a private inter-type member is visible only from
code that is defined within the declaring aspect. A default-visibility
inter-type member is visible only from code that is defined within the
declaring aspect&#8217;s package.</p>
</div>
<div class="paragraph">
<p>Note that a declaring a private inter-type method (which AspectJ
supports) is very different from inserting a private method declaration
into another class. The former allows access only from the declaring
aspect, while the latter would allow access only from the target type.
Java serialization, for example, uses the presense of a private method
<code>void writeObject(ObjectOutputStream)</code> for the implementation of
<code>java.io.Serializable</code>. A private inter-type declaration of that method
would not fulfill this requirement, since it would be private to the
aspect, not private to the target type.</p>
</div>
<div class="paragraph">
<p>The access modifier of abstract inter-type methods has one constraint:
It is illegal to declare an abstract non-public inter-type method on a
public interface. This is illegal because it would say that a public
interface has a constraint that only non-public implementors must
fulfill. This would not be compatible with Java&#8217;s type system.</p>
</div>
</div>
<div class="sect3">
<h4 id="_conflicts">Conflicts</h4>
<div class="paragraph">
<p>Inter-type declarations raise the possibility of conflicts among locally
declared members and inter-type members. For example, assuming
<code>otherPackage</code> is not the package containing the aspect <code>A</code>, the code</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect A {
  <span class="directive">private</span> <span class="predefined-type">Registry</span> otherPackage.onType.r;

  <span class="directive">public</span> <span class="type">void</span> otherPackage.onType.register(<span class="predefined-type">Registry</span> r) {
    r.register(<span class="local-variable">this</span>);
    <span class="local-variable">this</span>.r = r;
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>declares that <code>onType</code> in <code>otherPackage</code> has a field <code>r</code>. This field,
however, is only accessible from the code inside of aspect <code>A</code>. The
aspect also declares that <code>onType</code> has a method &#8220;register&#8221;, but makes
this method accessible from everywhere.</p>
</div>
<div class="paragraph">
<p>If <code>onType</code> already defines a private or package-protected field <code>r</code>,
there is no conflict: The aspect cannot see such a field, and no code in
<code>otherPackage</code> can see the inter-type <code>r</code>.</p>
</div>
<div class="paragraph">
<p>If <code>onType</code> defines a public field <code>r</code>, there is a conflict: The
expression</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="local-variable">this</span>.r = r</code></pre>
</div>
</div>
<div class="paragraph">
<p>is an error, since it is ambiguous whether the private inter-type <code>r</code>
or the public locally-defined <code>r</code> should be used.</p>
</div>
<div class="paragraph">
<p>If <code>onType</code> defines a method <code>register(Registry)</code> there is a conflict,
since it would be ambiguous to any code that could see such a defined
method which <code>register(Registry)</code> method was applicable.</p>
</div>
<div class="paragraph">
<p>Conflicts are resolved as much as possible as per Java&#8217;s conflict
resolution rules:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A subclass can inherit multiple fields from its superclasses, all with the
same name and type. However, it is an error to have an ambiguous reference
to a field.</p>
</li>
<li>
<p>A subclass can only inherit multiple methods with the same name and argument
types from its superclasses if only zero or one of them is concrete (i.e., all
but one is abstract, or all are abstract).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Given a potential conflict between inter-type member declarations in
different aspects, if one aspect has precedence over the other its
declaration will take effect without any conflict notice from compiler.
This is true both when the precedence is declared explicitly with
<code>declare precedence</code> as well as when when sub-aspects implicitly have
precedence over their super-aspect.</p>
</div>
</div>
<div class="sect3">
<h4 id="_extension_and_implementation">Extension and Implementation</h4>
<div class="paragraph">
<p>An aspect may change the inheritance hierarchy of a system by changing
the superclass of a type or adding a superinterface onto a type, with
the <code>declare parents</code> form.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>declare parents: TypePattern extends Type ;</code></p>
</li>
<li>
<p><code>declare parents: TypePattern implements TypeList ;</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For example, if an aspect wished to make a particular class runnable, it
might define appropriate inter-type <code>void
        run()</code> method, but it should also declare that the class
fulfills the <code>Runnable</code> interface. In order to implement the methods in
the <code>Runnable</code> interface, the inter-type <code>run()</code> method must be public:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect A {
  declare parents: SomeClass <span class="directive">implements</span> <span class="predefined-type">Runnable</span>;

  <span class="directive">public</span> <span class="type">void</span> SomeClass.run() { ... }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_interfaces_with_members">Interfaces with members</h4>
<div class="paragraph">
<p>Through the use of inter-type members, interfaces may now carry
(non-public-static-final) fields and (non-public-abstract) methods that
classes can inherit. Conflicts may occur from ambiguously inheriting
members from a superclass and multiple superinterfaces.</p>
</div>
<div class="paragraph">
<p>Because interfaces may carry non-static initializers, each interface
behaves as if it has a zero-argument constructor containing its
initializers. The order of super-interface instantiation is observable.
We fix this order with the following properties: A supertype is
initialized before a subtype, initialized code runs only once, and the
initializers for a type&#8217;s superclass are run before the initializers for
its superinterfaces. Consider the following hierarchy where {<code>Object</code>,
<code>C</code>, <code>D</code>, <code>E</code>} are classes, {<code>M</code>, <code>N</code>, <code>O</code>, <code>P</code>, <code>Q</code>} are interfaces.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">Object  M   O
     \ / \ /
      C   N   Q
       \ /   /
        D   P
         \ /
          E</code></pre>
</div>
</div>
<div class="paragraph">
<p>when a new <code>E</code> is instantiated, the initializers run in this order:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">Object M C O N D Q P E</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_warnings_and_errors">Warnings and Errors</h4>
<div class="paragraph">
<p>An aspect may specify that a particular join point should never be
reached.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>declare error: Pointcut : String ;</code></p>
</li>
<li>
<p><code>declare warning: Pointcut : String ;</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If the compiler determines that a join point in <code>Pointcut</code> could
possibly be reached, then it will signal either an error or warning, as
declared, using the <code>String</code> for its message.</p>
</div>
</div>
<div class="sect3">
<h4 id="_softened_exceptions">Softened exceptions</h4>
<div class="paragraph">
<p>An aspect may specify that a particular kind of exception, if thrown at
a join point, should bypass Java&#8217;s usual static exception checking
system and instead be thrown as a <code>org.aspectj.lang.SoftException</code>,
which is subtype of <code>RuntimeException</code> and thus does not need to be
declared.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>declare soft: Type : Pointcut ;</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For example, the aspect</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect A {
  declare soft: <span class="exception">Exception</span>: execution(<span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Would, at the execution join point, catch any <code>Exception</code> and rethrow a
<code>org.aspectj.lang.SoftException</code> containing original exception.</p>
</div>
<div class="paragraph">
<p>This is similar to what the following advice would do</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect A {
  <span class="type">void</span> around() execution(<span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args)) {
    <span class="keyword">try</span> { proceed(); }
    <span class="keyword">catch</span> (<span class="exception">Exception</span> e) {
      <span class="keyword">throw</span> <span class="keyword">new</span> org.aspectj.lang.SoftException(e);
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>except, in addition to wrapping the exception, it also affects Java&#8217;s
static exception checking mechanism.</p>
</div>
<div class="paragraph">
<p>Like advice, the declare soft form has no effect in an abstract aspect
that is not extended by a concreate aspect. So the following code will
not compile unless it is compiled with an extending concrete aspect:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">abstract</span> aspect A {
  <span class="directive">abstract</span> pointcut softeningPC();

  before() : softeningPC() {
    <span class="predefined-type">Class</span>.forName(<span class="string"><span class="delimiter">&quot;</span><span class="content">FooClass</span><span class="delimiter">&quot;</span></span>); <span class="comment">// error:  uncaught ClassNotFoundException</span>
  }

  declare soft : <span class="exception">ClassNotFoundException</span> : call(* <span class="predefined-type">Class</span>.*(..));
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="advice-precedence-cross">Advice Precedence</h4>
<div class="paragraph">
<p>An aspect may declare a precedence relationship between concrete aspects
with the <code>declare precedence</code> form:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>declare precedence : TypePatternList ;</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This signifies that if any join point has advice from two concrete
aspects matched by some pattern in <code>TypePatternList</code>, then the
precedence of the advice will be the order of in the list.</p>
</div>
<div class="paragraph">
<p>In <code>TypePatternList</code>, the wildcard <code>*</code> can appear at most once, and it
means "any type not matched by any other pattern in the list".</p>
</div>
<div class="paragraph">
<p>For example, the constraints that (1) aspects that have Security as part
of their name should have precedence over all other aspects, and (2) the
Logging aspect (and any aspect that extends it) should have precedence
over all non-security aspects, can be expressed by:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">declare precedence: *..*<span class="predefined-type">Security</span>*, Logging+, *;</code></pre>
</div>
</div>
<div class="paragraph">
<p>For another example, the <code>CountEntry</code> aspect might want to count the entry
to methods in the current package accepting a Type object as its first
argument. However, it should count all entries, even those that the
aspect <code>DisallowNulls</code> causes to throw exceptions. This can be
accomplished by stating that <code>CountEntry</code> has precedence over
<code>DisallowNulls</code>. This declaration could be in either aspect, or in
another, ordering aspect:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect Ordering {
  declare precedence: CountEntry, DisallowNulls;
}

aspect DisallowNulls {
  pointcut allTypeMethods(<span class="predefined-type">Type</span> obj): call(* *(..)) &amp;&amp; args(obj, ..);
  before(<span class="predefined-type">Type</span> obj):  allTypeMethods(obj) {
    <span class="keyword">if</span> (obj == <span class="predefined-constant">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">RuntimeException</span>();
  }
}

aspect CountEntry {
  pointcut allTypeMethods(<span class="predefined-type">Type</span> obj): call(* *(..)) &amp;&amp; args(obj, ..);
  <span class="directive">static</span> <span class="type">int</span> count = <span class="integer">0</span>;
  before():  allTypeMethods(<span class="predefined-type">Type</span>) {
    count++;
  }
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_various_cycles">Various cycles</h5>
<div class="paragraph">
<p>It is an error for any aspect to be matched by more than one TypePattern
in a single decare precedence, so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">declare precedence:  A, B, A ;  <span class="comment">// error</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>However, multiple declare precedence forms may legally have this kind of
circularity. For example, each of these declare precedence is perfectly
legal:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">declare precedence: B, A;
declare precedence: A, B;</code></pre>
</div>
</div>
<div class="paragraph">
<p>And a system in which both constraints are active may also be legal, so
long as advice from <code>A</code> and <code>B</code> don&#8217;t share a join point. So this is an
idiom that can be used to enforce that <code>A</code> and <code>B</code> are strongly independent.</p>
</div>
</div>
<div class="sect4">
<h5 id="_applies_to_concrete_aspects">Applies to concrete aspects</h5>
<div class="paragraph">
<p>Consider the following library aspects:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">abstract</span> aspect Logging {
  <span class="directive">abstract</span> pointcut logged();

  before(): logged() {
    <span class="predefined-type">System</span>.err.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">thisJoinPoint: </span><span class="delimiter">&quot;</span></span> + thisJoinPoint);
  }
}

<span class="directive">abstract</span> aspect MyProfiling {
  <span class="directive">abstract</span> pointcut profiled();

  <span class="predefined-type">Object</span> around(): profiled() {
    <span class="type">long</span> beforeTime = <span class="predefined-type">System</span>.currentTimeMillis();
    <span class="keyword">try</span> {
      <span class="keyword">return</span> proceed();
    } <span class="keyword">finally</span> {
      <span class="type">long</span> afterTime = <span class="predefined-type">System</span>.currentTimeMillis();
      addToProfile(thisJoinPointStaticPart, afterTime - beforeTime);
    }
  }

  <span class="directive">abstract</span> <span class="type">void</span> addToProfile(
    org.aspectj.JoinPoint.StaticPart jp,
    <span class="type">long</span> elapsed
  );
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In order to use either aspect, they must be extended with concrete
aspects, say, MyLogging and MyProfiling. Because advice only applies
from concrete aspects, the declare precedence form only matters when
declaring precedence with concrete aspects. So</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">declare precedence: Logging, Profiling;</code></pre>
</div>
</div>
<div class="paragraph">
<p>has no effect, but both</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">declare precedence: MyLogging, MyProfiling;
declare precedence: Logging+, Profiling+;</code></pre>
</div>
</div>
<div class="paragraph">
<p>are meaningful.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_statically_determinable_pointcuts">Statically determinable pointcuts</h4>
<div class="paragraph">
<p>Pointcuts that appear inside of <code>declare</code> forms have certain
restrictions. Like other pointcuts, these pick out join points, but they
do so in a way that is statically determinable.</p>
</div>
<div class="paragraph">
<p>Consequently, such pointcuts may not include, directly or indirectly
(through user-defined pointcut declarations) pointcuts that discriminate
based on dynamic (runtime) context. Therefore, such pointcuts may not be
defined in terms of</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>cflow</code></p>
</li>
<li>
<p><code>cflowbelow</code></p>
</li>
<li>
<p><code>this</code></p>
</li>
<li>
<p><code>target</code></p>
</li>
<li>
<p><code>args</code></p>
</li>
<li>
<p><code>if</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>all of which can discriminate on runtime information.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="semantics-aspects">Aspects</h3>
<div class="paragraph">
<p>An aspect is a crosscutting type defined by the <code>aspect</code> declaration.</p>
</div>
<div class="sect3">
<h4 id="_aspect_declaration">Aspect Declaration</h4>
<div class="paragraph">
<p>The <code>aspect</code> declaration is similar to the <code>class</code> declaration in that
it defines a type and an implementation for that type. It differs in a
number of ways:</p>
</div>
<div class="sect4">
<h5 id="_aspect_implementation_can_cut_across_other_types">Aspect implementation can cut across other types</h5>
<div class="paragraph">
<p>In addition to normal Java class declarations such as methods and
fields, aspect declarations can include AspectJ declarations such as
advice, pointcuts, and inter-type declarations. Thus, aspects contain
implementation declarations that can can cut across other types
(including those defined by other aspect declarations).</p>
</div>
</div>
<div class="sect4">
<h5 id="_aspects_are_not_directly_instantiated">Aspects are not directly instantiated</h5>
<div class="paragraph">
<p>Aspects are not directly instantiated with a new expression, with
cloning, or with serialization. Aspects may have one constructor
definition, but if so it must be of a constructor taking no arguments
and throwing no checked exceptions.</p>
</div>
</div>
<div class="sect4">
<h5 id="_nested_aspects_must_be_static">Nested aspects must be <code>static</code></h5>
<div class="paragraph">
<p>Aspects may be defined either at the package level, or as a <code>static</code>
nested aspect&#8201;&#8212;&#8201;that is, a <code>static</code> member of a class, interface, or
aspect. If it is not at the package level, the aspect <em>must</em> be defined
with the <code>static</code> keyword. Local and anonymous aspects are not allowed.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_aspect_extension">Aspect Extension</h4>
<div class="paragraph">
<p>To support abstraction and composition of crosscutting concerns, aspects
can be extended in much the same way that classes can. Aspect extension
adds some new rules, though.</p>
</div>
<div class="sect4">
<h5 id="_aspects_may_extend_classes_and_implement_interfaces">Aspects may extend classes and implement interfaces</h5>
<div class="paragraph">
<p>An aspect, abstract or concrete, may extend a class and may implement a
set of interfaces. Extending a class does not provide the ability to
instantiate the aspect with a new expression: The aspect may still only
define a null constructor.</p>
</div>
</div>
<div class="sect4">
<h5 id="_classes_may_not_extend_aspects">Classes may not extend aspects</h5>
<div class="paragraph">
<p>It is an error for a class to extend or implement an aspect.</p>
</div>
</div>
<div class="sect4">
<h5 id="_aspects_extending_aspects">Aspects extending aspects</h5>
<div class="paragraph">
<p>Aspects may extend other aspects, in which case not only are fields and
methods inherited but so are pointcuts. However, aspects may only extend
abstract aspects. It is an error for a concrete aspect to extend another
concrete aspect.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_aspect_instantiation">Aspect instantiation</h4>
<div class="paragraph">
<p>Unlike class expressions, aspects are not instantiated with <code>new</code>
expressions. Rather, aspect instances are automatically created to cut
across programs. A program can get a reference to an aspect instance
using the static method <code>aspectOf(..)</code>.</p>
</div>
<div class="paragraph">
<p>Because advice only runs in the context of an aspect instance, aspect
instantiation indirectly controls when advice runs.</p>
</div>
<div class="paragraph">
<p>The criteria used to determine how an aspect is instantiated is
inherited from its parent aspect. If the aspect has no parent aspect,
then by default the aspect is a singleton aspect. How an aspect is
instantiated controls the form of the <code>aspectOf(..)</code> method defined on
the concrete aspect class.</p>
</div>
<div class="sect4">
<h5 id="_singleton_aspects">Singleton Aspects</h5>
<div class="ulist">
<ul>
<li>
<p><code>aspect Id { &#8230;&#8203; }</code></p>
</li>
<li>
<p><code>aspect Id issingleton() { &#8230;&#8203; }</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>By default (or by using the modifier <code>issingleton()</code>) an aspect has
exactly one instance that cuts across the entire program. That instance
is available at any time during program execution from the static method
<code>aspectOf()</code> automatically defined on all concrete aspects&#8201;&#8212;&#8201;so, in the
above examples, <code>A.aspectOf()</code> will return <code>A</code>'s instance. This aspect
instance is created as the aspect&#8217;s classfile is loaded.</p>
</div>
<div class="paragraph">
<p>Because the an instance of the aspect exists at all join points in the
running of a program (once its class is loaded), its advice will have a
chance to run at all such join points.</p>
</div>
<div class="paragraph">
<p>(In actuality, one instance of the aspect <code>A</code> is made for each version of
the aspect <code>A</code>, so there will be one instantiation for each time <code>A</code> is
loaded by a different classloader.)</p>
</div>
</div>
<div class="sect4">
<h5 id="_per_object_aspects">Per-object aspects</h5>
<div class="ulist">
<ul>
<li>
<p><code>aspect Id perthis( Pointcut ) { &#8230;&#8203; }</code></p>
</li>
<li>
<p><code>aspect Id pertarget( Pointcut ) { &#8230;&#8203; }</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If an aspect <code>A</code> is defined <code>perthis(Pointcut)</code>, then one object of type <code>A</code>
is created for every object that is the executing object (i.e., <code>this</code>)
at any of the join points picked out by <code>Pointcut</code>. The advice defined
in <code>A</code> will run only at a join point where the currently executing object
has been associated with an instance of <code>A</code>.</p>
</div>
<div class="paragraph">
<p>Similarly, if an aspect <code>A</code> is defined <code>pertarget(Pointcut)</code>, then one
object of type <code>A</code> is created for every object that is the target object
of the join points picked out by <code>Pointcut</code>. The advice defined in <code>A</code>
will run only at a join point where the target object has been
associated with an instance of <code>A</code>.</p>
</div>
<div class="paragraph">
<p>In either case, the static method call <code>A.aspectOf(Object)</code> can be used
to get the aspect instance (of type <code>A</code>) registered with the object. Each
aspect instance is created as early as possible, but not before reaching
a join point picked out by <code>Pointcut</code> where there is no associated
aspect of type <code>A</code>.</p>
</div>
<div class="paragraph">
<p>Both <code>perthis</code> and <code>pertarget</code> aspects may be affected by code the
AspectJ compiler controls, as discussed in the <a href="#implementation">Implementation Notes</a>
appendix.</p>
</div>
</div>
<div class="sect4">
<h5 id="_per_control_flow_aspects">Per-control-flow aspects</h5>
<div class="ulist">
<ul>
<li>
<p><code>aspect Id percflow( Pointcut ) { &#8230;&#8203; }</code></p>
</li>
<li>
<p><code>aspect Id percflowbelow( Pointcut ) { &#8230;&#8203; }</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If an aspect <code>A</code> is defined <code>percflow(Pointcut)</code> or
<code>percflowbelow(Pointcut)</code>, then one object of type <code>A</code> is created for each
flow of control of the join points picked out by <code>Pointcut</code>, either as
the flow of control is entered, or below the flow of control,
respectively. The advice defined in <code>A</code> may run at any join point in or
under that control flow. During each such flow of control, the static
method <code>A.aspectOf()</code> will return an object of type <code>A</code>. An instance of
the aspect is created upon entry into each such control flow.</p>
</div>
</div>
<div class="sect4">
<h5 id="_aspect_instantiation_and_advice">Aspect instantiation and advice</h5>
<div class="paragraph">
<p>All advice runs in the context of an aspect instance, but it is possible
to write a piece of advice with a pointcut that picks out a join point
that must occur before asopect instantiation. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Client</span>
{
  <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
    Client c = <span class="keyword">new</span> Client();
  }
}

aspect Watchcall {
  pointcut myConstructor(): execution(<span class="keyword">new</span>(..));

  before(): myConstructor() {
    <span class="predefined-type">System</span>.err.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Entering Constructor</span><span class="delimiter">&quot;</span></span>);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The before advice should run before the execution of all constructors in
the system. It must run in the context of an instance of the Watchcall
aspect. The only way to get such an instance is to have Watchcall&#8217;s
default constructor execute. But before that executes, we need to run
the before advice&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>There is no general way to detect these kinds of circularities at
compile time. If advice runs before its aspect is instantiated, AspectJ
will throw a
<a href="../runtime-api/org/aspectj/lang/NoAspectBoundException.html"><code>org.aspectj.lang.NoAspectBoundException</code></a>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_aspect_privilege">Aspect privilege</h4>
<div class="ulist">
<ul>
<li>
<p><code>privileged aspect Id { &#8230;&#8203; }</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Code written in aspects is subject to the same access control rules as
Java code when referring to members of classes or aspects. So, for
example, code written in an aspect may not refer to members with default
(package-protected) visibility unless the aspect is defined in the same
package.</p>
</div>
<div class="paragraph">
<p>While these restrictions are suitable for many aspects, there may be
some aspects in which advice or inter-type members needs to access
private or protected resources of other types. To allow this, aspects
may be declared <code>privileged</code>. Code in priviliged aspects has access to
all members, even private ones.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">C</span> {
  <span class="directive">private</span> <span class="type">int</span> i = <span class="integer">0</span>;
  <span class="type">void</span> incI(<span class="type">int</span> x) { i = i+x; }
}

privileged aspect A {
  <span class="directive">static</span> <span class="directive">final</span> <span class="type">int</span> MAX = <span class="integer">1000</span>;

  before(<span class="type">int</span> x, C c): call(<span class="type">void</span> C.incI(<span class="type">int</span>)) &amp;&amp; target(c) &amp;&amp; args(x) {
    <span class="keyword">if</span> (c.i+x &gt; MAX) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">RuntimeException</span>();
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case, if <code>A</code> had not been declared <code>privileged</code>, the field reference
<code>c.i</code> would have resulted in an error signaled by the compiler.</p>
</div>
<div class="paragraph">
<p>If a privileged aspect can access multiple versions of a particular
member, then those that it could see if it were not privileged take
precedence. For example, in the code</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">C</span> {
  <span class="directive">private</span> <span class="type">int</span> i = <span class="integer">0</span>;
  <span class="type">void</span> foo() { }
}

privileged aspect A {
  <span class="directive">private</span> <span class="type">int</span> C.i = <span class="integer">999</span>;

  before(C c): call(<span class="type">void</span> C.foo()) target(c) {
    <span class="predefined-type">System</span>.out.println(c.i);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>A</code>'s private inter-type field <code>C.i</code>, initially bound to 999, will be
referenced in the body of the advice in preference to <code>C</code>'s privately
declared field, since <code>A</code> would have access to its own inter-type
fields even if it were not privileged.</p>
</div>
<div class="paragraph">
<p>Note that a privileged aspect can access private inter-type declarations
made by other aspects, since they are simply considered private members
of that other aspect.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="implementation">Implementation Notes</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_compiler_notes">Compiler Notes</h3>
<div class="paragraph">
<p>The initial implementations of AspectJ have all been compiler-based
implementations. Certain elements of AspectJ&#8217;s semantics are difficult
to implement without making modifications to the virtual machine, which
a compiler-based implementation cannot do. One way to deal with this
problem would be to specify only the behavior that is easiest to
implement. We have chosen a somewhat different approach, which is to
specify an ideal language semantics, as well as a clearly defined way in
which implementations are allowed to deviate from that semantics. This
makes it possible to develop conforming AspectJ implementations today,
while still making it clear what later, and presumably better,
implementations should do tomorrow.</p>
</div>
<div class="paragraph">
<p>According to the AspectJ language semantics, the declaration</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">before(): get(<span class="type">int</span> <span class="predefined-type">Point</span>.x) { <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">got x</span><span class="delimiter">&quot;</span></span>); }</code></pre>
</div>
</div>
<div class="paragraph">
<p>should advise all accesses of a field of type <code>int</code> and name <code>x</code> from
instances of type (or subtype of) <code>Point</code>. It should do this regardless of
whether all the source code performing the access was available at the
time the aspect containing this advice was compiled, whether changes
were made later, etc.</p>
</div>
<div class="paragraph">
<p>But AspectJ implementations are permitted to deviate from this in a
well-defined way&#8201;&#8212;&#8201;they are permitted to advise only accesses in <em>code
the implementation controls</em>. Each implementation is free within certain
bounds to provide its own definition of what it means to control code.</p>
</div>
<div class="paragraph">
<p>In the current AspectJ compiler, <em>ajc</em>, control of the code means having
bytecode for any aspects and all the code they should affect available
during the compile. This means that if some class <code>Client</code> contains code
with the expression <code>new Point().x</code> (which results in a field get join point at runtime), the
current AspectJ compiler will fail to advise that access, unless
<code>Client.java</code> or <code>Client.class</code> is compiled as well. It also means that join
points associated with code in native methods (including their execution
join points) cannot be advised.</p>
</div>
<div class="paragraph">
<p>Different join points have different requirements. Method and
constructor call join points can be advised only if <em>ajc</em> controls the
bytecode for the caller. Field reference or assignment join points can
be advised only if <em>ajc</em> controls the bytecode for the "caller", the code
actually making the reference or assignment. Initialization join points
can be advised only if <em>ajc</em> controls the bytecode of the type being
initialized, and execution join points can be advised only if <em>ajc</em>
controls the bytecode for the method or constructor body in question.
The end of an exception handler is underdetermined in bytecode, so <em>ajc</em>
will not implement after or around advice on handler join points.
Similarly, <em>ajc</em> cannot implement <code>around</code> advice on <code>initialization</code> or
<code>preinitialization</code> join points. In cases where <em>ajc</em> cannot implement
advice, it will emit a compile-time error noting this as a compiler
limitation.</p>
</div>
<div class="paragraph">
<p>Aspects that are defined <code>perthis</code> or <code>pertarget</code> also have restrictions
based on control of the code. In particular, at a join point where the
bytecode for the currently executing object is not available, an aspect
defined <code>perthis</code> of that join point will not be associated. So aspects
defined <code>perthis(Object)</code> will not create aspect instances for every
object unless <code>Object</code> is part of the compile. Similar restrictions apply
to <code>pertarget</code> aspects.</p>
</div>
<div class="paragraph">
<p>Inter-type declarations such as <code>declare parents</code> also have restrictions
based on control of the code. If the bytecode for the target of an
inter-type declaration is not available, then the inter-type declaration
is not made on that target. So, <code>declare parents : String implements MyInterface</code>
will not work for <code>java.lang.String</code>, unless <code>java.lang.String</code> is part of the compile.</p>
</div>
<div class="paragraph">
<p>When declaring members on interfaces, the implementation must control
both the interface and the top-level implementors of that interface (the
classes that implement the interface but do not have a superclass that
implements the interface). You may weave these separately, but be aware
that you will get runtime exceptions if you run the affected top-level
classes without the interface as produced by the same <em>ajc</em>
implementation. Any intertype declaration of an <code>abstract</code> method on an
interface must be specified as <code>public</code>, you will get a compile time error
message indicating this is a compiler limitation if you do not specify
<code>public</code>. A non-<code>abstract</code> method declared on an interface can use any
access modifier except protected. Note that this is different to normal
Java rules where all members declared in an interface are implicitly
<code>public</code>. Finally, note that one cannot define <code>static</code> fields or methods on
interfaces.</p>
</div>
<div class="paragraph">
<p>When declaring methods on target types, only methods declared <code>public</code> are
recognizable in the bytecode, so methods must be declared <code>public</code> to be
overridden in any subtype or to be called from code in a later compile
using the target type as a library.</p>
</div>
<div class="paragraph">
<p>Other AspectJ implementations, indeed, future versions of <em>ajc</em>, may
define <em>code the implementation controls</em> more liberally or
restrictively, so long as they comport with the Java language. For
example, the <code>call</code> pointcut does not pick out reflective calls to a
method implemented in
<code>java.lang.reflect.Method.invoke(Object, Object[])</code>. Some suggest that
the call "happens" and the call pointcut should pick it out, but the
AspectJ language shouldn&#8217;t anticipate what happens in code outside the
control of the implementation, even when it is a well-defined API in a
Java standard library.</p>
</div>
<div class="paragraph">
<p>The important thing to remember is that core concepts of AspectJ, such
as the join point, are unchanged, regardless of which implementation is
used. During your development, you will have to be aware of the
limitations of the <em>ajc</em> compiler you&#8217;re using, but these limitations
should not drive the design of your aspects.</p>
</div>
</div>
<div class="sect2">
<h3 id="_bytecode_notes">Bytecode Notes</h3>
<div class="sect3">
<h4 id="the-class-expression-and-string-plus">The <code>.class</code> expression and <code>String</code> <code>+</code></h4>
<div class="paragraph">
<p>The java language form <code>Foo.class</code> is implemented in bytecode with a
call to <code>Class.forName</code> guarded by an exception handler catching a
<code>ClassNotFoundException</code>.</p>
</div>
<div class="paragraph">
<p>The java language <code>+</code> operator, when applied to <code>String</code> arguments, is
implemented in bytecode by calls to <code>StringBuffer.append</code>.</p>
</div>
<div class="paragraph">
<p>In both of these cases, the current AspectJ compiler operates on the
bytecode implementation of these language features; in short, it
operates on what is really happening rather than what was written in
source code. This means that there may be call join points to
<code>Class.forName</code> or <code>StringBuffer.append</code> from programs that do not, at
first glance, appear to contain such calls:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">Test</span> {
  <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
    <span class="predefined-type">System</span>.out.println(Test.class);         <span class="comment">// calls Class.forName</span>
    <span class="predefined-type">System</span>.out.println(args[<span class="integer">0</span>] + args[<span class="integer">1</span>]);  <span class="comment">// calls StringBuffer.append</span>
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In short, the join point model of the current AspectJ compiler considers
these as valid join points.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_handler_join_point">The <code>handler()</code> join point</h4>
<div class="paragraph">
<p>The end of exception handlers cannot reliably be found in Java bytecode.
Instead of removing the <code>handler</code> join point entirely, the current AspectJ
compiler restricts what can be done with the <code>handler</code> join point:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>after</code> and <code>around</code> advice cannot apply to <code>handler</code> join points.</p>
</li>
<li>
<p>The control flow of a <code>handler</code> join point cannot be detected.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The first of these is relatively straightforward. If any piece of <code>after</code>
advice (returning, throwing, or "finally") would normally apply to a
<code>handler</code> join point, it will not in code output by the current AspectJ
compiler. A compiler warning is generated, whenever this is detected to
be the case. <code>before</code> advice is allowed.</p>
</div>
<div class="paragraph">
<p>The second is that the control flow of a <code>handler</code> join point is not
picked out. For example, the following pointcut</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">cflow(call(<span class="type">void</span> foo()) || handler(java.io.IOException))</code></pre>
</div>
</div>
<div class="paragraph">
<p>will capture all join points in the control flow of a call to
<code>void foo()</code>, but it will <em>not</em> capture those in the control flow of an
<code>IOException</code> handler. It is equivalent to <code>cflow(call(void foo()))</code>. In
general, <code>cflow(handler(Type))</code> will not pick out any join points, the
one exception to this is join points that occur during the execution of
any before advice on the handler.</p>
</div>
<div class="paragraph">
<p>This does not restrict programs from placing before advice on handlers
inside <em>other</em> control flows. This advice, for example, is perfectly
fine:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">before(): handler(java.io.IOException) &amp;&amp; cflow(<span class="type">void</span> parse()) {
  <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">about to handle an exception while parsing</span><span class="delimiter">&quot;</span></span>);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A source-code implementation of AspectJ (such as AspectJ 1.0.6) is able
to detect the endpoint of a handler join point, and as such will likely
have fewer such restrictions.</p>
</div>
</div>
<div class="sect3">
<h4 id="_initializers_and_inter_type_constructors">Initializers and Inter-type Constructors</h4>
<div class="paragraph">
<p>The code for Java initializers, such as the assignment to the field <code>d</code> in</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">C</span> {
  <span class="type">double</span> d = <span class="predefined-type">Math</span>.sqrt(<span class="integer">2</span>);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>are considered part of constructors by the time AspectJ gets ahold of
bytecode. That is, the assignment of <code>d</code> to the square root of two happens
<em>inside</em> the default constructor of <code>C</code>.</p>
</div>
<div class="paragraph">
<p>Thus inter-type constructors will not necessarily run a target type&#8217;s
initialization code. In particular, if the inter-type constructor calls
a super-constructor (as opposed to a <code>this</code> constructor), the target
type&#8217;s initialization code will <em>not</em> be run when that inter-type
constructor is called.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect A {
  C.new(<span class="predefined-type">Object</span> o) {}  <span class="comment">// implicitly calls super()</span>

  <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
    <span class="predefined-type">System</span>.out.println((<span class="keyword">new</span> C()    ).d);  <span class="comment">// prints 1.414...</span>
    <span class="predefined-type">System</span>.out.println((<span class="keyword">new</span> C(<span class="predefined-constant">null</span>)).d);  <span class="comment">// prints 0.0</span>
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is the job of an inter-type constructor to do all the required
initialization, or to delegate to a <code>this</code> constructor if necessary.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_annotation_style_notes">Annotation-style Notes</h3>
<div class="paragraph">
<p>Writing aspects in annotation-style is subject to the same bytecode
limitations since the binary aspects take the same form and are woven in
the same way. However, the implementation differences (e.g., the
mechanism for implementing <code>around</code> advice) may be apparent at runtime.
See the documentation on annotation-style for more information.</p>
</div>
</div>
<div class="sect2">
<h3 id="_summary_of_implementation_requirements">Summary of implementation requirements</h3>
<div class="paragraph">
<p>This summarizes the requirements of our implementation of AspectJ. For
more details, see the relevant sections of this guide.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The invoking code must be under the control of <em>ajc</em> for the following
join points:</p>
<div class="ulist">
<ul>
<li>
<p><code>call</code> join point</p>
</li>
<li>
<p><code>get</code> join point</p>
</li>
<li>
<p><code>set</code> join point</p>
</li>
</ul>
</div>
</li>
<li>
<p>The declaring/target code must be under the control of <em>ajc</em> for the
following join points and inter-type declarations:</p>
<div class="ulist">
<ul>
<li>
<p><code>execution</code> join point</p>
</li>
<li>
<p><code>adviceexecution</code> join point</p>
</li>
<li>
<p><code>handler</code> join point</p>
</li>
<li>
<p><code>initialization</code> join point</p>
</li>
<li>
<p><code>preinitialiaztion</code> join point</p>
</li>
<li>
<p><code>staticinitialization</code> join point</p>
</li>
<li>
<p><code>perthis</code> aspect</p>
</li>
<li>
<p><code>pertarget</code> aspect</p>
</li>
<li>
<p><code>declare <em>parents</em></code></p>
</li>
<li>
<p><code>declare <em>method</em> | <em>field</em></code> (see interface caveats below)</p>
</li>
</ul>
</div>
</li>
<li>
<p>Implementation Caveats</p>
<div class="ulist">
<ul>
<li>
<p>The <code>initialization</code> and <code>preinitialization</code> join points do not support
<code>around</code> advice</p>
</li>
<li>
<p>The <code>handler</code> join point does not support&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p><code>after advice</code></p>
</li>
<li>
<p><code>around</code> advice</p>
</li>
<li>
<p><code>cflow(handler(..))</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>Declaring members on an interface in an aspect affects only the
topmost implementing classes the implementation controls.</p>
</li>
<li>
<p><code>cflow</code> and <code>cflowbelow</code> pointcuts work within a single thread.</p>
</li>
<li>
<p>Runtime <code>ClassCastException</code> may result from supplying a supertype of
the actual type as an argument to <code>proceed(..)</code> in <code>around</code> advice.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</body>
</html>