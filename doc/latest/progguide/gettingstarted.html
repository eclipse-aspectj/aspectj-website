<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.20">
<title>Getting Started with AspectJ</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="./asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="./coderay-asciidoctor.css">
</head>
<body id="starting" class="article toc2 toc-left">
<div id="header">
<h1>Getting Started with AspectJ</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#starting-intro">Introduction</a></li>
<li><a href="#starting-aspectj">Introduction to AspectJ</a>
<ul class="sectlevel2">
<li><a href="#_the_dynamic_join_point_model">The Dynamic Join Point Model</a></li>
<li><a href="#pointcuts-starting">Pointcuts</a></li>
<li><a href="#advice-starting">Advice</a></li>
<li><a href="#_inter_type_declarations">Inter-type declarations</a></li>
<li><a href="#_aspects">Aspects</a></li>
</ul>
</li>
<li><a href="#starting-development">Development Aspects</a>
<ul class="sectlevel2">
<li><a href="#_tracing">Tracing</a></li>
<li><a href="#_profiling_and_logging">Profiling and Logging</a></li>
<li><a href="#pre-and-post-conditions">Pre- and Post-Conditions</a></li>
<li><a href="#_contract_enforcement">Contract Enforcement</a></li>
<li><a href="#_configuration_management">Configuration Management</a></li>
</ul>
</li>
<li><a href="#starting-production">Production Aspects</a>
<ul class="sectlevel2">
<li><a href="#_change_monitoring">Change Monitoring</a></li>
<li><a href="#_context_passing">Context Passing</a></li>
<li><a href="#starting-production-consistentBehavior">Providing Consistent Behavior</a></li>
</ul>
</li>
<li><a href="#starting-conclusion">Conclusion</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="starting-intro">Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Many software developers are attracted to the idea of aspect-oriented
programming (AOP) but unsure about how to begin using the technology.
They recognize the concept of crosscutting concerns, and know that they
have had problems with the implementation of such concerns in the past.
But there are many questions about how to adopt AOP into the development
process. Common questions include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Can I use aspects in my existing code?</p>
</li>
<li>
<p>What kinds of benefits can I expect to get from using aspects?</p>
</li>
<li>
<p>How do I find aspects in my programs?</p>
</li>
<li>
<p>How steep is the learning curve for AOP?</p>
</li>
<li>
<p>What are the risks of using this new technology?</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This chapter addresses these questions in the context of AspectJ: a
general-purpose aspect-oriented extension to Java. A series of abridged
examples illustrate the kinds of aspects programmers may want to
implement using AspectJ and the benefits associated with doing so.
Readers who would like to understand the examples in more detail, or who
want to learn how to program examples like these, can find more complete
examples and supporting material linked from the
<a href="https://www.eclipse.org/aspectj/">AspectJ web site</a>.</p>
</div>
<div class="paragraph">
<p>A significant risk in adopting any new technology is going too far too
fast. Concern about this risk causes many organizations to be
conservative about adopting new technology. To address this issue, the
examples in this chapter are grouped into three broad categories, with
aspects that are easier to adopt into existing development projects
coming earlier in this chapter. The next section,
<a href="#starting-aspectj">Introduction to AspectJ</a>, we present the core of
AspectJ&#8217;s features, and in <a href="#starting-development">Development
Aspects</a>, we present aspects that facilitate tasks such as debugging,
testing and performance tuning of applications. And, in the section
following, <a href="#starting-production">Production Aspects</a>, we present
aspects that implement crosscutting functionality common in Java
applications. We will defer discussing a third category of aspects,
reusable aspects, until <a href="language.html#language">The AspectJ Language</a>.</p>
</div>
<div class="paragraph">
<p>These categories are informal, and this ordering is not the only way to
adopt AspectJ. Some developers may want to use a production aspect right
away. But our experience with current AspectJ users suggests that this
is one ordering that allows developers to get experience with (and
benefit from) AOP technology quickly, while also minimizing risk.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="starting-aspectj">Introduction to AspectJ</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section presents a brief introduction to the features of AspectJ
used later in this chapter. These features are at the core of the
language, but this is by no means a complete overview of AspectJ.</p>
</div>
<div class="paragraph">
<p>The features are presented using a simple figure editor system. A
<code>Figure</code> consists of a number of <code>FigureElements</code>, which can be either
<code>Point</code>s or <code>Line</code>s. The <code>Figure</code> class provides factory services. There
is also a <code>Display</code>. Most example programs later in this chapter are
based on this system as well.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/figureUML.png" alt="UML for the <code>FigureEditor</code> example"></span></p>
</div>
<div class="paragraph">
<p>The motivation for AspectJ (and likewise for aspect-oriented
programming) is the realization that there are issues or concerns that
are not well captured by traditional programming methodologies. Consider
the problem of enforcing a security policy in some application. By its
nature, security cuts across many of the natural units of modularity of
the application. Moreover, the security policy must be uniformly applied
to any additions as the application evolves. And the security policy
that is being applied might itself evolve. Capturing concerns like a
security policy in a disciplined way is difficult and error-prone in a
traditional programming language.</p>
</div>
<div class="paragraph">
<p>Concerns like security cut across the natural units of modularity. For
object-oriented programming languages, the natural unit of modularity is
the class. But in object-oriented programming languages, crosscutting
concerns are not easily turned into classes precisely because they cut
across classes, and so these aren&#8217;t reusable, they can&#8217;t be refined or
inherited, they are spread through out the program in an undisciplined
way, in short, they are difficult to work with.</p>
</div>
<div class="paragraph">
<p>Aspect-oriented programming is a way of modularizing crosscutting
concerns much like object-oriented programming is a way of modularizing
common concerns. AspectJ is an implementation of aspect-oriented
programming for Java.</p>
</div>
<div class="paragraph">
<p>AspectJ adds to Java just one new concept, a join point&#8201;&#8212;&#8201;and that&#8217;s
really just a name for an existing Java concept. It adds to Java only a
few new constructs: pointcuts, advice, inter-type declarations and
aspects. Pointcuts and advice dynamically affect program flow,
inter-type declarations statically affects a program&#8217;s class hierarchy,
and aspects encapsulate these new constructs.</p>
</div>
<div class="paragraph">
<p>A <em>join point</em> is a well-defined point in the program flow. A <em>pointcut</em>
picks out certain join points and values at those points. A piece of
<em>advice</em> is code that is executed when a join point is reached. These
are the dynamic parts of AspectJ.</p>
</div>
<div class="paragraph">
<p>AspectJ also has different kinds of <em>inter-type declarations</em> that allow
the programmer to modify a program&#8217;s static structure, namely, the
members of its classes and the relationship between classes.</p>
</div>
<div class="paragraph">
<p>AspectJ&#8217;s <em>aspect</em> are the unit of modularity for crosscutting concerns.
They behave somewhat like Java classes, but may also include pointcuts,
advice and inter-type declarations.</p>
</div>
<div class="paragraph">
<p>In the sections immediately following, we are first going to look at
join points and how they compose into pointcuts. Then we will look at
advice, the code which is run when a pointcut is reached. We will see
how to combine pointcuts and advice into aspects, AspectJ&#8217;s reusable,
inheritable unit of modularity. Lastly, we will look at how to use
inter-type declarations to deal with crosscutting concerns of a
program&#8217;s class structure.</p>
</div>
<div class="sect2">
<h3 id="_the_dynamic_join_point_model">The Dynamic Join Point Model</h3>
<div class="paragraph">
<p>A critical element in the design of any aspect-oriented language is the
join point model. The join point model provides the common frame of
reference that makes it possible to define the dynamic structure of
crosscutting concerns. This chapter describes AspectJ&#8217;s dynamic join
points, in which join points are certain well-defined points in the
execution of the program.</p>
</div>
<div class="paragraph">
<p>AspectJ provides for many kinds of join points, but this chapter
discusses only one of them: method call join points. A method call join
point encompasses the actions of an object receiving a method call. It
includes all the actions that comprise a method call, starting after all
arguments are evaluated up to and including return (either normally or
by throwing an exception).</p>
</div>
<div class="paragraph">
<p>Each method call at runtime is a different join point, even if it comes
from the same call expression in the program. Many other join points may
run while a method call join point is executing&#8201;&#8212;&#8201;all the join points
that happen while executing the method body, and in those methods called
from the body. We say that these join points execute in the <em>dynamic
context</em> of the original call join point.</p>
</div>
</div>
<div class="sect2">
<h3 id="pointcuts-starting">Pointcuts</h3>
<div class="paragraph">
<p>In AspectJ, <em>pointcuts</em> pick out certain join points in the program
flow. For example, the pointcut</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">call(<span class="type">void</span> <span class="predefined-type">Point</span>.setX(<span class="type">int</span>))</code></pre>
</div>
</div>
<div class="paragraph">
<p>picks out each join point that is a call to a method that has the
signature <code>void Point.setX(int)</code> - that is, <code>Point</code>'s void <code>setX</code> method
with a single <code>int</code> parameter.</p>
</div>
<div class="paragraph">
<p>A pointcut can be built out of other pointcuts with and, or, and not
(spelled <code>&amp;&amp;</code>, <code>||</code>, and <code>!</code>). For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">call(<span class="type">void</span> <span class="predefined-type">Point</span>.setX(<span class="type">int</span>)) ||
call(<span class="type">void</span> <span class="predefined-type">Point</span>.setY(<span class="type">int</span>))</code></pre>
</div>
</div>
<div class="paragraph">
<p>picks out each join point that is either a call to <code>setX</code> or a call to
<code>setY</code>.</p>
</div>
<div class="paragraph">
<p>Pointcuts can identify join points from many different types - in other
words, they can crosscut types. For example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">call(<span class="type">void</span> FigureElement.setXY(<span class="type">int</span>,<span class="type">int</span>)) ||
call(<span class="type">void</span> <span class="predefined-type">Point</span>.setX(<span class="type">int</span>))              ||
call(<span class="type">void</span> <span class="predefined-type">Point</span>.setY(<span class="type">int</span>))              ||
call(<span class="type">void</span> <span class="predefined-type">Line</span>.setP1(<span class="predefined-type">Point</span>))            ||
call(<span class="type">void</span> <span class="predefined-type">Line</span>.setP2(<span class="predefined-type">Point</span>));</code></pre>
</div>
</div>
<div class="paragraph">
<p>picks out each join point that is a call to one of five methods (the
first of which is an interface method, by the way).</p>
</div>
<div class="paragraph">
<p>In our example system, this pointcut captures all the join points when a
<code>FigureElement</code> moves. While this is a useful way to specify this
crosscutting concern, it is a bit of a mouthful. So AspectJ allows
programmers to define their own named pointcuts with the <code>pointcut</code>
form. So the following declares a new, named pointcut:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">pointcut move():
  call(<span class="type">void</span> FigureElement.setXY(<span class="type">int</span>,<span class="type">int</span>)) ||
  call(<span class="type">void</span> <span class="predefined-type">Point</span>.setX(<span class="type">int</span>))              ||
  call(<span class="type">void</span> <span class="predefined-type">Point</span>.setY(<span class="type">int</span>))              ||
  call(<span class="type">void</span> <span class="predefined-type">Line</span>.setP1(<span class="predefined-type">Point</span>))            ||
  call(<span class="type">void</span> <span class="predefined-type">Line</span>.setP2(<span class="predefined-type">Point</span>));</code></pre>
</div>
</div>
<div class="paragraph">
<p>and whenever this definition is visible, the programmer can simply use
<code>move()</code> to capture this complicated pointcut.</p>
</div>
<div class="paragraph">
<p>The previous pointcuts are all based on explicit enumeration of a set of
method signatures. We sometimes call this <em>name-based</em> crosscutting.
AspectJ also provides mechanisms that enable specifying a pointcut in
terms of properties of methods other than their exact name. We call this
<em>property-based</em> crosscutting. The simplest of these involve using
wildcards in certain fields of the method signature. For example, the
pointcut</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">call(<span class="type">void</span> Figure.make*(..))</code></pre>
</div>
</div>
<div class="paragraph">
<p>picks out each join point that&#8217;s a call to a void method defined on
<code>Figure</code> whose the name begins with &#8220;make&#8221; regardless of the method&#8217;s
parameters. In our system, this picks out calls to the factory methods
<code>makePoint</code> and <code>makeLine</code>. The pointcut</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">call(<span class="directive">public</span> * Figure.* (..))</code></pre>
</div>
</div>
<div class="paragraph">
<p>picks out each call to <code>Figure</code>'s public methods.</p>
</div>
<div class="paragraph">
<p>But wildcards aren&#8217;t the only properties AspectJ supports. Another
pointcut, <code>cflow</code>, identifies join points based on whether they occur in
the dynamic context of other join points. So</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">cflow(move())</code></pre>
</div>
</div>
<div class="paragraph">
<p>picks out each join point that occurs in the dynamic context of the join
points picked out by <code>move()</code>, our named pointcut defined above. So this
picks out each join points that occurrs between when a move method is
called and when it returns (either normally or by throwing an
exception).</p>
</div>
</div>
<div class="sect2">
<h3 id="advice-starting">Advice</h3>
<div class="paragraph">
<p>So pointcuts pick out join points. But they don&#8217;t <em>do</em> anything apart
from picking out join points. To actually implement crosscutting
behavior, we use advice. Advice brings together a pointcut (to pick out
join points) and a body of code (to run at each of those join points).</p>
</div>
<div class="paragraph">
<p>AspectJ has several different kinds of advice. <em>Before advice</em> runs as a
join point is reached, before the program proceeds with the join point.
For example, before advice on a method call join point runs before the
actual method starts running, just after the arguments to the method
call are evaluated.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">before(): move() {
  <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">about to move</span><span class="delimiter">&quot;</span></span>);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>After advice</em> on a particular join point runs after the program
proceeds with that join point. For example, after advice on a method
call join point runs after the method body has run, just before before
control is returned to the caller. Because Java programs can leave a
join point 'normally' or by throwing an exception, there are three kinds
of after advice: <code>after returning</code>, <code>after
        throwing</code>, and plain <code>after</code> (which runs after returning <em>or</em>
throwing, like Java&#8217;s <code>finally</code>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">after() returning: move() {
  <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">just successfully moved</span><span class="delimiter">&quot;</span></span>);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Around advice</em> on a join point runs as the join point is reached, and
has explicit control over whether the program proceeds with the join
point. Around advice is not discussed in this section.</p>
</div>
<div class="sect3">
<h4 id="_exposing_context_in_pointcuts">Exposing Context in Pointcuts</h4>
<div class="paragraph">
<p>Pointcuts not only pick out join points, they can also expose part of
the execution context at their join points. Values exposed by a pointcut
can be used in the body of advice declarations.</p>
</div>
<div class="paragraph">
<p>An advice declaration has a parameter list (like a method) that gives
names to all the pieces of context that it uses. For example, the after
advice</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">after(FigureElement fe, <span class="type">int</span> x, <span class="type">int</span> y) returning:
  <span class="comment">// SomePointcut...</span>
{
  <span class="comment">// SomeBody</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>uses three pieces of exposed context, a <code>FigureElement</code> named fe, and
two <code>int</code>s named x and y.</p>
</div>
<div class="paragraph">
<p>The body of the advice uses the names just like method parameters, so</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">after(FigureElement fe, <span class="type">int</span> x, <span class="type">int</span> y) returning:
  <span class="comment">// SomePointcut...</span>
{
  <span class="predefined-type">System</span>.out.println(fe + <span class="string"><span class="delimiter">&quot;</span><span class="content"> moved to (</span><span class="delimiter">&quot;</span></span> + x + <span class="string"><span class="delimiter">&quot;</span><span class="content">, </span><span class="delimiter">&quot;</span></span> + y + <span class="string"><span class="delimiter">&quot;</span><span class="content">)</span><span class="delimiter">&quot;</span></span>);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The advice&#8217;s pointcut publishes the values for the advice&#8217;s arguments.
The three primitive pointcuts <code>this</code>, <code>target</code> and <code>args</code> are used to
publish these values. So now we can write the complete piece of advice:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">after(FigureElement fe, <span class="type">int</span> x, <span class="type">int</span> y) returning:
  call(<span class="type">void</span> FigureElement.setXY(<span class="type">int</span>, <span class="type">int</span>))
  &amp;&amp; target(fe)
  &amp;&amp; args(x, y)
{
  <span class="predefined-type">System</span>.out.println(fe + <span class="string"><span class="delimiter">&quot;</span><span class="content"> moved to (</span><span class="delimiter">&quot;</span></span> + x + <span class="string"><span class="delimiter">&quot;</span><span class="content">, </span><span class="delimiter">&quot;</span></span> + y + <span class="string"><span class="delimiter">&quot;</span><span class="content">)</span><span class="delimiter">&quot;</span></span>);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The pointcut exposes three values from calls to <code>setXY</code>: the target
<code>FigureElement</code>&#8201;&#8212;&#8201;which it publishes as <code>fe</code>, so it becomes the first
argument to the after advice&#8201;&#8212;&#8201;and the two int arguments&#8201;&#8212;&#8201;which it
publishes as <code>x</code> and <code>y</code>, so they become the second and third argument
to the after advice.</p>
</div>
<div class="paragraph">
<p>So the advice prints the figure element that was moved and its new <code>x</code>
and <code>y</code> coordinates after each <code>setXY</code> method call.</p>
</div>
<div class="paragraph">
<p>A named pointcut may have parameters like a piece of advice. When the
named pointcut is used (by advice, or in another named pointcut), it
publishes its context by name just like the <code>this</code>, <code>target</code> and <code>args</code>
pointcut. So another way to write the above advice is</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">pointcut setXY(FigureElement fe, <span class="type">int</span> x, <span class="type">int</span> y):
  call(<span class="type">void</span> FigureElement.setXY(<span class="type">int</span>, <span class="type">int</span>))
  &amp;&amp; target(fe)
  &amp;&amp; args(x, y);

after(FigureElement fe, <span class="type">int</span> x, <span class="type">int</span> y) returning: setXY(fe, x, y) {
  <span class="predefined-type">System</span>.out.println(fe + <span class="string"><span class="delimiter">&quot;</span><span class="content"> moved to (</span><span class="delimiter">&quot;</span></span> + x + <span class="string"><span class="delimiter">&quot;</span><span class="content">, </span><span class="delimiter">&quot;</span></span> + y + <span class="string"><span class="delimiter">&quot;</span><span class="content">).</span><span class="delimiter">&quot;</span></span>);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_inter_type_declarations">Inter-type declarations</h3>
<div class="paragraph">
<p>Inter-type declarations in AspectJ are declarations that cut across
classes and their hierarchies. They may declare members that cut across
multiple classes, or change the inheritance relationship between
classes. Unlike advice, which operates primarily dynamically,
introduction operates statically, at compile-time.</p>
</div>
<div class="paragraph">
<p>Consider the problem of expressing a capability shared by some existing
classes that are already part of a class hierarchy, i.e. they already
extend a class. In Java, one creates an interface that captures this new
capability, and then adds to <em>each affected class</em> a method that
implements this interface.</p>
</div>
<div class="paragraph">
<p>AspectJ can express the concern in one place, by using inter-type
declarations. The aspect declares the methods and fields that are
necessary to implement the new capability, and associates the methods
and fields to the existing classes.</p>
</div>
<div class="paragraph">
<p>Suppose we want to have <code>Screen</code> objects observe changes to <code>Point</code>
objects, where <code>Point</code> is an existing class. We can implement this by
writing an aspect declaring that the class Point <code>Point</code> has an instance
field, <code>observers</code>, that keeps track of the <code>Screen</code> objects that are
observing <code>Point</code>s.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect PointObserving {
  <span class="directive">private</span> <span class="predefined-type">Vector</span> <span class="predefined-type">Point</span>.observers = <span class="keyword">new</span> <span class="predefined-type">Vector</span>();
  <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>observers</code> field is private, so only <code>PointObserving</code> can see it.
So observers are added or removed with the static methods <code>addObserver</code>
and <code>removeObserver</code> on the aspect.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect PointObserving {
  <span class="directive">private</span> <span class="predefined-type">Vector</span> <span class="predefined-type">Point</span>.observers = <span class="keyword">new</span> <span class="predefined-type">Vector</span>();

  <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> addObserver(<span class="predefined-type">Point</span> p, Screen s) {
    p.observers.add(s);
  }
  <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> removeObserver(<span class="predefined-type">Point</span> p, Screen s) {
    p.observers.remove(s);
  }
  <span class="comment">//...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Along with this, we can define a pointcut <code>changes</code> that defines what we
want to observe, and the after advice defines what we want to do when we
observe a change.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect PointObserving {
  <span class="directive">private</span> <span class="predefined-type">Vector</span> <span class="predefined-type">Point</span>.observers = <span class="keyword">new</span> <span class="predefined-type">Vector</span>();

  <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> addObserver(<span class="predefined-type">Point</span> p, Screen s) {
    p.observers.add(s);
  }
  <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> removeObserver(<span class="predefined-type">Point</span> p, Screen s) {
    p.observers.remove(s);
  }

  pointcut changes(<span class="predefined-type">Point</span> p): target(p) &amp;&amp; call(<span class="type">void</span> <span class="predefined-type">Point</span>.set*(<span class="type">int</span>));

  after(<span class="predefined-type">Point</span> p): changes(p) {
    <span class="predefined-type">Iterator</span> iter = p.observers.iterator();
    <span class="keyword">while</span> ( iter.hasNext() ) {
      updateObserver(p, (Screen)iter.next());
    }
  }

  <span class="directive">static</span> <span class="type">void</span> updateObserver(<span class="predefined-type">Point</span> p, Screen s) {
    s.display(p);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that neither <code>Screen</code>'s nor <code>Point</code>'s code has to be modified, and
that all the changes needed to support this new capability are local to
this aspect.</p>
</div>
</div>
<div class="sect2">
<h3 id="_aspects">Aspects</h3>
<div class="paragraph">
<p>Aspects wrap up pointcuts, advice, and inter-type declarations in a a
modular unit of crosscutting implementation. It is defined very much
like a class, and can have methods, fields, and initializers in addition
to the crosscutting members. Because only aspects may include these
crosscutting members, the declaration of these effects is localized.</p>
</div>
<div class="paragraph">
<p>Like classes, aspects may be instantiated, but AspectJ controls how that
instantiation happens&#8201;&#8212;&#8201;so you can&#8217;t use Java&#8217;s <code>new</code> form to build new
aspect instances. By default, each aspect is a singleton, so one aspect
instance is created. This means that advice may use non-static fields of
the aspect, if it needs to keep state around:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect Logging {
  <span class="predefined-type">OutputStream</span> logStream = <span class="predefined-type">System</span>.err;

  before(): move() {
    logStream.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">about to move</span><span class="delimiter">&quot;</span></span>);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Aspects may also have more complicated rules for instantiation, but
these will be described in a later chapter.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="starting-development">Development Aspects</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The next two sections present the use of aspects in increasingly
sophisticated ways. Development aspects are easily removed from
production builds. Production aspects are intended to be used in both
development and in production, but tend to affect only a few classes.</p>
</div>
<div class="paragraph">
<p>This section presents examples of aspects that can be used during
development of Java applications. These aspects facilitate debugging,
testing and performance tuning work. The aspects define behavior that
ranges from simple tracing, to profiling, to testing of internal
consistency within the application. Using AspectJ makes it possible to
cleanly modularize this kind of functionality, thereby making it
possible to easily enable and disable the functionality when desired.</p>
</div>
<div class="sect2">
<h3 id="_tracing">Tracing</h3>
<div class="paragraph">
<p>This first example shows how to increase the visibility of the internal
workings of a program. It is a simple tracing aspect that prints a
message at specified method calls. In our figure editor example, one
such aspect might simply trace whenever points are drawn.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect SimpleTracing {
  pointcut tracedCall():
    call(<span class="type">void</span> FigureElement.draw(GraphicsContext));

  before(): tracedCall() {
    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Entering: </span><span class="delimiter">&quot;</span></span> + thisJoinPoint);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This code makes use of the <code>thisJoinPoint</code> special variable. Within all
advice bodies this variable is bound to an object that describes the
current join point. The effect of this code is to print a line like the
following every time a figure element receives a <code>draw</code> method call:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">Entering: call(void FigureElement.draw(GraphicsContext))</code></pre>
</div>
</div>
<div class="paragraph">
<p>To understand the benefit of coding this with AspectJ consider changing
the set of method calls that are traced. With AspectJ, this just
requires editing the definition of the <code>tracedCalls</code> pointcut and
recompiling. The individual methods that are traced do not need to be
edited.</p>
</div>
<div class="paragraph">
<p>When debugging, programmers often invest considerable effort in figuring
out a good set of trace points to use when looking for a particular kind
of problem. When debugging is complete or appears to be complete it is
frustrating to have to lose that investment by deleting trace statements
from the code. The alternative of just commenting them out makes the
code look bad, and can cause trace statements for one kind of debugging
to get confused with trace statements for another kind of debugging.</p>
</div>
<div class="paragraph">
<p>With AspectJ it is easy to both preserve the work of designing a good
set of trace points and disable the tracing when it isn&#8217;t being used.
This is done by writing an aspect specifically for that tracing mode,
and removing that aspect from the compilation when it is not needed.</p>
</div>
<div class="paragraph">
<p>This ability to concisely implement and reuse debugging configurations
that have proven useful in the past is a direct result of AspectJ
modularizing a crosscutting design element the set of methods that are
appropriate to trace when looking for a given kind of information.</p>
</div>
</div>
<div class="sect2">
<h3 id="_profiling_and_logging">Profiling and Logging</h3>
<div class="paragraph">
<p>Our second example shows you how to do some very specific profiling.
Although many sophisticated profiling tools are available, and these can
gather a variety of information and display the results in useful ways,
you may sometimes want to profile or log some very specific behavior. In
these cases, it is often possible to write a simple aspect similar to
the ones above to do the job.</p>
</div>
<div class="paragraph">
<p>For example, the following aspect counts the number of calls to the
<code>rotate</code> method on a <code>Line</code> and the number of calls to the <code>set*</code>
methods of a <code>Point</code> that happen within the control flow of those calls
to <code>rotate</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect SetsInRotateCounting {
  <span class="type">int</span> rotateCount = <span class="integer">0</span>;
  <span class="type">int</span> setCount = <span class="integer">0</span>;

  before(): call(<span class="type">void</span> <span class="predefined-type">Line</span>.rotate(<span class="type">double</span>)) {
    rotateCount++;
  }

  before():
    call(<span class="type">void</span> <span class="predefined-type">Point</span>.set*(<span class="type">int</span>)) &amp;&amp;
    cflow(call(<span class="type">void</span> <span class="predefined-type">Line</span>.rotate(<span class="type">double</span>)))
  {
    setCount++;
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In effect, this aspect allows the programmer to ask very specific
questions like</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>How many times is the <code>rotate</code> method defined on <code>Line</code> objects called?</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>and</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>How many times are methods defined on <code>Point</code> objects whose name begins with
<code>"set"</code> called in fulfilling those <code>rotate</code> calls?</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Such questions may be difficult to express using standard profiling or
logging tools.</p>
</div>
</div>
<div class="sect2">
<h3 id="pre-and-post-conditions">Pre- and Post-Conditions</h3>
<div class="paragraph">
<p>Many programmers use the "Design by Contract" style popularized by
Bertand Meyer in Object-Oriented Software Construction, 2/e. In this
style of programming, explicit pre-conditions test that callers of a
method call it properly and explicit post-conditions test that methods
properly do the work they are supposed to.</p>
</div>
<div class="paragraph">
<p>AspectJ makes it possible to implement pre- and post-condition testing
in modular form. For example, this code</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect PointBoundsChecking {

  pointcut setX(<span class="type">int</span> x):
    (call(<span class="type">void</span> FigureElement.setXY(<span class="type">int</span>, <span class="type">int</span>)) &amp;&amp; args(x, *))
    || (call(<span class="type">void</span> <span class="predefined-type">Point</span>.setX(<span class="type">int</span>)) &amp;&amp; args(x));

  pointcut setY(<span class="type">int</span> y):
    (call(<span class="type">void</span> FigureElement.setXY(<span class="type">int</span>, <span class="type">int</span>)) &amp;&amp; args(*, y))
    || (call(<span class="type">void</span> <span class="predefined-type">Point</span>.setY(<span class="type">int</span>)) &amp;&amp; args(y));

  before(<span class="type">int</span> x): setX(x) {
    <span class="keyword">if</span> ( x &lt; MIN_X || x &gt; MAX_X )
      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalArgumentException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">x is out of bounds.</span><span class="delimiter">&quot;</span></span>);
  }

  before(<span class="type">int</span> y): setY(y) {
    <span class="keyword">if</span> ( y &lt; MIN_Y || y &gt; MAX_Y )
      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalArgumentException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">y is out of bounds.</span><span class="delimiter">&quot;</span></span>);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>implements the bounds checking aspect of pre-condition testing for
operations that move points. Notice that the <code>setX</code> pointcut refers to
all the operations that can set a Point&#8217;s <code>x</code> coordinate; this includes
the <code>setX</code> method, as well as half of the <code>setXY</code> method. In this sense
the <code>setX</code> pointcut can be seen as involving very fine-grained
crosscutting - it names the the <code>setX</code> method and half of the <code>setXY</code>
method.</p>
</div>
<div class="paragraph">
<p>Even though pre- and post-condition testing aspects can often be used
only during testing, in some cases developers may wish to include them
in the production build as well. Again, because AspectJ makes it
possible to modularize these crosscutting concerns cleanly, it gives
developers good control over this decision.</p>
</div>
</div>
<div class="sect2">
<h3 id="_contract_enforcement">Contract Enforcement</h3>
<div class="paragraph">
<p>The property-based crosscutting mechanisms can be very useful in
defining more sophisticated contract enforcement. One very powerful use
of these mechanisms is to identify method calls that, in a correct
program, should not exist. For example, the following aspect enforces
the constraint that only the well-known factory methods can add an
element to the registry of figure elements. Enforcing this constraint
ensures that no figure element is added to the registry more than once.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect RegistrationProtection {

  pointcut register(): call(<span class="type">void</span> <span class="predefined-type">Registry</span>.register(FigureElement));
  pointcut canRegister(): withincode(<span class="directive">static</span> * FigureElement.make*(..));

  before(): register() &amp;&amp; !canRegister() {
    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalAccessException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Illegal call </span><span class="delimiter">&quot;</span></span> + thisJoinPoint);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This aspect uses the withincode primitive pointcut to denote all join
points that occur within the body of the factory methods on
<code>FigureElement</code> (the methods with names that begin with &#8220;make&#8221;). This
is a property-based pointcut because it identifies join points based not
on their signature, but rather on the property that they occur
specifically within the code of another method. The before advice
declaration effectively says signal an error for any calls to register
that are not within the factory methods.</p>
</div>
<div class="paragraph">
<p>This advice throws a runtime exception at certain join points, but
AspectJ can do better. Using the <code>declare error</code> form, we can have the
<em>compiler</em> signal the error.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect RegistrationProtection {

  pointcut register(): call(<span class="type">void</span> <span class="predefined-type">Registry</span>.register(FigureElement));
  pointcut canRegister(): withincode(<span class="directive">static</span> * FigureElement.make*(..));

  declare error: register() &amp;&amp; !canRegister(): <span class="string"><span class="delimiter">&quot;</span><span class="content">Illegal call</span><span class="delimiter">&quot;</span></span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When using this aspect, it is impossible for the compiler to compile
programs with these illegal calls. This early detection is not always
possible. In this case, since we depend only on static information (the
<code>withincode</code> pointcut picks out join points totally based on their code,
and the <code>call</code> pointcut here picks out join points statically). Other
enforcement, such as the precondition enforcement, above, does require
dynamic information such as the runtime value of parameters.</p>
</div>
</div>
<div class="sect2">
<h3 id="_configuration_management">Configuration Management</h3>
<div class="paragraph">
<p>Configuration management for aspects can be handled using a variety of
make-file like techniques. To work with optional aspects, the programmer
can simply define their make files to either include the aspect in the
call to the AspectJ compiler or not, as desired.</p>
</div>
<div class="paragraph">
<p>Developers who want to be certain that no aspects are included in the
production build can do so by configuring their make files so that they
use a traditional Java compiler for production builds. To make it easy
to write such make files, the AspectJ compiler has a command-line
interface that is consistent with ordinary Java compilers.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="starting-production">Production Aspects</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section presents examples of aspects that are inherently intended
to be included in the production builds of an application. Production
aspects tend to add functionality to an application rather than merely
adding more visibility of the internals of a program. Again, we begin
with name-based aspects and follow with property-based aspects.
Name-based production aspects tend to affect only a small number of
methods. For this reason, they are a good next step for projects
adopting AspectJ. But even though they tend to be small and simple, they
can often have a significant effect in terms of making the program
easier to understand and maintain.</p>
</div>
<div class="sect2">
<h3 id="_change_monitoring">Change Monitoring</h3>
<div class="paragraph">
<p>The first example production aspect shows how one might implement some
simple functionality where it is problematic to try and do it
explicitly. It supports the code that refreshes the display. The role of
the aspect is to maintain a dirty bit indicating whether or not an
object has moved since the last time the display was refreshed.</p>
</div>
<div class="paragraph">
<p>Implementing this functionality as an aspect is straightforward. The
<code>testAndClear</code> method is called by the display code to find out whether
a figure element has moved recently. This method returns the current
state of the dirty flag and resets it to false. The pointcut <code>move</code>
captures all the method calls that can move a figure element. The after
advice on <code>move</code> sets the dirty flag whenever an object moves.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect MoveTracking {
  <span class="directive">private</span> <span class="directive">static</span> <span class="type">boolean</span> dirty = <span class="predefined-constant">false</span>;

  <span class="directive">public</span> <span class="directive">static</span> <span class="type">boolean</span> testAndClear() {
    <span class="type">boolean</span> result = dirty;
    dirty = <span class="predefined-constant">false</span>;
    <span class="keyword">return</span> result;
  }

  pointcut move():
    call(<span class="type">void</span> FigureElement.setXY(<span class="type">int</span>, <span class="type">int</span>)) ||
    call(<span class="type">void</span> <span class="predefined-type">Line</span>.setP1(<span class="predefined-type">Point</span>))             ||
    call(<span class="type">void</span> <span class="predefined-type">Line</span>.setP2(<span class="predefined-type">Point</span>))             ||
    call(<span class="type">void</span> <span class="predefined-type">Point</span>.setX(<span class="type">int</span>))               ||
    call(<span class="type">void</span> <span class="predefined-type">Point</span>.setY(<span class="type">int</span>));

  after() returning: move() {
    dirty = <span class="predefined-constant">true</span>;
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Even this simple example serves to illustrate some of the important
benefits of using AspectJ in production code. Consider implementing this
functionality with ordinary Java: there would likely be a helper class
that contained the <code>dirty</code> flag, the <code>testAndClear</code> method, as well as a
<code>setFlag</code> method. Each of the methods that could move a figure element
would include a call to the <code>setFlag</code> method. Those calls, or rather the
concept that those calls should happen at each move operation, are the
crosscutting concern in this case.</p>
</div>
<div class="paragraph">
<p>The AspectJ implementation has several advantages over the standard
implementation:</p>
</div>
<div class="paragraph">
<p><em>The structure of the crosscutting concern is captured explicitly.</em> The
moves pointcut clearly states all the methods involved, so the
programmer reading the code sees not just individual calls to <code>setFlag</code>,
but instead sees the real structure of the code. The IDE support
included with AspectJ automatically reminds the programmer that this
aspect advises each of the methods involved. The IDE support also
provides commands to jump to the advice from the method and vice-versa.</p>
</div>
<div class="paragraph">
<p><em>Evolution is easier.</em> If, for example, the aspect needs to be revised
to record not just that some figure element moved, but rather to record
exactly which figure elements moved, the change would be entirely local
to the aspect. The pointcut would be updated to expose the object being
moved, and the advice would be updated to record that object. The paper
An Overview of AspectJ (available linked off of the AspectJ web site&#8201;&#8212;&#8201;<a href="https://eclipse.org/aspectj" class="bare">https://eclipse.org/aspectj</a>), presented at ECOOP 2001, presents a
detailed discussion of various ways this aspect could be expected to
evolve.</p>
</div>
<div class="paragraph">
<p><em>The functionality is easy to plug in and out.</em> Just as with development
aspects, production aspects may need to be removed from the system,
either because the functionality is no longer needed at all, or because
it is not needed in certain configurations of a system. Because the
functionality is modularized in a single aspect this is easy to do.</p>
</div>
<div class="paragraph">
<p><em>The implementation is more stable.</em> If, for example, the programmer
adds a subclass of <code>Line</code> that overrides the existing methods, this
advice in this aspect will still apply. In the ordinary Java
implementation the programmer would have to remember to add the call to
<code>setFlag</code> in the new overriding method. This benefit is often even more
compelling for property-based aspects (see the section
<a href="#starting-production-consistentBehavior">Providing Consistent
Behavior</a>).</p>
</div>
</div>
<div class="sect2">
<h3 id="_context_passing">Context Passing</h3>
<div class="paragraph">
<p>The crosscutting structure of context passing can be a significant
source of complexity in Java programs. Consider implementing
functionality that would allow a client of the figure editor (a program
client rather than a human) to set the color of any figure elements that
are created. Typically this requires passing a color, or a color
factory, from the client, down through the calls that lead to the figure
element factory. All programmers are familiar with the inconvenience of
adding a first argument to a number of methods just to pass this kind of
context information.</p>
</div>
<div class="paragraph">
<p>Using AspectJ, this kind of context passing can be implemented in a
modular way. The following code adds after advice that runs only when
the factory methods of <code>Figure</code> are called in the control flow of a
method on a <code>ColorControllingClient</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect ColorControl {
  pointcut CCClientCflow(ColorControllingClient client):
    cflow(call(* * (..)) &amp;&amp; target(client));

  pointcut make(): call(FigureElement Figure.make*(..));

  after (ColorControllingClient c) returning (FigureElement fe):
    make() &amp;&amp; CCClientCflow(c)
  {
    fe.setColor(c.colorFor(fe));
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This aspect affects only a small number of methods, but note that the
non-AOP implementation of this functionality might require editing many
more methods, specifically, all the methods in the control flow from the
client to the factory. This is a benefit common to many property-based
aspects while the aspect is short and affects only a modest number of
benefits, the complexity the aspect saves is potentially much larger.</p>
</div>
</div>
<div class="sect2">
<h3 id="starting-production-consistentBehavior">Providing Consistent Behavior</h3>
<div class="paragraph">
<p>This example shows how a property-based aspect can be used to provide
consistent handling of functionality across a large set of operations.
This aspect ensures that all public methods of the <code>com.bigboxco</code>
package log any Errors they throw to their caller (in Java, an Error is
like an Exception, but it indicates that something really bad and
usually unrecoverable has happened). The <code>publicMethodCall</code> pointcut
captures the public method calls of the package, and the after advice
runs whenever one of those calls throws an Error. The advice logs that
Error and then the throw resumes.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect PublicErrorLogging {
  Log log = <span class="keyword">new</span> Log();

  pointcut publicMethodCall():
    call(<span class="directive">public</span> * com.bigboxco.*.*(..));

  after() throwing (<span class="exception">Error</span> e): publicMethodCall() {
    log.write(e);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In some cases this aspect can log an exception twice. This happens if
code inside the <code>com.bigboxco</code> package itself calls a public method of
the package. In that case this code will log the error at both the
outermost call into the <code>com.bigboxco</code> package and the re-entrant call.
The <code>cflow</code> primitive pointcut can be used in a nice way to exclude
these re-entrant calls:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">after() throwing (<span class="exception">Error</span> e):
  publicMethodCall() &amp;&amp; !cflow(publicMethodCall())
{
  log.write(e);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following aspect is taken from work on the AspectJ compiler. The
aspect advises about 35 methods in the <code>JavaParser</code> class. The
individual methods handle each of the different kinds of elements that
must be parsed. They have names like <code>parseMethodDec</code>, <code>parseThrows</code>,
and <code>parseExpr</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">aspect ContextFilling {
  pointcut parse(JavaParser jp):
    call(* JavaParser.parse*(..))
    &amp;&amp; target(jp)
    &amp;&amp; !call(Stmt parseVarDec(<span class="type">boolean</span>)); <span class="comment">// var decs  are tricky</span>

  around(JavaParser jp) returns ASTObject: parse(jp) {
    Token beginToken = jp.peekToken();
    ASTObject ret = proceed(jp);
    <span class="keyword">if</span> (ret != <span class="predefined-constant">null</span>) jp.addContext(ret, beginToken);
      <span class="keyword">return</span> ret;
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This example exhibits a property found in many aspects with large
property-based pointcuts. In addition to a general property based
pattern <code>call(* JavaParser.parse*(..))</code> it includes an exception to the
pattern <code>!call(Stmt parseVarDec(boolean))</code>. The exclusion of <code>parseVarDec</code> happens
because the parsing of variable declarations in Java is too complex to
fit with the clean pattern of the other <code>parse*</code> methods. Even with the
explicit exclusion this aspect is a clear expression of a clean
crosscutting modularity. Namely that all <code>parse*</code> methods that return
<code>ASTObjects</code>, except for <code>parseVarDec</code> share a common behavior for
establishing the parse context of their result.</p>
</div>
<div class="paragraph">
<p>The process of writing an aspect with a large property-based pointcut,
and of developing the appropriate exceptions can clarify the structure
of the system. This is especially true, as in this case, when
refactoring existing code to use aspects. When we first looked at the
code for this aspect, we were able to use the IDE support provided in
AJDE for JBuilder to see what methods the aspect was advising compared
to our manual coding. We quickly discovered that there were a dozen
places where the aspect advice was in effect but we had not manually
inserted the required functionality. Two of these were bugs in our prior
non-AOP implementation of the parser. The other ten were needless
performance optimizations. So, here, refactoring the code to express the
crosscutting structure of the aspect explicitly made the code more
concise and eliminated latent bugs.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="starting-conclusion">Conclusion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>AspectJ is a simple and practical aspect-oriented extension to Java.
With just a few new constructs, AspectJ provides support for modular
implementation of a range of crosscutting concerns.</p>
</div>
<div class="paragraph">
<p>Adoption of AspectJ into an existing Java development project can be a
straightforward and incremental task. One path is to begin by using only
development aspects, going on to using production aspects and then
reusable aspects after building up experience with AspectJ. Adoption can
follow other paths as well. For example, some developers will benefit
from using production aspects right away. Others may be able to write
clean reusable aspects almost right away.</p>
</div>
<div class="paragraph">
<p>AspectJ enables both name-based and property based crosscutting. Aspects
that use name-based crosscutting tend to affect a small number of other
classes. But despite their small scale, they can often eliminate
significant complexity compared to an ordinary Java implementation.
Aspects that use property-based crosscutting can have small or large
scale.</p>
</div>
<div class="paragraph">
<p>Using AspectJ results in clean well-modularized implementations of
crosscutting concerns. When written as an AspectJ aspect the structure
of a crosscutting concern is explicit and easy to understand. Aspects
are also highly modular, making it possible to develop plug-and-play
implementations of crosscutting functionality.</p>
</div>
<div class="paragraph">
<p>AspectJ provides more functionality than was covered by this short
introduction. The next chapter, <a href="language.html#language">The AspectJ Language</a>, covers in detail
more of the features of the AspectJ language. The following chapter,
<a href="examples.html#examples">Examples</a>, then presents some carefully chosen examples that
show you how AspectJ might be used. We recommend that you read the next
two chapters carefully before deciding to adopt AspectJ into a project.</p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2024-02-01 14:58:10 +0700
</div>
</div>
</body>
</html>